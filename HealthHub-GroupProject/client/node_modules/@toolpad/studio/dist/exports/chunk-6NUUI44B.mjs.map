{"version":3,"sources":["../../src/canvas/index.tsx","../../src/utils/geometry.ts","../../src/canvas/ToolpadBridge.tsx"],"sourcesContent":["import * as React from 'react';\nimport invariant from 'invariant';\nimport { throttle } from 'lodash-es';\nimport {\n  queryClient,\n  FlowDirection,\n  SlotType,\n  useAppHost,\n  CanvasEventsContext,\n} from '@toolpad/studio-runtime';\nimport { update } from '@toolpad/utils/immutability';\nimport { AppCanvasState, NodeInfo, PageViewState, SlotsState } from '../types';\nimport {\n  getRelativeBoundingRect,\n  getRelativeOuterRect,\n  rectContainsPoint,\n} from '../utils/geometry';\nimport { ToolpadBridge, bridge, setCommandHandler } from './ToolpadBridge';\nimport { ToolpadApp, CanvasHooks, CanvasHooksContext } from '../runtime';\n\nconst handleScreenUpdate = throttle(\n  () => {\n    bridge?.canvasEvents.emit('screenUpdate', {});\n  },\n  50,\n  { trailing: true },\n);\n\nexport function updateNodeInfo(nodeInfo: NodeInfo, rootElm: Element): NodeInfo {\n  const nodeElm = rootElm.querySelector(`[data-toolpad-node-id=\"${nodeInfo.nodeId}\"]`);\n\n  if (!nodeElm) {\n    return nodeInfo;\n  }\n\n  const rect = getRelativeOuterRect(rootElm, nodeElm);\n\n  const slotElms = rootElm.querySelectorAll(`[data-toolpad-slot-parent=\"${nodeInfo.nodeId}\"]`);\n\n  const slots: SlotsState = {};\n\n  for (const slotElm of slotElms) {\n    const slotName = slotElm.getAttribute('data-toolpad-slot-name');\n    const slotType = slotElm.getAttribute('data-toolpad-slot-type');\n\n    invariant(slotName, 'Slot name not found');\n    invariant(slotType, 'Slot type not found');\n\n    if (slots[slotName]) {\n      continue;\n    }\n\n    const slotRect =\n      slotType === 'single'\n        ? getRelativeBoundingRect(rootElm, slotElm)\n        : getRelativeBoundingRect(rootElm, slotElm);\n\n    const display = window.getComputedStyle(slotElm).display;\n    let flowDirection: FlowDirection = 'row';\n    if (slotType === 'layout') {\n      flowDirection = 'column';\n    } else if (display === 'grid') {\n      const gridAutoFlow = window.getComputedStyle(slotElm).gridAutoFlow;\n      flowDirection = gridAutoFlow === 'row' ? 'column' : 'row';\n    } else if (display === 'flex') {\n      flowDirection = window.getComputedStyle(slotElm).flexDirection as FlowDirection;\n    }\n\n    slots[slotName] = {\n      type: slotType as SlotType,\n      rect: slotRect,\n      flowDirection,\n    };\n  }\n\n  return { ...nodeInfo, rect, slots };\n}\n\nexport interface AppCanvasProps {\n  state: AppCanvasState;\n  basename: string;\n}\n\nexport default function AppCanvas({ basename, state }: AppCanvasProps) {\n  const [readyBridge, setReadyBridge] = React.useState<ToolpadBridge | undefined>();\n\n  const appRootRef = React.useRef<HTMLDivElement>();\n  const appRootCleanupRef = React.useRef<() => void>();\n  const onAppRoot = React.useCallback((appRoot: HTMLDivElement) => {\n    appRootCleanupRef.current?.();\n    appRootCleanupRef.current = undefined;\n\n    if (!appRoot) {\n      return;\n    }\n\n    appRootRef.current = appRoot;\n\n    const mutationObserver = new MutationObserver(handleScreenUpdate);\n\n    mutationObserver.observe(appRoot, {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true,\n    });\n\n    const resizeObserver = new ResizeObserver(handleScreenUpdate);\n\n    resizeObserver.observe(appRoot);\n    appRoot.querySelectorAll('*').forEach((elm) => resizeObserver.observe(elm));\n\n    appRootCleanupRef.current = () => {\n      handleScreenUpdate.cancel();\n      mutationObserver.disconnect();\n      resizeObserver.disconnect();\n    };\n  }, []);\n\n  React.useEffect(\n    () => () => {\n      appRootCleanupRef.current?.();\n      appRootCleanupRef.current = undefined;\n    },\n    [],\n  );\n\n  // Notify host after every render\n  React.useEffect(() => {\n    if (appRootRef.current) {\n      // Only notify screen updates if the approot is rendered\n      handleScreenUpdate();\n    }\n  });\n\n  const viewState = React.useRef<PageViewState>({ nodes: {} });\n\n  React.useEffect(() => {\n    if (!bridge) {\n      return;\n    }\n\n    setCommandHandler(bridge.canvasCommands, 'getPageViewState', () => {\n      invariant(appRootRef.current, 'App root not found');\n      let nodes = viewState.current.nodes;\n\n      for (const [nodeId, nodeInfo] of Object.entries(nodes)) {\n        nodes = update(nodes, {\n          [nodeId]: updateNodeInfo(nodeInfo, appRootRef.current),\n        });\n      }\n\n      return { nodes };\n    });\n\n    setCommandHandler(bridge.canvasCommands, 'scrollComponent', (nodeId) => {\n      if (!nodeId) {\n        return;\n      }\n      invariant(appRootRef.current, 'App root not found');\n      const canvasNode = appRootRef.current.querySelector(`[data-node-id='${nodeId}']`);\n      canvasNode?.scrollIntoView({ behavior: 'instant', block: 'end', inline: 'end' });\n    });\n\n    setCommandHandler(bridge.canvasCommands, 'getViewCoordinates', (clientX, clientY) => {\n      if (!appRootRef.current) {\n        return null;\n      }\n      const rect = appRootRef.current.getBoundingClientRect();\n      if (rectContainsPoint(rect, clientX, clientY)) {\n        return { x: clientX - rect.x, y: clientY - rect.y };\n      }\n      return null;\n    });\n\n    setCommandHandler(bridge.canvasCommands, 'invalidateQueries', () => {\n      queryClient.invalidateQueries();\n    });\n\n    bridge.canvasEvents.emit('ready', {});\n    setReadyBridge(bridge);\n  }, []);\n\n  const savedNodes = state?.savedNodes;\n  const editorHooks: CanvasHooks = React.useMemo(() => {\n    return {\n      savedNodes,\n      registerNode: (node, props, componentConfig) => {\n        viewState.current.nodes[node.id] = {\n          nodeId: node.id,\n          props,\n          componentConfig,\n        };\n\n        return () => {\n          delete viewState.current.nodes[node.id];\n        };\n      },\n    };\n  }, [savedNodes]);\n\n  const appHost = useAppHost();\n\n  if (appHost.isCanvas) {\n    return readyBridge ? (\n      <CanvasHooksContext.Provider value={editorHooks}>\n        <CanvasEventsContext.Provider value={readyBridge.canvasEvents}>\n          <ToolpadApp rootRef={onAppRoot} basename={basename} state={state} />\n        </CanvasEventsContext.Provider>\n      </CanvasHooksContext.Provider>\n    ) : null;\n  }\n\n  return <ToolpadApp basename={basename} state={state} />;\n}\n","import { FlowDirection } from '@toolpad/studio-runtime';\n\nexport interface Rectangle {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\n/**\n * Calculates the Euclidian distance between two points\n */\nexport function distanceToPoint(x1: number, y1: number, x2: number, y2: number): number {\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n}\n/**\n * Calculates the shortest Euclidian distance from a point to a rectangle. Returns `0` if the\n * point falss within the rectangle.\n */\nexport function distanceToRect(rect: Rectangle, x: number, y: number) {\n  const left = rect.x;\n  const top = rect.y;\n  const right = rect.x + rect.width;\n  const bottom = rect.y + rect.height;\n  if (x < left && y < top) {\n    return distanceToPoint(x, y, left, top);\n  }\n  if (x > right && y < top) {\n    return distanceToPoint(x, y, right, top);\n  }\n  if (x > right && y > bottom) {\n    return distanceToPoint(x, y, right, bottom);\n  }\n  if (x < left && y > bottom) {\n    return distanceToPoint(x, y, left, bottom);\n  }\n  if (x < left) {\n    return left - x;\n  }\n  if (x > right) {\n    return x - right;\n  }\n  if (y < top) {\n    return top - y;\n  }\n  if (y > bottom) {\n    return y - bottom;\n  }\n  return 0;\n}\n\n/**\n * Calculates the shortes Euclidian distance from a point to a line segment.\n * All credit goes to https://stackoverflow.com/a/6853926/419436\n * I was too lazy to figure out the math\n */\nexport function distanceToLine(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x: number,\n  y: number,\n): number {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const lenSq = C * C + D * D;\n  let param = -1;\n  if (lenSq > 0) {\n    // in case of 0 length line\n    param = dot / lenSq;\n  }\n\n  let xx;\n  let yy;\n\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * Translates a `Rectangle` into CSS properties for absolutely positioned elements.\n */\nexport function absolutePositionCss({ x, y, width, height }: Rectangle): React.CSSProperties {\n  return { left: x, top: y, width, height };\n}\n\nexport function isHorizontalFlow(flowDirection: FlowDirection): boolean {\n  return flowDirection === 'row' || flowDirection === 'row-reverse';\n}\n\nexport function isVerticalFlow(flowDirection: FlowDirection): boolean {\n  return flowDirection === 'column' || flowDirection === 'column-reverse';\n}\n\nexport function isReverseFlow(flowDirection: FlowDirection): boolean {\n  return flowDirection === 'row-reverse' || flowDirection === 'column-reverse';\n}\n\n/**\n * Returns the bounding client rect of an element relative to its container.\n */\nexport function getRelativeBoundingRect(containerElm: Element, childElm: Element): Rectangle {\n  const containerRect = containerElm.getBoundingClientRect();\n  const childRect = childElm.getBoundingClientRect();\n\n  return {\n    x: childRect.x - containerRect.x,\n    y: childRect.y - containerRect.y,\n    width: childRect.width,\n    height: childRect.height,\n  };\n}\n\n/**\n * Returns the bounding box of an element against another element.\n * Considers the box model to return the full dimensions, including padding/border/margin.\n */\nexport function getRelativeOuterRect(containerElm: Element, childElm: Element): Rectangle {\n  const { x, y, width, height } = getRelativeBoundingRect(containerElm, childElm);\n  const styles = window.getComputedStyle(childElm);\n\n  const parseMarginStyle = (style: string): number => (style === 'auto' ? 0 : parseFloat(style));\n\n  let offsetLeft = parseMarginStyle(styles.marginLeft);\n  let offsetRight = parseMarginStyle(styles.marginRight);\n  let offsetTop = parseMarginStyle(styles.marginTop);\n  let offsetBottom = parseMarginStyle(styles.marginBottom);\n\n  if (styles.boxSizing === 'content-box') {\n    offsetLeft += parseFloat(styles.paddingLeft) + parseFloat(styles.borderLeftWidth);\n    offsetRight += parseFloat(styles.paddingRight) + parseFloat(styles.borderRightWidth);\n    offsetTop += parseFloat(styles.paddingTop) + parseFloat(styles.borderTopWidth);\n    offsetBottom += parseFloat(styles.paddingBottom) + parseFloat(styles.borderBottomWidth);\n  }\n\n  return {\n    x: x - offsetLeft,\n    y: y - offsetTop,\n    width: width + offsetLeft + offsetRight,\n    height: height + offsetTop + offsetBottom,\n  };\n}\n\n/**\n * Checks whether a point falls within a reactangle\n */\nexport function rectContainsPoint(rect: Rectangle, x: number, y: number): boolean {\n  return rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y;\n}\n\nexport const RECTANGLE_EDGE_TOP = 'top';\nexport const RECTANGLE_EDGE_BOTTOM = 'bottom';\nexport const RECTANGLE_EDGE_LEFT = 'left';\nexport const RECTANGLE_EDGE_RIGHT = 'right';\nexport type RectangleEdge =\n  | typeof RECTANGLE_EDGE_TOP\n  | typeof RECTANGLE_EDGE_BOTTOM\n  | typeof RECTANGLE_EDGE_LEFT\n  | typeof RECTANGLE_EDGE_RIGHT;\n\nexport function getRectanglePointActiveEdge(\n  rect: Rectangle,\n  x: number,\n  y: number,\n): RectangleEdge | null {\n  const { height: rectHeight, width: rectWidth } = rect;\n\n  // Out of bounds\n  if (x < 0 || x > rectWidth || y < 0 || y > rectHeight) {\n    return null;\n  }\n\n  const isOverFirstDiagonal = y < (rectHeight / rectWidth) * x;\n  const isOverSecondDiagonal = y < -1 * (rectHeight / rectWidth) * x + rectHeight;\n\n  if (isOverFirstDiagonal && isOverSecondDiagonal) {\n    return RECTANGLE_EDGE_TOP;\n  }\n  if (isOverFirstDiagonal) {\n    return RECTANGLE_EDGE_RIGHT;\n  }\n  if (isOverSecondDiagonal) {\n    return RECTANGLE_EDGE_LEFT;\n  }\n  return RECTANGLE_EDGE_BOTTOM;\n}\n","import { Emitter } from '@toolpad/utils/events';\nimport type { RuntimeEvents } from '@toolpad/studio-runtime';\nimport type { PageViewState } from '../types';\n\nconst COMMAND_HANDLERS = Symbol('hidden property to hold the command handlers');\n\ntype Commands<T extends Record<string, Function>> = T & {\n  [COMMAND_HANDLERS]: Partial<T>;\n};\n\nexport function createCommands<T extends Record<string, Function>>(\n  initial: Partial<T> = {},\n): Commands<T> {\n  return new Proxy(\n    {\n      [COMMAND_HANDLERS]: initial,\n    },\n    {\n      get(target, prop, receiver) {\n        if (typeof prop !== 'string') {\n          return Reflect.get(target, prop, receiver);\n        }\n\n        return (...args: any[]): any => {\n          const handler = target[COMMAND_HANDLERS][prop];\n          if (typeof handler !== 'function') {\n            throw new Error(`Command \"${prop}\" not recognized.`);\n          }\n          return handler(...args);\n        };\n      },\n    },\n  ) as Commands<T>;\n}\n\nexport function setCommandHandler<T extends Record<string, Function>, K extends keyof T & string>(\n  commands: Commands<T>,\n  name: K,\n  handler: T[K],\n) {\n  commands[COMMAND_HANDLERS][name] = handler;\n}\n\n// Interface to communicate between editor and canvas\nexport interface ToolpadBridge {\n  // Events fired in the editor, listened in the canvas\n  editorEvents: Emitter<{}>;\n  // Commands executed from the canvas, ran in the editor\n  editorCommands: Commands<{}>;\n  // Events fired in the canvas, listened in the editor\n  canvasEvents: Emitter<RuntimeEvents>;\n  // Commands executed from the editor, ran in the canvas\n  canvasCommands: Commands<{\n    getViewCoordinates(clientX: number, clientY: number): { x: number; y: number } | null;\n    getPageViewState(): PageViewState;\n    scrollComponent(nodeId: string): void;\n    isReady(): boolean;\n    invalidateQueries(): void;\n  }>;\n}\nconst isRenderedInCanvas =\n  typeof window !== 'undefined' &&\n  (window.frameElement as HTMLIFrameElement | null)?.dataset.toolpadCanvas;\n\nlet canvasIsReady = false;\n\nconst bridge: ToolpadBridge | null = isRenderedInCanvas\n  ? ({\n      editorEvents: new Emitter(),\n      editorCommands: createCommands(),\n      canvasEvents: new Emitter(),\n      canvasCommands: createCommands({\n        isReady: () => canvasIsReady,\n        getPageViewState: () => {\n          throw new Error('Not implemented');\n        },\n        scrollComponent: () => {\n          throw new Error('Not Implemented');\n        },\n        getViewCoordinates: () => {\n          throw new Error('Not implemented');\n        },\n        invalidateQueries: () => {\n          throw new Error('Not implemented');\n        },\n        update: () => {\n          throw new Error('Not implemented');\n        },\n      }),\n    } satisfies ToolpadBridge)\n  : null;\n\nbridge?.canvasEvents.on('ready', () => {\n  canvasIsReady = true;\n});\n\nexport { bridge };\n"],"mappings":"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","names":[]}