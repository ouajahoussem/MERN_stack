import {
  CanvasHooksContext,
  ToolpadApp
} from "./chunk-SHTVBEAG.mjs";

// src/canvas/index.tsx
import * as React from "react";
import invariant from "invariant";
import { throttle } from "lodash-es";
import {
  queryClient,
  useAppHost,
  CanvasEventsContext
} from "@toolpad/studio-runtime";
import { update } from "@toolpad/utils/immutability";

// src/utils/geometry.ts
function absolutePositionCss({ x, y, width, height }) {
  return { left: x, top: y, width, height };
}
function isHorizontalFlow(flowDirection) {
  return flowDirection === "row" || flowDirection === "row-reverse";
}
function isVerticalFlow(flowDirection) {
  return flowDirection === "column" || flowDirection === "column-reverse";
}
function isReverseFlow(flowDirection) {
  return flowDirection === "row-reverse" || flowDirection === "column-reverse";
}
function getRelativeBoundingRect(containerElm, childElm) {
  const containerRect = containerElm.getBoundingClientRect();
  const childRect = childElm.getBoundingClientRect();
  return {
    x: childRect.x - containerRect.x,
    y: childRect.y - containerRect.y,
    width: childRect.width,
    height: childRect.height
  };
}
function getRelativeOuterRect(containerElm, childElm) {
  const { x, y, width, height } = getRelativeBoundingRect(containerElm, childElm);
  const styles = window.getComputedStyle(childElm);
  const parseMarginStyle = (style) => style === "auto" ? 0 : parseFloat(style);
  let offsetLeft = parseMarginStyle(styles.marginLeft);
  let offsetRight = parseMarginStyle(styles.marginRight);
  let offsetTop = parseMarginStyle(styles.marginTop);
  let offsetBottom = parseMarginStyle(styles.marginBottom);
  if (styles.boxSizing === "content-box") {
    offsetLeft += parseFloat(styles.paddingLeft) + parseFloat(styles.borderLeftWidth);
    offsetRight += parseFloat(styles.paddingRight) + parseFloat(styles.borderRightWidth);
    offsetTop += parseFloat(styles.paddingTop) + parseFloat(styles.borderTopWidth);
    offsetBottom += parseFloat(styles.paddingBottom) + parseFloat(styles.borderBottomWidth);
  }
  return {
    x: x - offsetLeft,
    y: y - offsetTop,
    width: width + offsetLeft + offsetRight,
    height: height + offsetTop + offsetBottom
  };
}
function rectContainsPoint(rect, x, y) {
  return rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y;
}
var RECTANGLE_EDGE_TOP = "top";
var RECTANGLE_EDGE_BOTTOM = "bottom";
var RECTANGLE_EDGE_LEFT = "left";
var RECTANGLE_EDGE_RIGHT = "right";
function getRectanglePointActiveEdge(rect, x, y) {
  const { height: rectHeight, width: rectWidth } = rect;
  if (x < 0 || x > rectWidth || y < 0 || y > rectHeight) {
    return null;
  }
  const isOverFirstDiagonal = y < rectHeight / rectWidth * x;
  const isOverSecondDiagonal = y < -1 * (rectHeight / rectWidth) * x + rectHeight;
  if (isOverFirstDiagonal && isOverSecondDiagonal) {
    return RECTANGLE_EDGE_TOP;
  }
  if (isOverFirstDiagonal) {
    return RECTANGLE_EDGE_RIGHT;
  }
  if (isOverSecondDiagonal) {
    return RECTANGLE_EDGE_LEFT;
  }
  return RECTANGLE_EDGE_BOTTOM;
}

// src/canvas/ToolpadBridge.tsx
import { Emitter } from "@toolpad/utils/events";
var COMMAND_HANDLERS = Symbol("hidden property to hold the command handlers");
function createCommands(initial = {}) {
  return new Proxy(
    {
      [COMMAND_HANDLERS]: initial
    },
    {
      get(target, prop, receiver) {
        if (typeof prop !== "string") {
          return Reflect.get(target, prop, receiver);
        }
        return (...args) => {
          const handler = target[COMMAND_HANDLERS][prop];
          if (typeof handler !== "function") {
            throw new Error(`Command "${prop}" not recognized.`);
          }
          return handler(...args);
        };
      }
    }
  );
}
function setCommandHandler(commands, name, handler) {
  commands[COMMAND_HANDLERS][name] = handler;
}
var isRenderedInCanvas = typeof window !== "undefined" && window.frameElement?.dataset.toolpadCanvas;
var canvasIsReady = false;
var bridge = isRenderedInCanvas ? {
  editorEvents: new Emitter(),
  editorCommands: createCommands(),
  canvasEvents: new Emitter(),
  canvasCommands: createCommands({
    isReady: () => canvasIsReady,
    getPageViewState: () => {
      throw new Error("Not implemented");
    },
    scrollComponent: () => {
      throw new Error("Not Implemented");
    },
    getViewCoordinates: () => {
      throw new Error("Not implemented");
    },
    invalidateQueries: () => {
      throw new Error("Not implemented");
    },
    update: () => {
      throw new Error("Not implemented");
    }
  })
} : null;
bridge?.canvasEvents.on("ready", () => {
  canvasIsReady = true;
});

// src/canvas/index.tsx
var handleScreenUpdate = throttle(
  () => {
    bridge?.canvasEvents.emit("screenUpdate", {});
  },
  50,
  { trailing: true }
);
function updateNodeInfo(nodeInfo, rootElm) {
  const nodeElm = rootElm.querySelector(`[data-toolpad-node-id="${nodeInfo.nodeId}"]`);
  if (!nodeElm) {
    return nodeInfo;
  }
  const rect = getRelativeOuterRect(rootElm, nodeElm);
  const slotElms = rootElm.querySelectorAll(`[data-toolpad-slot-parent="${nodeInfo.nodeId}"]`);
  const slots = {};
  for (const slotElm of slotElms) {
    const slotName = slotElm.getAttribute("data-toolpad-slot-name");
    const slotType = slotElm.getAttribute("data-toolpad-slot-type");
    invariant(slotName, "Slot name not found");
    invariant(slotType, "Slot type not found");
    if (slots[slotName]) {
      continue;
    }
    const slotRect = slotType === "single" ? getRelativeBoundingRect(rootElm, slotElm) : getRelativeBoundingRect(rootElm, slotElm);
    const display = window.getComputedStyle(slotElm).display;
    let flowDirection = "row";
    if (slotType === "layout") {
      flowDirection = "column";
    } else if (display === "grid") {
      const gridAutoFlow = window.getComputedStyle(slotElm).gridAutoFlow;
      flowDirection = gridAutoFlow === "row" ? "column" : "row";
    } else if (display === "flex") {
      flowDirection = window.getComputedStyle(slotElm).flexDirection;
    }
    slots[slotName] = {
      type: slotType,
      rect: slotRect,
      flowDirection
    };
  }
  return { ...nodeInfo, rect, slots };
}
function AppCanvas({ basename, state }) {
  const [readyBridge, setReadyBridge] = React.useState();
  const appRootRef = React.useRef();
  const appRootCleanupRef = React.useRef();
  const onAppRoot = React.useCallback((appRoot) => {
    appRootCleanupRef.current?.();
    appRootCleanupRef.current = void 0;
    if (!appRoot) {
      return;
    }
    appRootRef.current = appRoot;
    const mutationObserver = new MutationObserver(handleScreenUpdate);
    mutationObserver.observe(appRoot, {
      attributes: true,
      childList: true,
      subtree: true,
      characterData: true
    });
    const resizeObserver = new ResizeObserver(handleScreenUpdate);
    resizeObserver.observe(appRoot);
    appRoot.querySelectorAll("*").forEach((elm) => resizeObserver.observe(elm));
    appRootCleanupRef.current = () => {
      handleScreenUpdate.cancel();
      mutationObserver.disconnect();
      resizeObserver.disconnect();
    };
  }, []);
  React.useEffect(
    () => () => {
      appRootCleanupRef.current?.();
      appRootCleanupRef.current = void 0;
    },
    []
  );
  React.useEffect(() => {
    if (appRootRef.current) {
      handleScreenUpdate();
    }
  });
  const viewState = React.useRef({ nodes: {} });
  React.useEffect(() => {
    if (!bridge) {
      return;
    }
    setCommandHandler(bridge.canvasCommands, "getPageViewState", () => {
      invariant(appRootRef.current, "App root not found");
      let nodes = viewState.current.nodes;
      for (const [nodeId, nodeInfo] of Object.entries(nodes)) {
        nodes = update(nodes, {
          [nodeId]: updateNodeInfo(nodeInfo, appRootRef.current)
        });
      }
      return { nodes };
    });
    setCommandHandler(bridge.canvasCommands, "scrollComponent", (nodeId) => {
      if (!nodeId) {
        return;
      }
      invariant(appRootRef.current, "App root not found");
      const canvasNode = appRootRef.current.querySelector(`[data-node-id='${nodeId}']`);
      canvasNode?.scrollIntoView({ behavior: "instant", block: "end", inline: "end" });
    });
    setCommandHandler(bridge.canvasCommands, "getViewCoordinates", (clientX, clientY) => {
      if (!appRootRef.current) {
        return null;
      }
      const rect = appRootRef.current.getBoundingClientRect();
      if (rectContainsPoint(rect, clientX, clientY)) {
        return { x: clientX - rect.x, y: clientY - rect.y };
      }
      return null;
    });
    setCommandHandler(bridge.canvasCommands, "invalidateQueries", () => {
      queryClient.invalidateQueries();
    });
    bridge.canvasEvents.emit("ready", {});
    setReadyBridge(bridge);
  }, []);
  const savedNodes = state?.savedNodes;
  const editorHooks = React.useMemo(() => {
    return {
      savedNodes,
      registerNode: (node, props, componentConfig) => {
        viewState.current.nodes[node.id] = {
          nodeId: node.id,
          props,
          componentConfig
        };
        return () => {
          delete viewState.current.nodes[node.id];
        };
      }
    };
  }, [savedNodes]);
  const appHost = useAppHost();
  if (appHost.isCanvas) {
    return readyBridge ? /* @__PURE__ */ React.createElement(CanvasHooksContext.Provider, { value: editorHooks }, /* @__PURE__ */ React.createElement(CanvasEventsContext.Provider, { value: readyBridge.canvasEvents }, /* @__PURE__ */ React.createElement(ToolpadApp, { rootRef: onAppRoot, basename, state }))) : null;
  }
  return /* @__PURE__ */ React.createElement(ToolpadApp, { basename, state });
}

export {
  absolutePositionCss,
  isHorizontalFlow,
  isVerticalFlow,
  isReverseFlow,
  rectContainsPoint,
  RECTANGLE_EDGE_TOP,
  RECTANGLE_EDGE_BOTTOM,
  RECTANGLE_EDGE_LEFT,
  RECTANGLE_EDGE_RIGHT,
  getRectanglePointActiveEdge,
  createCommands,
  updateNodeInfo,
  AppCanvas
};
//# sourceMappingURL=chunk-6NUUI44B.mjs.map