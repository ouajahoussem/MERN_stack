"use strict";var se=Object.defineProperty;var Ae=Object.getOwnPropertyDescriptor;var Re=Object.getOwnPropertyNames;var Ee=Object.prototype.hasOwnProperty;var J=(o,t)=>()=>(o&&(t=o(o=0)),t);var $=(o,t)=>{for(var e in t)se(o,e,{get:t[e],enumerable:!0})},oe=(o,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Re(t))!Ee.call(o,n)&&n!==e&&se(o,n,{get:()=>t[n],enumerable:!(r=Ae(t,n))||r.enumerable});return o},S=(o,t,e)=>(oe(o,t,"default"),e&&oe(e,t,"default"));var Fe=o=>oe(se({},"__esModule",{value:!0}),o);function p(...o){ae&&console.log(...o)}var ae,M=J(()=>{"use strict";ae=!1});var ue={};$(ue,{QuickJSAsyncifyError:()=>j,QuickJSAsyncifySuspended:()=>z,QuickJSEmscriptenModuleError:()=>V,QuickJSMemoryLeakDetected:()=>H,QuickJSNotImplemented:()=>D,QuickJSPromisePending:()=>W,QuickJSUnknownIntrinsic:()=>Y,QuickJSUnwrapError:()=>F,QuickJSUseAfterFree:()=>L,QuickJSWrongOwner:()=>N});var F,N,L,D,j,z,H,V,Y,W,v=J(()=>{"use strict";F=class extends Error{constructor(e,r){super(String(e));this.cause=e;this.context=r;this.name="QuickJSUnwrapError"}},N=class extends Error{constructor(){super(...arguments);this.name="QuickJSWrongOwner"}},L=class extends Error{constructor(){super(...arguments);this.name="QuickJSUseAfterFree"}},D=class extends Error{constructor(){super(...arguments);this.name="QuickJSNotImplemented"}},j=class extends Error{constructor(){super(...arguments);this.name="QuickJSAsyncifyError"}},z=class extends Error{constructor(){super(...arguments);this.name="QuickJSAsyncifySuspended"}},H=class extends Error{constructor(){super(...arguments);this.name="QuickJSMemoryLeakDetected"}},V=class extends Error{constructor(){super(...arguments);this.name="QuickJSEmscriptenModuleError"}},Y=class extends TypeError{constructor(){super(...arguments);this.name="QuickJSUnknownIntrinsic"}},W=class extends Error{constructor(){super(...arguments);this.name="QuickJSPromisePending"}}});function*be(o){return yield o}function Le(o){return be(me(o))}function ce(o,t){return(...e)=>{let r=t.call(o,le,...e);return me(r)}}function ge(o,t){let e=t.call(o,le);return me(e)}function me(o){function t(e){return e.done?e.value:e.value instanceof Promise?e.value.then(r=>t(o.next(r)),r=>t(o.throw(r))):t(o.next(e.value))}return t(o.next())}var le,de=J(()=>{"use strict";le=be;le.of=Le});function pe(o,t){let e;try{o.dispose()}catch(r){e=r}if(t&&e)throw Object.assign(t,{message:`${t.message}
 Then, failed to dispose scope: ${e.message}`,disposeError:e}),t;if(t||e)throw t||e}var x,Qe,Me,m,k,O,y,b=J(()=>{"use strict";de();M();v();x=class{[Symbol.dispose](){return this.dispose()}},Qe=Symbol.dispose??Symbol.for("Symbol.dispose"),Me=x.prototype;Me[Qe]||(Me[Qe]=function(){return this.dispose()});m=class o extends x{constructor(e,r,n,i){super();this._value=e;this.copier=r;this.disposer=n;this._owner=i;this._alive=!0;this._constructorStack=ae?new Error("Lifetime constructed").stack:void 0}get alive(){return this._alive}get value(){return this.assertAlive(),this._value}get owner(){return this._owner}get dupable(){return!!this.copier}dup(){if(this.assertAlive(),!this.copier)throw new Error("Non-dupable lifetime");return new o(this.copier(this._value),this.copier,this.disposer,this._owner)}consume(e){this.assertAlive();let r=e(this);return this.dispose(),r}dispose(){this.assertAlive(),this.disposer&&this.disposer(this._value),this._alive=!1}assertAlive(){if(!this.alive)throw this._constructorStack?new L(`Lifetime not alive
${this._constructorStack}
Lifetime used`):new L("Lifetime not alive")}},k=class extends m{constructor(t,e){super(t,void 0,void 0,e)}get dupable(){return!0}dup(){return this}dispose(){}},O=class extends m{constructor(t,e,r,n){super(t,e,r,n)}dispose(){this._alive=!1}};y=class o extends x{constructor(){super(...arguments);this._disposables=new m(new Set)}static withScope(e){let r=new o,n;try{return e(r)}catch(i){throw n=i,i}finally{pe(r,n)}}static withScopeMaybeAsync(e,r){return ge(void 0,function*(n){let i=new o,s;try{return yield*n.of(r.call(e,n,i))}catch(u){throw s=u,u}finally{pe(i,s)}})}static async withScopeAsync(e){let r=new o,n;try{return await e(r)}catch(i){throw n=i,i}finally{pe(r,n)}}manage(e){return this._disposables.value.add(e),e}get alive(){return this._disposables.alive}dispose(){let e=Array.from(this._disposables.value.values()).reverse();for(let r of e)r.alive&&r.dispose();this._disposables.dispose()}}});var U,fe=J(()=>{"use strict";b();U=class extends x{constructor(e){super();this.resolve=e=>{this.resolveHandle.alive&&(this.context.unwrapResult(this.context.callFunction(this.resolveHandle,this.context.undefined,e||this.context.undefined)).dispose(),this.disposeResolvers(),this.onSettled())};this.reject=e=>{this.rejectHandle.alive&&(this.context.unwrapResult(this.context.callFunction(this.rejectHandle,this.context.undefined,e||this.context.undefined)).dispose(),this.disposeResolvers(),this.onSettled())};this.dispose=()=>{this.handle.alive&&this.handle.dispose(),this.disposeResolvers()};this.context=e.context,this.owner=e.context.runtime,this.handle=e.promiseHandle,this.settled=new Promise(r=>{this.onSettled=r}),this.resolveHandle=e.resolveHandle,this.rejectHandle=e.rejectHandle}get alive(){return this.handle.alive||this.resolveHandle.alive||this.rejectHandle.alive}disposeResolvers(){this.resolveHandle.alive&&this.resolveHandle.dispose(),this.rejectHandle.alive&&this.rejectHandle.dispose()}}});var _,he=J(()=>{"use strict";b();_=class{constructor(t){this.module=t}toPointerArray(t){let e=new Int32Array(t.map(s=>s.value)),r=e.length*e.BYTES_PER_ELEMENT,n=this.module._malloc(r);return new Uint8Array(this.module.HEAPU8.buffer,n,r).set(new Uint8Array(e.buffer)),new m(n,void 0,s=>this.module._free(s))}newMutablePointerArray(t){let e=new Int32Array(new Array(t).fill(0)),r=e.length*e.BYTES_PER_ELEMENT,n=this.module._malloc(r),i=new Int32Array(this.module.HEAPU8.buffer,n,t);return i.set(e),new m({typedArray:i,ptr:n},void 0,s=>this.module._free(s.ptr))}newHeapCharPointer(t){let e=this.module.lengthBytesUTF8(t),r=e+1,n=this.module._malloc(r);return this.module.stringToUTF8(t,n,r),new m({ptr:n,strlen:e},void 0,i=>this.module._free(i.ptr))}newHeapBufferPointer(t){let e=t.byteLength,r=this.module._malloc(e);return this.module.HEAPU8.set(t,r),new m({pointer:r,numBytes:e},void 0,n=>this.module._free(n.pointer))}consumeHeapCharPointer(t){let e=this.module.UTF8ToString(t);return this.module._free(t),e}}});function q(o){if(!o)return 0;let t=0;for(let[e,r]of Object.entries(o)){if(!(e in g.IntrinsicsFlags))throw new Y(e);r&&(t|=g.IntrinsicsFlags[e])}return t}function K(o){if(typeof o=="number")return o;if(o===void 0)return 0;let{type:t,strict:e,strip:r,compileOnly:n,backtraceBarrier:i}=o,s=0;return t==="global"&&(s|=g.EvalFlags.JS_EVAL_TYPE_GLOBAL),t==="module"&&(s|=g.EvalFlags.JS_EVAL_TYPE_MODULE),e&&(s|=g.EvalFlags.JS_EVAL_FLAG_STRICT),r&&(s|=g.EvalFlags.JS_EVAL_FLAG_STRIP),n&&(s|=g.EvalFlags.JS_EVAL_FLAG_COMPILE_ONLY),i&&(s|=g.EvalFlags.JS_EVAL_FLAG_BACKTRACE_BARRIER),s}function Ce(...o){let t=[];for(let e of o)e!==void 0&&(t=t.concat(e));return t}var g,rt,Pe,T=J(()=>{"use strict";g=require("@jitl/quickjs-ffi-types");v();rt=Symbol("Unstable"),Pe=Object.freeze({BaseObjects:!0,Date:!0,Eval:!0,StringNormalize:!0,RegExp:!0,JSON:!0,Proxy:!0,MapSet:!0,TypedArrays:!0,Promise:!0})});var X,Se,P,Z=J(()=>{"use strict";X=require("@jitl/quickjs-ffi-types");M();fe();v();b();he();T();Se=class extends _{constructor(e){super(e.module);this.scope=new y;this.copyJSValue=e=>this.ffi.QTS_DupValuePointer(this.ctx.value,e);this.freeJSValue=e=>{this.ffi.QTS_FreeValuePointer(this.ctx.value,e)};e.ownedLifetimes?.forEach(r=>this.scope.manage(r)),this.owner=e.owner,this.module=e.module,this.ffi=e.ffi,this.rt=e.rt,this.ctx=this.scope.manage(e.ctx)}get alive(){return this.scope.alive}dispose(){return this.scope.dispose()}[Symbol.dispose](){return this.dispose()}manage(e){return this.scope.manage(e)}consumeJSCharPointer(e){let r=this.module.UTF8ToString(e);return this.ffi.QTS_FreeCString(this.ctx.value,e),r}heapValueHandle(e){return new m(e,this.copyJSValue,this.freeJSValue,this.owner)}},P=class extends x{constructor(e){super();this._undefined=void 0;this._null=void 0;this._false=void 0;this._true=void 0;this._global=void 0;this._BigInt=void 0;this.fnNextId=-32768;this.fnMaps=new Map;this.cToHostCallbacks={callFunction:(e,r,n,i,s)=>{if(e!==this.ctx.value)throw new Error("QuickJSContext instance received C -> JS call with mismatched ctx");let u=this.getFunction(s);if(!u)throw new Error(`QuickJSContext had no callback with id ${s}`);return y.withScopeMaybeAsync(this,function*(a,l){let h=l.manage(new O(r,this.memory.copyJSValue,this.memory.freeJSValue,this.runtime)),E=new Array(n);for(let d=0;d<n;d++){let c=this.ffi.QTS_ArgvGetJSValueConstPointer(i,d);E[d]=l.manage(new O(c,this.memory.copyJSValue,this.memory.freeJSValue,this.runtime))}try{let d=yield*a(u.apply(h,E));if(d){if("error"in d&&d.error)throw p("throw error",d.error),d.error;let c=l.manage(d instanceof m?d:d.value);return this.ffi.QTS_DupValuePointer(this.ctx.value,c.value)}return 0}catch(d){return this.errorToHandle(d).consume(c=>this.ffi.QTS_Throw(this.ctx.value,c.value))}})}};this.runtime=e.runtime,this.module=e.module,this.ffi=e.ffi,this.rt=e.rt,this.ctx=e.ctx,this.memory=new Se({...e,owner:this.runtime}),e.callbacks.setContextCallbacks(this.ctx.value,this.cToHostCallbacks),this.dump=this.dump.bind(this),this.getString=this.getString.bind(this),this.getNumber=this.getNumber.bind(this),this.resolvePromise=this.resolvePromise.bind(this)}get alive(){return this.memory.alive}dispose(){this.memory.dispose()}get undefined(){if(this._undefined)return this._undefined;let e=this.ffi.QTS_GetUndefined();return this._undefined=new k(e)}get null(){if(this._null)return this._null;let e=this.ffi.QTS_GetNull();return this._null=new k(e)}get true(){if(this._true)return this._true;let e=this.ffi.QTS_GetTrue();return this._true=new k(e)}get false(){if(this._false)return this._false;let e=this.ffi.QTS_GetFalse();return this._false=new k(e)}get global(){if(this._global)return this._global;let e=this.ffi.QTS_GetGlobalObject(this.ctx.value);return this.memory.manage(this.memory.heapValueHandle(e)),this._global=new k(e,this.runtime),this._global}newNumber(e){return this.memory.heapValueHandle(this.ffi.QTS_NewFloat64(this.ctx.value,e))}newString(e){let r=this.memory.newHeapCharPointer(e).consume(n=>this.ffi.QTS_NewString(this.ctx.value,n.value.ptr));return this.memory.heapValueHandle(r)}newUniqueSymbol(e){let r=(typeof e=="symbol"?e.description:e)??"",n=this.memory.newHeapCharPointer(r).consume(i=>this.ffi.QTS_NewSymbol(this.ctx.value,i.value.ptr,0));return this.memory.heapValueHandle(n)}newSymbolFor(e){let r=(typeof e=="symbol"?e.description:e)??"",n=this.memory.newHeapCharPointer(r).consume(i=>this.ffi.QTS_NewSymbol(this.ctx.value,i.value.ptr,1));return this.memory.heapValueHandle(n)}newBigInt(e){if(!this._BigInt){let i=this.getProp(this.global,"BigInt");this.memory.manage(i),this._BigInt=new k(i.value,this.runtime)}let r=this._BigInt,n=String(e);return this.newString(n).consume(i=>this.unwrapResult(this.callFunction(r,this.undefined,i)))}newObject(e){e&&this.runtime.assertOwned(e);let r=e?this.ffi.QTS_NewObjectProto(this.ctx.value,e.value):this.ffi.QTS_NewObject(this.ctx.value);return this.memory.heapValueHandle(r)}newArray(){let e=this.ffi.QTS_NewArray(this.ctx.value);return this.memory.heapValueHandle(e)}newArrayBuffer(e){let r=new Uint8Array(e),n=this.memory.newHeapBufferPointer(r),i=this.ffi.QTS_NewArrayBuffer(this.ctx.value,n.value.pointer,r.length);return this.memory.heapValueHandle(i)}newPromise(e){let r=y.withScope(n=>{let i=n.manage(this.memory.newMutablePointerArray(2)),s=this.ffi.QTS_NewPromiseCapability(this.ctx.value,i.value.ptr),u=this.memory.heapValueHandle(s),[a,l]=Array.from(i.value.typedArray).map(h=>this.memory.heapValueHandle(h));return new U({context:this,promiseHandle:u,resolveHandle:a,rejectHandle:l})});return e&&typeof e=="function"&&(e=new Promise(e)),e&&Promise.resolve(e).then(r.resolve,n=>n instanceof m?r.reject(n):this.newError(n).consume(r.reject)),r}newFunction(e,r){let n=++this.fnNextId;return this.setFunction(n,r),this.memory.heapValueHandle(this.ffi.QTS_NewFunction(this.ctx.value,n,e))}newError(e){let r=this.memory.heapValueHandle(this.ffi.QTS_NewError(this.ctx.value));return e&&typeof e=="object"?(e.name!==void 0&&this.newString(e.name).consume(n=>this.setProp(r,"name",n)),e.message!==void 0&&this.newString(e.message).consume(n=>this.setProp(r,"message",n))):typeof e=="string"?this.newString(e).consume(n=>this.setProp(r,"message",n)):e!==void 0&&this.newString(String(e)).consume(n=>this.setProp(r,"message",n)),r}typeof(e){return this.runtime.assertOwned(e),this.memory.consumeHeapCharPointer(this.ffi.QTS_Typeof(this.ctx.value,e.value))}getNumber(e){return this.runtime.assertOwned(e),this.ffi.QTS_GetFloat64(this.ctx.value,e.value)}getString(e){return this.runtime.assertOwned(e),this.memory.consumeJSCharPointer(this.ffi.QTS_GetString(this.ctx.value,e.value))}getSymbol(e){this.runtime.assertOwned(e);let r=this.memory.consumeJSCharPointer(this.ffi.QTS_GetSymbolDescriptionOrKey(this.ctx.value,e.value));return this.ffi.QTS_IsGlobalSymbol(this.ctx.value,e.value)?Symbol.for(r):Symbol(r)}getBigInt(e){this.runtime.assertOwned(e);let r=this.getString(e);return BigInt(r)}getArrayBuffer(e){this.runtime.assertOwned(e);let r=this.ffi.QTS_GetArrayBufferLength(this.ctx.value,e.value),n=this.ffi.QTS_GetArrayBuffer(this.ctx.value,e.value);if(!n)throw new Error("Couldn't allocate memory to get ArrayBuffer");return new m(this.module.HEAPU8.subarray(n,n+r),void 0,()=>this.module._free(n))}getPromiseState(e){this.runtime.assertOwned(e);let r=this.ffi.QTS_PromiseState(this.ctx.value,e.value);if(r<0)return{type:"fulfilled",value:e,notAPromise:!0};if(r===X.JSPromiseStateEnum.Pending)return{type:"pending",get error(){return new W("Cannot unwrap a pending promise")}};let n=this.ffi.QTS_PromiseResult(this.ctx.value,e.value),i=this.memory.heapValueHandle(n);if(r===X.JSPromiseStateEnum.Fulfilled)return{type:"fulfilled",value:i};if(r===X.JSPromiseStateEnum.Rejected)return{type:"rejected",error:i};throw i.dispose(),new Error(`Unknown JSPromiseStateEnum: ${r}`)}resolvePromise(e){this.runtime.assertOwned(e);let r=y.withScope(n=>{let i=n.manage(this.getProp(this.global,"Promise")),s=n.manage(this.getProp(i,"resolve"));return this.callFunction(s,i,e)});return r.error?Promise.resolve(r):new Promise(n=>{y.withScope(i=>{let s=i.manage(this.newFunction("resolve",h=>{n({value:h&&h.dup()})})),u=i.manage(this.newFunction("reject",h=>{n({error:h&&h.dup()})})),a=i.manage(r.value),l=i.manage(this.getProp(a,"then"));this.unwrapResult(this.callFunction(l,a,s,u)).dispose()})})}getProp(e,r){this.runtime.assertOwned(e);let n=this.borrowPropertyKey(r).consume(s=>this.ffi.QTS_GetProp(this.ctx.value,e.value,s.value));return this.memory.heapValueHandle(n)}setProp(e,r,n){this.runtime.assertOwned(e),this.borrowPropertyKey(r).consume(i=>this.ffi.QTS_SetProp(this.ctx.value,e.value,i.value,n.value))}defineProp(e,r,n){this.runtime.assertOwned(e),y.withScope(i=>{let s=i.manage(this.borrowPropertyKey(r)),u=n.value||this.undefined,a=!!n.configurable,l=!!n.enumerable,h=!!n.value,E=n.get?i.manage(this.newFunction(n.get.name,n.get)):this.undefined,d=n.set?i.manage(this.newFunction(n.set.name,n.set)):this.undefined;this.ffi.QTS_DefineProp(this.ctx.value,e.value,s.value,u.value,E.value,d.value,a,l,h)})}callFunction(e,r,...n){this.runtime.assertOwned(e);let i=this.memory.toPointerArray(n).consume(u=>this.ffi.QTS_Call(this.ctx.value,e.value,r.value,n.length,u.value)),s=this.ffi.QTS_ResolveException(this.ctx.value,i);return s?(this.ffi.QTS_FreeValuePointer(this.ctx.value,i),{error:this.memory.heapValueHandle(s)}):{value:this.memory.heapValueHandle(i)}}evalCode(e,r="eval.js",n){let i=n===void 0?1:0,s=K(n),u=this.memory.newHeapCharPointer(e).consume(l=>this.ffi.QTS_Eval(this.ctx.value,l.value.ptr,l.value.strlen,r,i,s)),a=this.ffi.QTS_ResolveException(this.ctx.value,u);return a?(this.ffi.QTS_FreeValuePointer(this.ctx.value,u),{error:this.memory.heapValueHandle(a)}):{value:this.memory.heapValueHandle(u)}}throw(e){return this.errorToHandle(e).consume(r=>this.ffi.QTS_Throw(this.ctx.value,r.value))}borrowPropertyKey(e){return typeof e=="number"?this.newNumber(e):typeof e=="string"?this.newString(e):new k(e.value,this.runtime)}getMemory(e){if(e===this.rt.value)return this.memory;throw new Error("Private API. Cannot get memory from a different runtime")}dump(e){this.runtime.assertOwned(e);let r=this.typeof(e);if(r==="string")return this.getString(e);if(r==="number")return this.getNumber(e);if(r==="bigint")return this.getBigInt(e);if(r==="undefined")return;if(r==="symbol")return this.getSymbol(e);let n=this.getPromiseState(e);if(n.type==="fulfilled"&&!n.notAPromise)return e.dispose(),{type:n.type,value:n.value.consume(this.dump)};if(n.type==="pending")return e.dispose(),{type:n.type};if(n.type==="rejected")return e.dispose(),{type:n.type,error:n.error.consume(this.dump)};let i=this.memory.consumeJSCharPointer(this.ffi.QTS_Dump(this.ctx.value,e.value));try{return JSON.parse(i)}catch{return i}}unwrapResult(e){if(e.error){let r="context"in e.error?e.error.context:this,n=e.error.consume(i=>this.dump(i));if(n&&typeof n=="object"&&typeof n.message=="string"){let{message:i,name:s,stack:u}=n,a=new F(""),l=a.stack;throw typeof s=="string"&&(a.name=n.name),typeof u=="string"&&(a.stack=`${s}: ${i}
${n.stack}Host: ${l}`),Object.assign(a,{cause:n,context:r,message:i}),a}throw new F(n,r)}return e.value}getFunction(e){let r=e>>8,n=this.fnMaps.get(r);if(n)return n.get(e)}setFunction(e,r){let n=e>>8,i=this.fnMaps.get(n);return i||(i=new Map,this.fnMaps.set(n,i)),i.set(e,r)}errorToHandle(e){return e instanceof m?e:this.newError(e)}encodeBinaryJSON(e){let r=this.ffi.QTS_bjson_encode(this.ctx.value,e.value);return this.memory.heapValueHandle(r)}decodeBinaryJSON(e){let r=this.ffi.QTS_bjson_decode(this.ctx.value,e.value);return this.memory.heapValueHandle(r)}}});var C,ee=J(()=>{"use strict";de();Z();M();v();b();he();T();C=class extends x{constructor(e){super();this.scope=new y;this.contextMap=new Map;this.cToHostCallbacks={shouldInterrupt:e=>{if(e!==this.rt.value)throw new Error("QuickJSContext instance received C -> JS interrupt with mismatched rt");let r=this.interruptHandler;if(!r)throw new Error("QuickJSContext had no interrupt handler");return r(this)?1:0},loadModuleSource:ce(this,function*(e,r,n,i){let s=this.moduleLoader;if(!s)throw new Error("Runtime has no module loader");if(r!==this.rt.value)throw new Error("Runtime pointer mismatch");let u=this.contextMap.get(n)??this.newContext({contextPointer:n});try{let a=yield*e(s(i,u));if(typeof a=="object"&&"error"in a&&a.error)throw p("cToHostLoadModule: loader returned error",a.error),a.error;let l=typeof a=="string"?a:"value"in a?a.value:a;return this.memory.newHeapCharPointer(l).value.ptr}catch(a){return p("cToHostLoadModule: caught error",a),u.throw(a),0}}),normalizeModule:ce(this,function*(e,r,n,i,s){let u=this.moduleNormalizer;if(!u)throw new Error("Runtime has no module normalizer");if(r!==this.rt.value)throw new Error("Runtime pointer mismatch");let a=this.contextMap.get(n)??this.newContext({contextPointer:n});try{let l=yield*e(u(i,s,a));if(typeof l=="object"&&"error"in l&&l.error)throw p("cToHostNormalizeModule: normalizer returned error",l.error),l.error;let h=typeof l=="string"?l:l.value;return a.getMemory(this.rt.value).newHeapCharPointer(h).value.ptr}catch(l){return p("normalizeModule: caught error",l),a.throw(l),0}})};e.ownedLifetimes?.forEach(r=>this.scope.manage(r)),this.module=e.module,this.memory=new _(this.module),this.ffi=e.ffi,this.rt=e.rt,this.callbacks=e.callbacks,this.scope.manage(this.rt),this.callbacks.setRuntimeCallbacks(this.rt.value,this.cToHostCallbacks),this.executePendingJobs=this.executePendingJobs.bind(this)}get alive(){return this.scope.alive}dispose(){return this.scope.dispose()}newContext(e={}){let r=q(e.intrinsics),n=new m(e.contextPointer||this.ffi.QTS_NewContext(this.rt.value,r),void 0,s=>{this.contextMap.delete(s),this.callbacks.deleteContext(s),this.ffi.QTS_FreeContext(s)}),i=new P({module:this.module,ctx:n,ffi:this.ffi,rt:this.rt,ownedLifetimes:e.ownedLifetimes,runtime:this,callbacks:this.callbacks});return this.contextMap.set(n.value,i),i}setModuleLoader(e,r){this.moduleLoader=e,this.moduleNormalizer=r,this.ffi.QTS_RuntimeEnableModuleLoader(this.rt.value,this.moduleNormalizer?1:0)}removeModuleLoader(){this.moduleLoader=void 0,this.ffi.QTS_RuntimeDisableModuleLoader(this.rt.value)}hasPendingJob(){return!!this.ffi.QTS_IsJobPending(this.rt.value)}setInterruptHandler(e){let r=this.interruptHandler;this.interruptHandler=e,r||this.ffi.QTS_RuntimeEnableInterruptHandler(this.rt.value)}removeInterruptHandler(){this.interruptHandler&&(this.ffi.QTS_RuntimeDisableInterruptHandler(this.rt.value),this.interruptHandler=void 0)}executePendingJobs(e=-1){let r=this.memory.newMutablePointerArray(1),n=this.ffi.QTS_ExecutePendingJob(this.rt.value,e??-1,r.value.ptr),i=r.value.typedArray[0];if(r.dispose(),i===0)return this.ffi.QTS_FreeValuePointerRuntime(this.rt.value,n),{value:0};let s=this.contextMap.get(i)??this.newContext({contextPointer:i}),u=s.getMemory(this.rt.value).heapValueHandle(n);if(s.typeof(u)==="number"){let l=s.getNumber(u);return u.dispose(),{value:l}}else return{error:Object.assign(u,{context:s})}}setMemoryLimit(e){if(e<0&&e!==-1)throw new Error("Cannot set memory limit to negative number. To unset, pass -1");this.ffi.QTS_RuntimeSetMemoryLimit(this.rt.value,e)}computeMemoryUsage(){let e=this.getSystemContext().getMemory(this.rt.value);return e.heapValueHandle(this.ffi.QTS_RuntimeComputeMemoryUsage(this.rt.value,e.ctx.value))}dumpMemoryUsage(){return this.memory.consumeHeapCharPointer(this.ffi.QTS_RuntimeDumpMemoryUsage(this.rt.value))}setMaxStackSize(e){if(e<0)throw new Error("Cannot set memory limit to negative number. To unset, pass 0.");this.ffi.QTS_RuntimeSetMaxStackSize(this.rt.value,e)}assertOwned(e){if(e.owner&&e.owner.rt!==this.rt)throw new N(`Handle is not owned by this runtime: ${e.owner.rt.value} != ${this.rt.value}`)}getSystemContext(){return this.context||(this.context=this.scope.manage(this.newContext())),this.context}}});var He={};$(He,{QuickJSModuleCallbacks:()=>te,QuickJSWASMModule:()=>A,applyBaseRuntimeOptions:()=>re,applyModuleEvalRuntimeOptions:()=>ne});function re(o,t){t.interruptHandler&&o.setInterruptHandler(t.interruptHandler),t.maxStackSizeBytes!==void 0&&o.setMaxStackSize(t.maxStackSizeBytes),t.memoryLimitBytes!==void 0&&o.setMemoryLimit(t.memoryLimitBytes)}function ne(o,t){t.moduleLoader&&o.setModuleLoader(t.moduleLoader),t.shouldInterrupt&&o.setInterruptHandler(t.shouldInterrupt),t.memoryLimitBytes!==void 0&&o.setMemoryLimit(t.memoryLimitBytes),t.maxStackSizeBytes!==void 0&&o.setMaxStackSize(t.maxStackSizeBytes)}var ye,te,A,ie=J(()=>{"use strict";M();v();b();ee();T();ye=class{constructor(t){this.callFunction=t.callFunction,this.shouldInterrupt=t.shouldInterrupt,this.loadModuleSource=t.loadModuleSource,this.normalizeModule=t.normalizeModule}},te=class{constructor(t){this.contextCallbacks=new Map;this.runtimeCallbacks=new Map;this.suspendedCount=0;this.cToHostCallbacks=new ye({callFunction:(t,e,r,n,i,s)=>this.handleAsyncify(t,()=>{try{let u=this.contextCallbacks.get(e);if(!u)throw new Error(`QuickJSContext(ctx = ${e}) not found for C function call "${s}"`);return u.callFunction(e,r,n,i,s)}catch(u){return console.error("[C to host error: returning null]",u),0}}),shouldInterrupt:(t,e)=>this.handleAsyncify(t,()=>{try{let r=this.runtimeCallbacks.get(e);if(!r)throw new Error(`QuickJSRuntime(rt = ${e}) not found for C interrupt`);return r.shouldInterrupt(e)}catch(r){return console.error("[C to host interrupt: returning error]",r),1}}),loadModuleSource:(t,e,r,n)=>this.handleAsyncify(t,()=>{try{let i=this.runtimeCallbacks.get(e);if(!i)throw new Error(`QuickJSRuntime(rt = ${e}) not found for C module loader`);let s=i.loadModuleSource;if(!s)throw new Error(`QuickJSRuntime(rt = ${e}) does not support module loading`);return s(e,r,n)}catch(i){return console.error("[C to host module loader error: returning null]",i),0}}),normalizeModule:(t,e,r,n,i)=>this.handleAsyncify(t,()=>{try{let s=this.runtimeCallbacks.get(e);if(!s)throw new Error(`QuickJSRuntime(rt = ${e}) not found for C module loader`);let u=s.normalizeModule;if(!u)throw new Error(`QuickJSRuntime(rt = ${e}) does not support module loading`);return u(e,r,n,i)}catch(s){return console.error("[C to host module loader error: returning null]",s),0}})});this.module=t,this.module.callbacks=this.cToHostCallbacks}setRuntimeCallbacks(t,e){this.runtimeCallbacks.set(t,e)}deleteRuntime(t){this.runtimeCallbacks.delete(t)}setContextCallbacks(t,e){this.contextCallbacks.set(t,e)}deleteContext(t){this.contextCallbacks.delete(t)}handleAsyncify(t,e){if(t)return t.handleSleep(n=>{try{let i=e();if(!(i instanceof Promise)){p("asyncify.handleSleep: not suspending:",i),n(i);return}if(this.suspended)throw new j(`Already suspended at: ${this.suspended.stack}
Attempted to suspend at:`);this.suspended=new z(`(${this.suspendedCount++})`),p("asyncify.handleSleep: suspending:",this.suspended),i.then(s=>{this.suspended=void 0,p("asyncify.handleSleep: resolved:",s),n(s)},s=>{p("asyncify.handleSleep: rejected:",s),console.error("QuickJS: cannot handle error in suspended function",s),this.suspended=void 0})}catch(i){throw p("asyncify.handleSleep: error:",i),this.suspended=void 0,i}});let r=e();if(r instanceof Promise)throw new Error("Promise return value not supported in non-asyncify context.");return r}};A=class{constructor(t,e){this.module=t,this.ffi=e,this.callbacks=new te(t)}newRuntime(t={}){let e=new m(this.ffi.QTS_NewRuntime(),void 0,n=>{this.callbacks.deleteRuntime(n),this.ffi.QTS_FreeRuntime(n)}),r=new C({module:this.module,callbacks:this.callbacks,ffi:this.ffi,rt:e});return re(r,t),t.moduleLoader&&r.setModuleLoader(t.moduleLoader),r}newContext(t={}){let e=this.newRuntime(),r=e.newContext({...t,ownedLifetimes:Ce(e,t.ownedLifetimes)});return e.context=r,r}evalCode(t,e={}){return y.withScope(r=>{let n=r.manage(this.newContext());ne(n.runtime,e);let i=n.evalCode(t,"eval.js");if(e.memoryLimitBytes!==void 0&&n.runtime.setMemoryLimit(-1),i.error)throw n.dump(r.manage(i.error));return n.dump(r.manage(i.value))})}getWasmMemory(){let e=this.module.quickjsEmscriptenInit?.(()=>{})?.getWasmMemory?.();if(!e)throw new Error("Variant does not support getting WebAssembly.Memory");return e}getFFI(){return this.ffi}}});var I,Je=J(()=>{"use strict";Z();M();T();I=class extends P{async evalCodeAsync(t,e="eval.js",r){let n=r===void 0?1:0,i=K(r),s=0;try{s=await this.memory.newHeapCharPointer(t).consume(a=>this.ffi.QTS_Eval_MaybeAsync(this.ctx.value,a.value.ptr,a.value.strlen,e,n,i))}catch(a){throw p("QTS_Eval_MaybeAsync threw",a),a}let u=this.ffi.QTS_ResolveException(this.ctx.value,s);return u?(this.ffi.QTS_FreeValuePointer(this.ctx.value,s),{error:this.memory.heapValueHandle(u)}):{value:this.memory.heapValueHandle(s)}}newAsyncifiedFunction(t,e){return this.newFunction(t,e)}}});var B,xe=J(()=>{"use strict";Je();ee();T();b();B=class extends C{constructor(t){super(t)}newContext(t={}){let e=q(t.intrinsics),r=new m(this.ffi.QTS_NewContext(this.rt.value,e),void 0,i=>{this.contextMap.delete(i),this.callbacks.deleteContext(i),this.ffi.QTS_FreeContext(i)}),n=new I({module:this.module,ctx:r,ffi:this.ffi,rt:this.rt,ownedLifetimes:[],runtime:this,callbacks:this.callbacks});return this.contextMap.set(r.value,n),n}setModuleLoader(t,e){super.setModuleLoader(t,e)}setMaxStackSize(t){return super.setMaxStackSize(t)}}});var Te={};$(Te,{QuickJSAsyncWASMModule:()=>G});var G,we=J(()=>{"use strict";v();b();ie();xe();G=class extends A{constructor(e,r){super(e,r);this.ffi=r,this.module=e}newRuntime(e={}){let r=new m(this.ffi.QTS_NewRuntime(),void 0,i=>{this.callbacks.deleteRuntime(i),this.ffi.QTS_FreeRuntime(i)}),n=new B({module:this.module,ffi:this.ffi,rt:r,callbacks:this.callbacks});return re(n,e),e.moduleLoader&&n.setModuleLoader(e.moduleLoader),n}newContext(e={}){let r=this.newRuntime(),n=e.ownedLifetimes?e.ownedLifetimes.concat([r]):[r],i=r.newContext({...e,ownedLifetimes:n});return r.context=i,i}evalCode(){throw new D("QuickJSWASMModuleAsyncify.evalCode: use evalCodeAsync instead")}evalCodeAsync(e,r){return y.withScopeAsync(async n=>{let i=n.manage(this.newContext());ne(i.runtime,r);let s=await i.evalCodeAsync(e,"eval.js");if(r.memoryLimitBytes!==void 0&&i.runtime.setMemoryLimit(-1),s.error)throw i.dump(n.manage(s.error));return i.dump(n.manage(s.value))})}}});var f={};$(f,{DefaultIntrinsics:()=>Pe,Lifetime:()=>m,QuickJSAsyncContext:()=>I,QuickJSAsyncRuntime:()=>B,QuickJSAsyncWASMModule:()=>G,QuickJSContext:()=>P,QuickJSDeferredPromise:()=>U,QuickJSRuntime:()=>C,QuickJSWASMModule:()=>A,Scope:()=>y,StaticLifetime:()=>k,TestQuickJSWASMModule:()=>ke,UsingDisposable:()=>x,WeakLifetime:()=>O,debugLog:()=>p,errors:()=>ue,isFail:()=>De,isSuccess:()=>Ne,memoizePromiseFactory:()=>_e,newQuickJSAsyncWASMModuleFromVariant:()=>Oe,newQuickJSWASMModuleFromVariant:()=>Ve,newVariant:()=>Ie,shouldInterruptAfterDeadline:()=>je});module.exports=Fe(f);S(f,require("@jitl/quickjs-ffi-types"),module.exports);ie();Z();ee();we();xe();Je();v();M();async function Ve(o){let t=R(await o),[e,r,{QuickJSWASMModule:n}]=await Promise.all([t.importModuleLoader().then(R),t.importFFI(),Promise.resolve().then(()=>(ie(),He)).then(R)]),i=await e();i.type="sync";let s=new r(i);return new n(i,s)}async function Oe(o){let t=R(await o),[e,r,{QuickJSAsyncWASMModule:n}]=await Promise.all([t.importModuleLoader().then(R),t.importFFI(),Promise.resolve().then(()=>(we(),Te)).then(R)]),i=await e();i.type="async";let s=new r(i);return new n(i,s)}function _e(o){let t;return()=>t??(t=o())}function R(o){return o&&"default"in o&&o.default?o.default&&"default"in o.default&&o.default.default?o.default.default:o.default:o}function Ie(o,t){return{...o,async importModuleLoader(){let r=R(await o.importModuleLoader());return async function(){let i=t.emscriptenModule?{...t.emscriptenModule}:{},s=t.log??((...c)=>p("newVariant moduleLoader:",...c)),u=(c,w)=>(s(...c,w),w),a=c=>typeof c=="function"?c():c;(t.wasmLocation||t.wasmSourceMapLocation||t.locateFile)&&(i.locateFile=(c,w)=>{let Q={fileName:c,relativeTo:w};if(c.endsWith(".wasm")&&t.wasmLocation!==void 0)return u(["locateFile .wasm: provide wasmLocation",Q],t.wasmLocation);if(c.endsWith(".map")){if(t.wasmSourceMapLocation!==void 0)return u(["locateFile .map: provide wasmSourceMapLocation",Q],t.wasmSourceMapLocation);if(t.wasmLocation&&!t.locateFile)return u(["locateFile .map: infer from wasmLocation",Q],t.wasmLocation+".map")}return t.locateFile?u(["locateFile: use provided fn",Q],t.locateFile(c,w)):u(["locateFile: unhandled, passthrough",Q],c)}),t.wasmBinary&&(i.wasmBinary=await a(t.wasmBinary)),t.wasmMemory&&(i.wasmMemory=await a(t.wasmMemory));let l=t.wasmModule,h;l&&(i.instantiateWasm=async(c,w)=>{h??(h=Promise.resolve(a(l)));let Q=await h;if(!Q)throw new V(`options.wasmModule returned ${String(Q)}`);let ve=await WebAssembly.instantiate(Q,c);return w(ve),ve.exports}),i.monitorRunDependencies=c=>{s("monitorRunDependencies:",c)},i.quickjsEmscriptenInit=()=>Be(s);let E=r(i),d=i.quickjsEmscriptenInit?.(s);if(l&&d?.receiveWasmOffsetConverter&&!d.existingWasmOffsetConverter){let c=await a(t.wasmBinary)??new ArrayBuffer(0);h??(h=Promise.resolve(a(l)));let w=await h;if(!w)throw new V(`options.wasmModule returned ${String(w)}`);d.receiveWasmOffsetConverter(c,w)}if(d?.receiveSourceMapJSON){let c=await a(t.wasmSourceMapData);typeof c=="string"?d.receiveSourceMapJSON(JSON.parse(c)):c?d.receiveSourceMapJSON(c):d.receiveSourceMapJSON({version:3,names:[],sources:[],mappings:""})}return E}}}}function Be(o){let t="mock called, emscripten module may not be initialized yet";return{mock:!0,removeRunDependency(e){o(`${t}: removeRunDependency called:`,e)},receiveSourceMapJSON(e){o(`${t}: receiveSourceMapJSON called:`,e)},WasmOffsetConverter:void 0,receiveWasmOffsetConverter(e,r){o(`${t}: receiveWasmOffsetConverter called:`,e,r)}}}function Ne(o){return!("error"in o)}function De(o){return"error"in o}b();function je(o){let t=typeof o=="number"?o:o.getTime();return function(){return Date.now()>t}}v();fe();v();b();var ke=class{constructor(t){this.parent=t;this.contexts=new Set;this.runtimes=new Set}newRuntime(t){let e=this.parent.newRuntime({...t,ownedLifetimes:[new m(void 0,void 0,()=>this.runtimes.delete(e)),...t?.ownedLifetimes??[]]});return this.runtimes.add(e),e}newContext(t){let e=this.parent.newContext({...t,ownedLifetimes:[new m(void 0,void 0,()=>this.contexts.delete(e)),...t?.ownedLifetimes??[]]});return this.contexts.add(e),e}evalCode(t,e){return this.parent.evalCode(t,e)}disposeAll(){let t=[...this.contexts,...this.runtimes];this.runtimes.clear(),this.contexts.clear(),t.forEach(e=>{e.alive&&e.dispose()})}assertNoMemoryAllocated(){if(this.getFFI().QTS_RecoverableLeakCheck())throw new H("Leak sanitizer detected un-freed memory");if(this.contexts.size>0)throw new H(`${this.contexts.size} contexts leaked`);if(this.runtimes.size>0)throw new H(`${this.runtimes.size} runtimes leaked`)}getWasmMemory(){return this.parent.getWasmMemory()}getFFI(){return this.parent.getFFI()}};T();M();0&&(module.exports={DefaultIntrinsics,Lifetime,QuickJSAsyncContext,QuickJSAsyncRuntime,QuickJSAsyncWASMModule,QuickJSContext,QuickJSDeferredPromise,QuickJSRuntime,QuickJSWASMModule,Scope,StaticLifetime,TestQuickJSWASMModule,UsingDisposable,WeakLifetime,debugLog,errors,isFail,isSuccess,memoizePromiseFactory,newQuickJSAsyncWASMModuleFromVariant,newQuickJSWASMModuleFromVariant,newVariant,shouldInterruptAfterDeadline,...require("@jitl/quickjs-ffi-types")});
//# sourceMappingURL=index.js.map