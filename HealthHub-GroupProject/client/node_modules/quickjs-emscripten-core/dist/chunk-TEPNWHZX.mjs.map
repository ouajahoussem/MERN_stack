{"version":3,"sources":["../src/debug.ts","../src/errors.ts","../src/asyncify-helpers.ts","../src/lifetime.ts","../src/context.ts","../src/deferred-promise.ts","../src/memory.ts","../src/types.ts","../src/runtime.ts","../src/module.ts"],"sourcesContent":["/**\n * @private\n * Mutable variable. Use {@link setDebugMode} to enable.\n */\nexport let QTS_DEBUG = false\n\n/**\n * Enable (or disable) debug logging and object creation tracking in the Javascript API.\n * To get debug logging in the WebAssembly module, you need to use a debug build variant.\n */\nexport function setDebugMode(enabled: boolean = true) {\n  QTS_DEBUG = enabled\n}\n\n/**\n * @private\n */\nexport function debugLog(...args: any[]) {\n  if (QTS_DEBUG) {\n    console.log(...args)\n  }\n}\n","import type { QuickJSContext } from \"./context\"\n\n/**\n * Error thrown if {@link QuickJSContext#unwrapResult} unwraps an error value that isn't an object.\n */\nexport class QuickJSUnwrapError extends Error {\n  name = \"QuickJSUnwrapError\"\n  constructor(\n    public cause: unknown,\n    public context?: QuickJSContext,\n  ) {\n    super(String(cause))\n  }\n}\n\nexport class QuickJSWrongOwner extends Error {\n  name = \"QuickJSWrongOwner\"\n}\n\nexport class QuickJSUseAfterFree extends Error {\n  name = \"QuickJSUseAfterFree\"\n}\n\nexport class QuickJSNotImplemented extends Error {\n  name = \"QuickJSNotImplemented\"\n}\n\nexport class QuickJSAsyncifyError extends Error {\n  name = \"QuickJSAsyncifyError\"\n}\n\nexport class QuickJSAsyncifySuspended extends Error {\n  name = \"QuickJSAsyncifySuspended\"\n}\n\nexport class QuickJSMemoryLeakDetected extends Error {\n  name = \"QuickJSMemoryLeakDetected\"\n}\n\nexport class QuickJSEmscriptenModuleError extends Error {\n  name = \"QuickJSEmscriptenModuleError\"\n}\n\nexport class QuickJSUnknownIntrinsic extends TypeError {\n  name = \"QuickJSUnknownIntrinsic\"\n}\n\nexport class QuickJSPromisePending extends Error {\n  name = \"QuickJSPromisePending\"\n}\n","function* awaitYield<T>(value: T | Promise<T>) {\n  return (yield value) as T\n}\n\nfunction awaitYieldOf<T, Yielded>(\n  generator: Generator<Yielded | Promise<Yielded>, T, Yielded>,\n): Generator<T | Promise<T>, T, T> {\n  return awaitYield(awaitEachYieldedPromise(generator))\n}\n\nexport type AwaitYield = typeof awaitYield & {\n  of: typeof awaitYieldOf\n}\n\nconst AwaitYield: AwaitYield = awaitYield as AwaitYield\nAwaitYield.of = awaitYieldOf\n\n/**\n * Create a function that may or may not be async, using a generator\n *\n * Within the generator, call `yield* awaited(maybePromise)` to await a value\n * that may or may not be a promise.\n *\n * If the inner function never yields a promise, it will return synchronously.\n */\nexport function maybeAsyncFn<\n  /** Function arguments */\n  Args extends any[],\n  This,\n  /** Function return type */\n  Return,\n  /** Yields to unwrap */\n  Yielded,\n>(\n  that: This,\n  fn: (\n    this: This,\n    awaited: AwaitYield,\n    ...args: Args\n  ) => Generator<Yielded | Promise<Yielded>, Return, Yielded>,\n): (...args: Args) => Return | Promise<Return> {\n  return (...args: Args) => {\n    const generator = fn.call(that, AwaitYield, ...args)\n    return awaitEachYieldedPromise(generator)\n  }\n}\n\n// class Example {\n//   private maybeAsyncMethod = maybeAsyncFn(this, function* (awaited, a: number) {\n//     yield* awaited(new Promise((resolve) => setTimeout(resolve, a)))\n//     return 5\n//   })\n// }\n\nexport type MaybeAsyncBlock<Return, This, Yielded, Args extends any[] = []> = (\n  this: This,\n  awaited: AwaitYield,\n  ...args: Args\n) => Generator<Yielded | Promise<Yielded>, Return, Yielded>\n\nexport function maybeAsync<Return, This, Yielded>(\n  that: This,\n  startGenerator: (\n    this: This,\n    await: AwaitYield,\n  ) => Generator<Yielded | Promise<Yielded>, Return, Yielded>,\n): Return | Promise<Return> {\n  const generator = startGenerator.call(that, AwaitYield)\n  return awaitEachYieldedPromise(generator)\n}\n\nexport function awaitEachYieldedPromise<Yielded, Returned>(\n  gen: Generator<Yielded | Promise<Yielded>, Returned, Yielded>,\n): Returned | Promise<Returned> {\n  type NextResult = ReturnType<typeof gen.next>\n\n  function handleNextStep(step: NextResult): Returned | Promise<Returned> {\n    if (step.done) {\n      return step.value\n    }\n\n    if (step.value instanceof Promise) {\n      return step.value.then(\n        (value) => handleNextStep(gen.next(value)),\n        (error) => handleNextStep(gen.throw(error)),\n      )\n    }\n\n    return handleNextStep(gen.next(step.value))\n  }\n\n  return handleNextStep(gen.next())\n}\n","import type { MaybeAsyncBlock } from \"./asyncify-helpers\"\nimport { maybeAsync } from \"./asyncify-helpers\"\nimport { QTS_DEBUG } from \"./debug\"\nimport { QuickJSUseAfterFree } from \"./errors\"\nimport type { QuickJSHandle } from \"./types\"\n\n/**\n * An object that can be disposed.\n * {@link Lifetime} is the canonical implementation of Disposable.\n * Use {@link Scope} to manage cleaning up multiple disposables.\n */\nexport interface Disposable {\n  /**\n   * Dispose of the underlying resources used by this object.\n   */\n  dispose(): void\n\n  /**\n   * @returns true if the object is alive\n   * @returns false after the object has been {@link dispose}d\n   */\n  alive: boolean\n\n  /**\n   * A method that is used to release resources held by an object. Called by the semantics of the `using` statement.\n   */\n  [Symbol.dispose](): void\n}\n\n/**\n * Base abstract class that helps implement {@link Disposable} by providing a default implementation of {@link Symbol.dispose}.\n */\nexport abstract class UsingDisposable implements Disposable {\n  /**\n   * @returns true if the object is alive\n   * @returns false after the object has been {@link dispose}d\n   */\n  declare abstract readonly alive: boolean\n  /**\n   * Dispose of the underlying resources used by this object.\n   */\n  abstract dispose(): void\n  /**\n   * Just calls the standard .dispose() method of this class.\n   */\n  [Symbol.dispose]() {\n    return this.dispose()\n  }\n}\n\n// Polyfill as needed if Symbol.dispose is not available.\n// This polyfill matches ESBuild's behavior.\nconst SymbolDispose = Symbol.dispose ?? Symbol.for(\"Symbol.dispose\")\nconst prototypeAsAny = UsingDisposable.prototype as any\nif (!prototypeAsAny[SymbolDispose]) {\n  prototypeAsAny[SymbolDispose] = function () {\n    return this.dispose()\n  }\n}\n\n/**\n * A lifetime prevents access to a value after the lifetime has been\n * {@link dispose}ed.\n *\n * Typically, quickjs-emscripten uses Lifetimes to protect C memory pointers.\n */\nexport class Lifetime<T, TCopy = never, Owner = never>\n  extends UsingDisposable\n  implements Disposable\n{\n  protected _alive: boolean = true\n  protected _constructorStack = QTS_DEBUG ? new Error(\"Lifetime constructed\").stack : undefined\n\n  /**\n   * When the Lifetime is disposed, it will call `disposer(_value)`. Use the\n   * disposer function to implement whatever cleanup needs to happen at the end\n   * of `value`'s lifetime.\n   *\n   * `_owner` is not used or controlled by the lifetime. It's just metadata for\n   * the creator.\n   */\n  constructor(\n    protected readonly _value: T,\n    protected readonly copier?: (value: T | TCopy) => TCopy,\n    protected readonly disposer?: (value: T | TCopy) => void,\n    protected readonly _owner?: Owner,\n  ) {\n    super()\n  }\n\n  get alive() {\n    return this._alive\n  }\n\n  /**\n   * The value this Lifetime protects. You must never retain the value - it\n   * may become invalid, leading to memory errors.\n   *\n   * @throws If the lifetime has been {@link dispose}d already.\n   */\n  get value() {\n    this.assertAlive()\n    return this._value\n  }\n\n  get owner() {\n    return this._owner\n  }\n\n  get dupable() {\n    return !!this.copier\n  }\n\n  /**\n   * Create a new handle pointing to the same {@link value}.\n   */\n  dup() {\n    this.assertAlive()\n    if (!this.copier) {\n      throw new Error(\"Non-dupable lifetime\")\n    }\n    return new Lifetime<TCopy, TCopy, Owner>(\n      this.copier(this._value),\n      this.copier,\n      this.disposer,\n      this._owner,\n    )\n  }\n\n  /**\n   * Call `map` with this lifetime, then dispose the lifetime.\n   * @return the result of `map(this)`.\n   */\n  consume<O>(map: (lifetime: this) => O): O\n  // A specific type definition is needed for our common use-case\n  // https://github.com/microsoft/TypeScript/issues/30271\n  consume<O>(map: (lifetime: QuickJSHandle) => O): O\n  consume<O>(map: (lifetime: any) => O): O {\n    this.assertAlive()\n    const result = map(this)\n    this.dispose()\n    return result\n  }\n\n  /**\n   * Dispose of {@link value} and perform cleanup.\n   */\n  dispose() {\n    this.assertAlive()\n    if (this.disposer) {\n      this.disposer(this._value)\n    }\n    this._alive = false\n  }\n\n  private assertAlive() {\n    if (!this.alive) {\n      if (this._constructorStack) {\n        throw new QuickJSUseAfterFree(\n          `Lifetime not alive\\n${this._constructorStack}\\nLifetime used`,\n        )\n      }\n      throw new QuickJSUseAfterFree(\"Lifetime not alive\")\n    }\n  }\n}\n\n/**\n * A Lifetime that lives forever. Used for constants.\n */\nexport class StaticLifetime<T, Owner = never> extends Lifetime<T, T, Owner> {\n  constructor(value: T, owner?: Owner) {\n    super(value, undefined, undefined, owner)\n  }\n\n  // Static lifetime doesn't need a copier to be copiable\n  get dupable() {\n    return true\n  }\n\n  // Copy returns the same instance.\n  dup() {\n    return this\n  }\n\n  // Dispose does nothing.\n  dispose() {}\n}\n\n/**\n * A Lifetime that does not own its `value`. A WeakLifetime never calls its\n * `disposer` function, but can be `dup`ed to produce regular lifetimes that\n * do.\n *\n * Used for function arguments.\n */\nexport class WeakLifetime<T, TCopy = never, Owner = never> extends Lifetime<T, TCopy, Owner> {\n  constructor(\n    value: T,\n    copier?: (value: T | TCopy) => TCopy,\n    disposer?: (value: TCopy) => void,\n    owner?: Owner,\n  ) {\n    // We don't care if the disposer doesn't support freeing T\n    super(value, copier, disposer as (value: T | TCopy) => void, owner)\n  }\n\n  dispose() {\n    this._alive = false\n  }\n}\n\nfunction scopeFinally(scope: Scope, blockError: Error | undefined) {\n  // console.log('scopeFinally', scope, blockError)\n  let disposeError: Error | undefined\n  try {\n    scope.dispose()\n  } catch (error) {\n    disposeError = error as any\n  }\n\n  if (blockError && disposeError) {\n    Object.assign(blockError, {\n      message: `${blockError.message}\\n Then, failed to dispose scope: ${disposeError.message}`,\n      disposeError,\n    })\n    throw blockError\n  }\n\n  if (blockError || disposeError) {\n    throw blockError || disposeError\n  }\n}\n\n/**\n * Scope helps reduce the burden of manually tracking and disposing of\n * Lifetimes. See {@link withScope}. and {@link withScopeAsync}.\n */\nexport class Scope extends UsingDisposable implements Disposable {\n  /**\n   * Run `block` with a new Scope instance that will be disposed after the block returns.\n   * Inside `block`, call `scope.manage` on each lifetime you create to have the lifetime\n   * automatically disposed after the block returns.\n   *\n   * @warning Do not use with async functions. Instead, use {@link withScopeAsync}.\n   */\n  static withScope<R>(block: (scope: Scope) => R): R {\n    const scope = new Scope()\n    let blockError: Error | undefined\n    try {\n      return block(scope)\n    } catch (error) {\n      blockError = error as any\n      throw error\n    } finally {\n      scopeFinally(scope, blockError)\n    }\n  }\n\n  static withScopeMaybeAsync<Return, This, Yielded>(\n    _this: This,\n    block: MaybeAsyncBlock<Return, This, Yielded, [Scope]>,\n  ): Return | Promise<Return> {\n    return maybeAsync(undefined, function* (awaited) {\n      const scope = new Scope()\n      let blockError: Error | undefined\n      try {\n        return yield* awaited.of(block.call(_this, awaited, scope))\n      } catch (error) {\n        blockError = error as any\n        throw error\n      } finally {\n        scopeFinally(scope, blockError)\n      }\n    })\n  }\n\n  /**\n   * Run `block` with a new Scope instance that will be disposed after the\n   * block's returned promise settles. Inside `block`, call `scope.manage` on each\n   * lifetime you create to have the lifetime automatically disposed after the\n   * block returns.\n   */\n  static async withScopeAsync<R>(block: (scope: Scope) => Promise<R>): Promise<R> {\n    const scope = new Scope()\n    let blockError: Error | undefined\n    try {\n      return await block(scope)\n    } catch (error) {\n      blockError = error as any\n      throw error\n    } finally {\n      scopeFinally(scope, blockError)\n    }\n  }\n\n  private _disposables: Lifetime<Set<Disposable>> = new Lifetime(new Set())\n\n  /**\n   * Track `lifetime` so that it is disposed when this scope is disposed.\n   */\n  manage<T extends Disposable>(lifetime: T): T {\n    this._disposables.value.add(lifetime)\n    return lifetime\n  }\n\n  get alive() {\n    return this._disposables.alive\n  }\n\n  dispose() {\n    const lifetimes = Array.from(this._disposables.value.values()).reverse()\n    for (const lifetime of lifetimes) {\n      if (lifetime.alive) {\n        lifetime.dispose()\n      }\n    }\n    this._disposables.dispose()\n  }\n}\n","import { JSPromiseStateEnum } from \"@jitl/quickjs-ffi-types\"\nimport type {\n  EvalFlags,\n  EitherModule,\n  EvalDetectModule,\n  JSBorrowedCharPointer,\n  JSContextPointer,\n  JSRuntimePointer,\n  JSValueConstPointer,\n  JSValuePointer,\n  JSValuePointerPointer,\n  EitherFFI,\n} from \"@jitl/quickjs-ffi-types\"\nimport { debugLog } from \"./debug\"\nimport type { JSPromiseState } from \"./deferred-promise\"\nimport { QuickJSDeferredPromise } from \"./deferred-promise\"\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { shouldInterruptAfterDeadline } from \"./interrupt-helpers\"\nimport { QuickJSPromisePending, QuickJSUnwrapError } from \"./errors\"\nimport type { Disposable } from \"./lifetime\"\nimport { Lifetime, Scope, StaticLifetime, UsingDisposable, WeakLifetime } from \"./lifetime\"\nimport { ModuleMemory } from \"./memory\"\nimport type { ContextCallbacks, QuickJSModuleCallbacks } from \"./module\"\nimport type {\n  QuickJSRuntime,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ExecutePendingJobsResult,\n} from \"./runtime\"\nimport type { ContextEvalOptions, JSValue, PromiseExecutor, QuickJSHandle } from \"./types\"\nimport { evalOptionsToFlags } from \"./types\"\nimport type {\n  LowLevelJavascriptVm,\n  SuccessOrFail,\n  VmCallResult,\n  VmFunctionImplementation,\n  VmPropertyDescriptor,\n} from \"./vm-interface\"\n\n/**\n * Property key for getting or setting a property on a handle with\n * {@link QuickJSContext#getProp}, {@link QuickJSContext#setProp}, or {@link QuickJSContext#defineProp}.\n */\nexport type QuickJSPropertyKey = number | string | QuickJSHandle\n\n/**\n * @private\n */\nclass ContextMemory extends ModuleMemory implements Disposable {\n  readonly owner: QuickJSRuntime\n  readonly ctx: Lifetime<JSContextPointer>\n  readonly rt: Lifetime<JSRuntimePointer>\n  readonly module: EitherModule\n  readonly ffi: EitherFFI\n  readonly scope = new Scope()\n\n  /** @private */\n  constructor(args: {\n    owner: QuickJSRuntime\n    module: EitherModule\n    ffi: EitherFFI\n    ctx: Lifetime<JSContextPointer>\n    rt: Lifetime<JSRuntimePointer>\n    ownedLifetimes?: Disposable[]\n  }) {\n    super(args.module)\n    args.ownedLifetimes?.forEach((lifetime) => this.scope.manage(lifetime))\n    this.owner = args.owner\n    this.module = args.module\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.ctx = this.scope.manage(args.ctx)\n  }\n\n  get alive() {\n    return this.scope.alive\n  }\n\n  dispose() {\n    return this.scope.dispose()\n  }\n\n  [Symbol.dispose]() {\n    return this.dispose()\n  }\n\n  /**\n   * Track `lifetime` so that it is disposed when this scope is disposed.\n   */\n  manage<T extends Disposable>(lifetime: T): T {\n    return this.scope.manage(lifetime)\n  }\n\n  copyJSValue = (ptr: JSValuePointer | JSValueConstPointer) => {\n    return this.ffi.QTS_DupValuePointer(this.ctx.value, ptr)\n  }\n\n  freeJSValue = (ptr: JSValuePointer) => {\n    this.ffi.QTS_FreeValuePointer(this.ctx.value, ptr)\n  }\n\n  consumeJSCharPointer(ptr: JSBorrowedCharPointer): string {\n    const str = this.module.UTF8ToString(ptr)\n    this.ffi.QTS_FreeCString(this.ctx.value, ptr)\n    return str\n  }\n\n  heapValueHandle(ptr: JSValuePointer): JSValue {\n    return new Lifetime(ptr, this.copyJSValue, this.freeJSValue, this.owner)\n  }\n}\n\n/**\n * QuickJSContext wraps a QuickJS Javascript context (JSContext*) within a\n * runtime. The contexts within the same runtime may exchange objects freely.\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain. The {@link runtime} references the context's runtime.\n *\n * This class's methods return {@link QuickJSHandle}, which wrap C pointers (JSValue*).\n * It's the caller's responsibility to call `.dispose()` on any\n * handles you create to free memory once you're done with the handle.\n *\n * Use {@link QuickJSRuntime#newContext} or {@link QuickJSWASMModule#newContext}\n * to create a new QuickJSContext.\n *\n * Create QuickJS values inside the interpreter with methods like\n * {@link newNumber}, {@link newString}, {@link newArray}, {@link newObject},\n * {@link newFunction}, and {@link newPromise}.\n *\n * Call {@link setProp} or {@link defineProp} to customize objects. Use those methods\n * with {@link global} to expose the values you create to the interior of the\n * interpreter, so they can be used in {@link evalCode}.\n *\n * Use {@link evalCode} or {@link callFunction} to execute Javascript inside the VM. If\n * you're using asynchronous code inside the QuickJSContext, you may need to also\n * call {@link QuickJSRuntime#executePendingJobs}. Executing code inside the runtime returns a\n * result object representing successful execution or an error. You must dispose\n * of any such results to avoid leaking memory inside the VM.\n *\n * Implement memory and CPU constraints at the runtime level, using {@link runtime}.\n * See {@link QuickJSRuntime} for more information.\n *\n */\n// TODO: Manage own callback registration\nexport class QuickJSContext\n  extends UsingDisposable\n  implements LowLevelJavascriptVm<QuickJSHandle>, Disposable\n{\n  /**\n   * The runtime that created this context.\n   */\n  public readonly runtime: QuickJSRuntime\n\n  /** @private */\n  protected readonly ctx: Lifetime<JSContextPointer>\n  /** @private */\n  protected readonly rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected readonly module: EitherModule\n  /** @private */\n  protected readonly ffi: EitherFFI\n  /** @private */\n  protected memory: ContextMemory\n\n  /** @private */\n  protected _undefined: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _null: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _false: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _true: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _global: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _BigInt: QuickJSHandle | undefined = undefined\n\n  /**\n   * Use {@link QuickJSRuntime#newContext} or {@link QuickJSWASMModule#newContext}\n   * to create a new QuickJSContext.\n   */\n  constructor(args: {\n    module: EitherModule\n    ffi: EitherFFI\n    ctx: Lifetime<JSContextPointer>\n    rt: Lifetime<JSRuntimePointer>\n    runtime: QuickJSRuntime\n    ownedLifetimes?: Disposable[]\n    callbacks: QuickJSModuleCallbacks\n  }) {\n    super()\n    this.runtime = args.runtime\n    this.module = args.module\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.ctx = args.ctx\n    this.memory = new ContextMemory({\n      ...args,\n      owner: this.runtime,\n    })\n    args.callbacks.setContextCallbacks(this.ctx.value, this.cToHostCallbacks)\n    this.dump = this.dump.bind(this)\n    this.getString = this.getString.bind(this)\n    this.getNumber = this.getNumber.bind(this)\n    this.resolvePromise = this.resolvePromise.bind(this)\n  }\n\n  // @implement Disposable ----------------------------------------------------\n\n  get alive() {\n    return this.memory.alive\n  }\n\n  /**\n   * Dispose of this VM's underlying resources.\n   *\n   * @throws Calling this method without disposing of all created handles\n   * will result in an error.\n   */\n  dispose() {\n    this.memory.dispose()\n  }\n\n  // Globals ------------------------------------------------------------------\n\n  /**\n   * [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined).\n   */\n  get undefined(): QuickJSHandle {\n    if (this._undefined) {\n      return this._undefined\n    }\n\n    // Undefined is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetUndefined()\n    return (this._undefined = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null).\n   */\n  get null(): QuickJSHandle {\n    if (this._null) {\n      return this._null\n    }\n\n    // Null is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetNull()\n    return (this._null = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`true`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/true).\n   */\n  get true(): QuickJSHandle {\n    if (this._true) {\n      return this._true\n    }\n\n    // True is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetTrue()\n    return (this._true = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`false`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/false).\n   */\n  get false(): QuickJSHandle {\n    if (this._false) {\n      return this._false\n    }\n\n    // False is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetFalse()\n    return (this._false = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`global`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects).\n   * A handle to the global object inside the interpreter.\n   * You can set properties to create global variables.\n   */\n  get global(): QuickJSHandle {\n    if (this._global) {\n      return this._global\n    }\n\n    // The global is a JSValue, but since it's lifetime is as long as the VM's,\n    // we should manage it.\n    const ptr = this.ffi.QTS_GetGlobalObject(this.ctx.value)\n\n    // Automatically clean up this reference when we dispose\n    this.memory.manage(this.memory.heapValueHandle(ptr))\n\n    // This isn't technically a static lifetime, but since it has the same\n    // lifetime as the VM, it's okay to fake one since when the VM is\n    // disposed, no other functions will accept the value.\n    this._global = new StaticLifetime(ptr, this.runtime)\n    return this._global\n  }\n\n  // New values ---------------------------------------------------------------\n\n  /**\n   * Converts a Javascript number into a QuickJS value.\n   */\n  newNumber(num: number): QuickJSHandle {\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFloat64(this.ctx.value, num))\n  }\n\n  /**\n   * Create a QuickJS [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) value.\n   */\n  newString(str: string): QuickJSHandle {\n    const ptr = this.memory\n      .newHeapCharPointer(str)\n      .consume((charHandle) => this.ffi.QTS_NewString(this.ctx.value, charHandle.value.ptr))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a QuickJS [symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) value.\n   * No two symbols created with this function will be the same value.\n   */\n  newUniqueSymbol(description: string | symbol): QuickJSHandle {\n    const key = (typeof description === \"symbol\" ? description.description : description) ?? \"\"\n    const ptr = this.memory\n      .newHeapCharPointer(key)\n      .consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value.ptr, 0))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Get a symbol from the [global registry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry) for the given key.\n   * All symbols created with the same key will be the same value.\n   */\n  newSymbolFor(key: string | symbol): QuickJSHandle {\n    const description = (typeof key === \"symbol\" ? key.description : key) ?? \"\"\n    const ptr = this.memory\n      .newHeapCharPointer(description)\n      .consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value.ptr, 1))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a QuickJS [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) value.\n   */\n  newBigInt(num: bigint): QuickJSHandle {\n    if (!this._BigInt) {\n      const bigIntHandle = this.getProp(this.global, \"BigInt\")\n      this.memory.manage(bigIntHandle)\n      this._BigInt = new StaticLifetime(bigIntHandle.value as JSValueConstPointer, this.runtime)\n    }\n\n    const bigIntHandle = this._BigInt\n    const asString = String(num)\n    return this.newString(asString).consume((handle) =>\n      this.unwrapResult(this.callFunction(bigIntHandle, this.undefined, handle)),\n    )\n  }\n\n  /**\n   * `{}`.\n   * Create a new QuickJS [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer).\n   *\n   * @param prototype - Like [`Object.create`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create).\n   */\n  newObject(prototype?: QuickJSHandle): QuickJSHandle {\n    if (prototype) {\n      this.runtime.assertOwned(prototype)\n    }\n    const ptr = prototype\n      ? this.ffi.QTS_NewObjectProto(this.ctx.value, prototype.value)\n      : this.ffi.QTS_NewObject(this.ctx.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * `[]`.\n   * Create a new QuickJS [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).\n   */\n  newArray(): QuickJSHandle {\n    const ptr = this.ffi.QTS_NewArray(this.ctx.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   *  Create a new QuickJS [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer).\n   */\n  newArrayBuffer(buffer: ArrayBufferLike): QuickJSHandle {\n    const array = new Uint8Array(buffer)\n    const handle = this.memory.newHeapBufferPointer(array)\n    const ptr = this.ffi.QTS_NewArrayBuffer(this.ctx.value, handle.value.pointer, array.length)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a new {@link QuickJSDeferredPromise}. Use `deferred.resolve(handle)` and\n   * `deferred.reject(handle)` to fulfill the promise handle available at `deferred.handle`.\n   * Note that you are responsible for calling `deferred.dispose()` to free the underlying\n   * resources; see the documentation on {@link QuickJSDeferredPromise} for details.\n   */\n  newPromise(): QuickJSDeferredPromise\n  /**\n   * Create a new {@link QuickJSDeferredPromise} that resolves when the\n   * given native Promise<QuickJSHandle> resolves. Rejections will be coerced\n   * to a QuickJS error.\n   *\n   * You can still resolve/reject the created promise \"early\" using its methods.\n   */\n  newPromise(promise: Promise<QuickJSHandle>): QuickJSDeferredPromise\n  /**\n   * Construct a new native Promise<QuickJSHandle>, and then convert it into a\n   * {@link QuickJSDeferredPromise}.\n   *\n   * You can still resolve/reject the created promise \"early\" using its methods.\n   */\n  newPromise(\n    newPromiseFn: PromiseExecutor<QuickJSHandle, Error | QuickJSHandle>,\n  ): QuickJSDeferredPromise\n  newPromise(\n    value?: PromiseExecutor<QuickJSHandle, Error | QuickJSHandle> | Promise<QuickJSHandle>,\n  ): QuickJSDeferredPromise {\n    const deferredPromise = Scope.withScope((scope) => {\n      const mutablePointerArray = scope.manage(\n        this.memory.newMutablePointerArray<JSValuePointerPointer>(2),\n      )\n      const promisePtr = this.ffi.QTS_NewPromiseCapability(\n        this.ctx.value,\n        mutablePointerArray.value.ptr,\n      )\n      const promiseHandle = this.memory.heapValueHandle(promisePtr)\n      const [resolveHandle, rejectHandle] = Array.from(mutablePointerArray.value.typedArray).map(\n        (jsvaluePtr) => this.memory.heapValueHandle(jsvaluePtr as any),\n      )\n      return new QuickJSDeferredPromise({\n        context: this,\n        promiseHandle,\n        resolveHandle,\n        rejectHandle,\n      })\n    })\n\n    if (value && typeof value === \"function\") {\n      value = new Promise(value)\n    }\n\n    if (value) {\n      Promise.resolve(value).then(deferredPromise.resolve, (error) =>\n        error instanceof Lifetime\n          ? deferredPromise.reject(error)\n          : this.newError(error).consume(deferredPromise.reject),\n      )\n    }\n\n    return deferredPromise\n  }\n\n  /**\n   * Convert a Javascript function into a QuickJS function value.\n   * See {@link VmFunctionImplementation} for more details.\n   *\n   * A {@link VmFunctionImplementation} should not free its arguments or its return\n   * value. A VmFunctionImplementation should also not retain any references to\n   * its return value.\n   *\n   * The function argument handles are automatically disposed when the function\n   * returns. If you want to retain a handle beyond the end of the function, you\n   * can call {@link Lifetime#dup} to create a copy of the handle that you own\n   * and must dispose manually. For example, you need to use this API and do some\n   * extra book keeping to implement `setInterval`:\n   *\n   * ```typescript\n   * // This won't work because `callbackHandle` expires when the function returns,\n   * // so when the interval fires, the callback handle is already disposed.\n   * const WRONG_setIntervalHandle = context.newFunction(\"setInterval\", (callbackHandle, delayHandle) => {\n   *   const delayMs = context.getNumber(delayHandle)\n   *   const intervalId = globalThis.setInterval(() => {\n   *     // ERROR: callbackHandle is already disposed here.\n   *     context.callFunction(callbackHandle)\n   *   }, intervalId)\n   *   return context.newNumber(intervalId)\n   * })\n   *\n   * // This works since we dup the callbackHandle.\n   * // We just need to make sure we clean it up manually when the interval is cleared --\n   * // so we need to keep track of those interval IDs, and make sure we clean all\n   * // of them up when we dispose the owning context.\n   *\n   * const setIntervalHandle = context.newFunction(\"setInterval\", (callbackHandle, delayHandle) => {\n   *   // Ensure the guest can't overload us by scheduling too many intervals.\n   *   if (QuickJSInterval.INTERVALS.size > 100) {\n   *     throw new Error(`Too many intervals scheduled already`)\n   *   }\n   *\n   *   const delayMs = context.getNumber(delayHandle)\n   *   const longLivedCallbackHandle = callbackHandle.dup()\n   *   const intervalId = globalThis.setInterval(() => {\n   *     context.callFunction(longLivedCallbackHandle)\n   *   }, intervalId)\n   *   const disposable = new QuickJSInterval(longLivedCallbackHandle, context, intervalId)\n   *   QuickJSInterval.INTERVALS.set(intervalId, disposable)\n   *   return context.newNumber(intervalId)\n   * })\n   *\n   * const clearIntervalHandle = context.newFunction(\"clearInterval\", (intervalIdHandle) => {\n   *   const intervalId = context.getNumber(intervalIdHandle)\n   *   const disposable = QuickJSInterval.INTERVALS.get(intervalId)\n   *   disposable?.dispose()\n   * })\n   *\n   * class QuickJSInterval extends UsingDisposable {\n   *   static INTERVALS = new Map<number, QuickJSInterval>()\n   *\n   *   static disposeContext(context: QuickJSContext) {\n   *     for (const interval of QuickJSInterval.INTERVALS.values()) {\n   *       if (interval.context === context) {\n   *         interval.dispose()\n   *       }\n   *     }\n   *   }\n   *\n   *   constructor(\n   *     public fnHandle: QuickJSHandle,\n   *     public context: QuickJSContext,\n   *     public intervalId: number,\n   *   ) {\n   *     super()\n   *   }\n   *\n   *   dispose() {\n   *     globalThis.clearInterval(this.intervalId)\n   *     this.fnHandle.dispose()\n   *     QuickJSInterval.INTERVALS.delete(this.fnHandle.value)\n   *   }\n   *\n   *   get alive() {\n   *     return this.fnHandle.alive\n   *   }\n   * }\n   * ```\n   *\n   * To implement an async function, create a promise with {@link newPromise}, then\n   * return the deferred promise handle from `deferred.handle` from your\n   * function implementation:\n   *\n   * ```typescript\n   * const deferred = vm.newPromise()\n   * someNativeAsyncFunction().then(deferred.resolve)\n   * return deferred.handle\n   * ```\n   */\n  newFunction(name: string, fn: VmFunctionImplementation<QuickJSHandle>): QuickJSHandle {\n    const fnId = ++this.fnNextId\n    this.setFunction(fnId, fn)\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFunction(this.ctx.value, fnId, name))\n  }\n\n  newError(error: { name: string; message: string }): QuickJSHandle\n  newError(message: string): QuickJSHandle\n  newError(): QuickJSHandle\n  newError(error?: string | { name: string; message: string }): QuickJSHandle {\n    const errorHandle = this.memory.heapValueHandle(this.ffi.QTS_NewError(this.ctx.value))\n\n    if (error && typeof error === \"object\") {\n      if (error.name !== undefined) {\n        this.newString(error.name).consume((handle) => this.setProp(errorHandle, \"name\", handle))\n      }\n\n      if (error.message !== undefined) {\n        this.newString(error.message).consume((handle) =>\n          this.setProp(errorHandle, \"message\", handle),\n        )\n      }\n    } else if (typeof error === \"string\") {\n      this.newString(error).consume((handle) => this.setProp(errorHandle, \"message\", handle))\n    } else if (error !== undefined) {\n      // This isn't supported in the type signature but maybe it will make life easier.\n      this.newString(String(error)).consume((handle) =>\n        this.setProp(errorHandle, \"message\", handle),\n      )\n    }\n\n    return errorHandle\n  }\n\n  // Read values --------------------------------------------------------------\n\n  /**\n   * `typeof` operator. **Not** [standards compliant](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof).\n   *\n   * @remarks\n   * Does not support BigInt values correctly.\n   */\n  typeof(handle: QuickJSHandle) {\n    this.runtime.assertOwned(handle)\n    return this.memory.consumeHeapCharPointer(this.ffi.QTS_Typeof(this.ctx.value, handle.value))\n  }\n\n  /**\n   * Converts `handle` into a Javascript number.\n   * @returns `NaN` on error, otherwise a `number`.\n   */\n  getNumber(handle: QuickJSHandle): number {\n    this.runtime.assertOwned(handle)\n    return this.ffi.QTS_GetFloat64(this.ctx.value, handle.value)\n  }\n\n  /**\n   * Converts `handle` to a Javascript string.\n   */\n  getString(handle: QuickJSHandle): string {\n    this.runtime.assertOwned(handle)\n    return this.memory.consumeJSCharPointer(this.ffi.QTS_GetString(this.ctx.value, handle.value))\n  }\n\n  /**\n   * Converts `handle` into a Javascript symbol. If the symbol is in the global\n   * registry in the guest, it will be created with Symbol.for on the host.\n   */\n  getSymbol(handle: QuickJSHandle): symbol {\n    this.runtime.assertOwned(handle)\n    const key = this.memory.consumeJSCharPointer(\n      this.ffi.QTS_GetSymbolDescriptionOrKey(this.ctx.value, handle.value),\n    )\n    const isGlobal = this.ffi.QTS_IsGlobalSymbol(this.ctx.value, handle.value)\n    return isGlobal ? Symbol.for(key) : Symbol(key)\n  }\n\n  /**\n   * Converts `handle` to a Javascript bigint.\n   */\n  getBigInt(handle: QuickJSHandle): bigint {\n    this.runtime.assertOwned(handle)\n    const asString = this.getString(handle)\n    return BigInt(asString)\n  }\n\n  /**\n   * Coverts `handle` to a JavaScript ArrayBuffer\n   */\n  getArrayBuffer(handle: QuickJSHandle): Lifetime<Uint8Array> {\n    this.runtime.assertOwned(handle)\n    const len = this.ffi.QTS_GetArrayBufferLength(this.ctx.value, handle.value)\n    const ptr = this.ffi.QTS_GetArrayBuffer(this.ctx.value, handle.value)\n    if (!ptr) {\n      throw new Error(\"Couldn't allocate memory to get ArrayBuffer\")\n    }\n    return new Lifetime(this.module.HEAPU8.subarray(ptr, ptr + len), undefined, () =>\n      this.module._free(ptr),\n    )\n  }\n\n  /**\n   * Get the current state of a QuickJS promise, see {@link JSPromiseState} for the possible states.\n   * This can be used to expect a promise to be fulfilled when combined with {@link unwrapResult}:\n   *\n   * ```typescript\n   * const promiseHandle = context.evalCode(`Promise.resolve(42)`);\n   * const resultHandle = context.unwrapResult(\n   *  context.getPromiseState(promiseHandle)\n   * );\n   * context.getNumber(resultHandle) === 42; // true\n   * resultHandle.dispose();\n   * ```\n   */\n  getPromiseState(handle: QuickJSHandle): JSPromiseState {\n    this.runtime.assertOwned(handle)\n    const state = this.ffi.QTS_PromiseState(this.ctx.value, handle.value)\n    if (state < 0) {\n      // Not a promise, but act like `await` would with non-promise, and just return the value.\n      return { type: \"fulfilled\", value: handle, notAPromise: true }\n    }\n\n    if (state === JSPromiseStateEnum.Pending) {\n      return {\n        type: \"pending\",\n        get error() {\n          return new QuickJSPromisePending(`Cannot unwrap a pending promise`)\n        },\n      }\n    }\n\n    const ptr = this.ffi.QTS_PromiseResult(this.ctx.value, handle.value)\n    const result = this.memory.heapValueHandle(ptr)\n    if (state === JSPromiseStateEnum.Fulfilled) {\n      return { type: \"fulfilled\", value: result }\n    }\n    if (state === JSPromiseStateEnum.Rejected) {\n      return { type: \"rejected\", error: result }\n    }\n    result.dispose()\n    throw new Error(`Unknown JSPromiseStateEnum: ${state}`)\n  }\n\n  /**\n   * `Promise.resolve(value)`.\n   * Convert a handle containing a Promise-like value inside the VM into an\n   * actual promise on the host.\n   *\n   * @remarks\n   * You may need to call {@link runtime}.{@link QuickJSRuntime#executePendingJobs} to ensure that the promise is resolved.\n   *\n   * @param promiseLikeHandle - A handle to a Promise-like value with a `.then(onSuccess, onError)` method.\n   */\n  resolvePromise(promiseLikeHandle: QuickJSHandle): Promise<VmCallResult<QuickJSHandle>> {\n    this.runtime.assertOwned(promiseLikeHandle)\n    const vmResolveResult = Scope.withScope((scope) => {\n      const vmPromise = scope.manage(this.getProp(this.global, \"Promise\"))\n      const vmPromiseResolve = scope.manage(this.getProp(vmPromise, \"resolve\"))\n      return this.callFunction(vmPromiseResolve, vmPromise, promiseLikeHandle)\n    })\n    if (vmResolveResult.error) {\n      return Promise.resolve(vmResolveResult)\n    }\n\n    return new Promise<VmCallResult<QuickJSHandle>>((resolve) => {\n      Scope.withScope((scope) => {\n        const resolveHandle = scope.manage(\n          this.newFunction(\"resolve\", (value) => {\n            resolve({ value: value && value.dup() })\n          }),\n        )\n\n        const rejectHandle = scope.manage(\n          this.newFunction(\"reject\", (error) => {\n            resolve({ error: error && error.dup() })\n          }),\n        )\n\n        const promiseHandle = scope.manage(vmResolveResult.value)\n        const promiseThenHandle = scope.manage(this.getProp(promiseHandle, \"then\"))\n        this.unwrapResult(\n          this.callFunction(promiseThenHandle, promiseHandle, resolveHandle, rejectHandle),\n        ).dispose()\n      })\n    })\n  }\n\n  // Properties ---------------------------------------------------------------\n\n  /**\n   * `handle[key]`.\n   * Get a property from a JSValue.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string (which will be converted automatically).\n   */\n  getProp(handle: QuickJSHandle, key: QuickJSPropertyKey): QuickJSHandle {\n    this.runtime.assertOwned(handle)\n    const ptr = this.borrowPropertyKey(key).consume((quickJSKey) =>\n      this.ffi.QTS_GetProp(this.ctx.value, handle.value, quickJSKey.value),\n    )\n    const result = this.memory.heapValueHandle(ptr)\n\n    return result\n  }\n\n  /**\n   * `handle[key] = value`.\n   * Set a property on a JSValue.\n   *\n   * @remarks\n   * Note that the QuickJS authors recommend using {@link defineProp} to define new\n   * properties.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  setProp(handle: QuickJSHandle, key: QuickJSPropertyKey, value: QuickJSHandle) {\n    this.runtime.assertOwned(handle)\n    // free newly allocated value if key was a string or number. No-op if string was already\n    // a QuickJS handle.\n    this.borrowPropertyKey(key).consume((quickJSKey) =>\n      this.ffi.QTS_SetProp(this.ctx.value, handle.value, quickJSKey.value, value.value),\n    )\n  }\n\n  /**\n   * [`Object.defineProperty(handle, key, descriptor)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  defineProp(\n    handle: QuickJSHandle,\n    key: QuickJSPropertyKey,\n    descriptor: VmPropertyDescriptor<QuickJSHandle>,\n  ): void {\n    this.runtime.assertOwned(handle)\n    Scope.withScope((scope) => {\n      const quickJSKey = scope.manage(this.borrowPropertyKey(key))\n\n      const value = descriptor.value || this.undefined\n      const configurable = Boolean(descriptor.configurable)\n      const enumerable = Boolean(descriptor.enumerable)\n      const hasValue = Boolean(descriptor.value)\n      const get = descriptor.get\n        ? scope.manage(this.newFunction(descriptor.get.name, descriptor.get))\n        : this.undefined\n      const set = descriptor.set\n        ? scope.manage(this.newFunction(descriptor.set.name, descriptor.set))\n        : this.undefined\n\n      this.ffi.QTS_DefineProp(\n        this.ctx.value,\n        handle.value,\n        quickJSKey.value,\n        value.value,\n        get.value,\n        set.value,\n        configurable,\n        enumerable,\n        hasValue,\n      )\n    })\n  }\n\n  // Evaluation ---------------------------------------------------------------\n\n  /**\n   * [`func.call(thisVal, ...args)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call).\n   * Call a JSValue as a function.\n   *\n   * See {@link unwrapResult}, which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use {@link resolvePromise} to convert it to a native promise and\n   * {@link runtime}.{@link QuickJSRuntime#executePendingJobs} to finish evaluating the promise.\n   *\n   * @returns A result. If the function threw synchronously, `result.error` be a\n   * handle to the exception. Otherwise `result.value` will be a handle to the\n   * value.\n   */\n  callFunction(\n    func: QuickJSHandle,\n    thisVal: QuickJSHandle,\n    ...args: QuickJSHandle[]\n  ): VmCallResult<QuickJSHandle> {\n    this.runtime.assertOwned(func)\n    const resultPtr = this.memory\n      .toPointerArray(args)\n      .consume((argsArrayPtr) =>\n        this.ffi.QTS_Call(\n          this.ctx.value,\n          func.value,\n          thisVal.value,\n          args.length,\n          argsArrayPtr.value,\n        ),\n      )\n\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Like [`eval(code)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Description).\n   *\n   * Evaluates `code`, as though it's in a file named `filename`, with options `options`.\n   *\n   * - When `options.type` is `\"global\"`, the code is evaluated in the global\n   *   scope of the QuickJSContext, and the return value is the result of the last\n   *   expression.\n   * - When `options.type` is `\"module\"`, the code is evaluated is a module scope.\n   *   It may use `import` and `export` if {@link runtime}.{@link QuickJSRuntime#setModuleLoader} was called.\n   *   It may use top-level await if supported by the underlying QuickJS library.\n   *   The return value is the module's exports, or a promise for the module's exports.\n   * - When `options.type` is unset, the code is evaluated as a module if it\n   *   contains an `import` or `export` statement, otherwise it is evaluated in\n   *   the global scope.\n   *\n   * When working with async code, you many need to call {@link runtime}.{@link QuickJSRuntime#executePendingJobs}\n   * to execute callbacks pending after synchronous evaluation returns.\n   *\n   * See {@link unwrapResult}, which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use {@link resolvePromise} to convert it to a native promise and\n   * {@link QuickJSRuntime#executePendingJobs} to finish evaluating the promise.\n   *\n   * *Note*: to protect against infinite loops, provide an interrupt handler to\n   * {@link QuickJSRuntime#setInterruptHandler}. You can use {@link shouldInterruptAfterDeadline} to\n   * create a time-based deadline.\n   *\n   * @returns The last statement's value. If the code threw synchronously,\n   * `result.error` will be a handle to the exception. If execution was\n   * interrupted, the error will have name `InternalError` and message\n   * `interrupted`.\n   */\n  evalCode(\n    code: string,\n    filename: string = \"eval.js\",\n    /**\n     * If no options are passed, a heuristic will be used to detect if `code` is\n     * an ES module.\n     *\n     * See {@link EvalFlags} for number semantics.\n     */\n    options?: number | ContextEvalOptions,\n  ): VmCallResult<QuickJSHandle> {\n    const detectModule = (options === undefined ? 1 : 0) as EvalDetectModule\n    const flags = evalOptionsToFlags(options) as EvalFlags\n    const resultPtr = this.memory\n      .newHeapCharPointer(code)\n      .consume((charHandle) =>\n        this.ffi.QTS_Eval(\n          this.ctx.value,\n          charHandle.value.ptr,\n          charHandle.value.strlen,\n          filename,\n          detectModule,\n          flags,\n        ),\n      )\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Throw an error in the VM, interrupted whatever current execution is in progress when execution resumes.\n   * @experimental\n   */\n  throw(error: Error | QuickJSHandle) {\n    return this.errorToHandle(error).consume((handle) =>\n      this.ffi.QTS_Throw(this.ctx.value, handle.value),\n    )\n  }\n\n  /**\n   * @private\n   */\n  protected borrowPropertyKey(key: QuickJSPropertyKey): QuickJSHandle {\n    if (typeof key === \"number\") {\n      return this.newNumber(key)\n    }\n\n    if (typeof key === \"string\") {\n      return this.newString(key)\n    }\n\n    // key is already a JSValue, but we're borrowing it. Return a static handle\n    // for internal use only.\n    return new StaticLifetime(key.value as JSValueConstPointer, this.runtime)\n  }\n\n  /**\n   * @private\n   */\n  getMemory(rt: JSRuntimePointer): ContextMemory {\n    if (rt === this.rt.value) {\n      return this.memory\n    } else {\n      throw new Error(\"Private API. Cannot get memory from a different runtime\")\n    }\n  }\n\n  // Utilities ----------------------------------------------------------------\n\n  /**\n   * Dump a JSValue to Javascript in a best-effort fashion.\n   * If the value is a promise, dumps the promise's state.\n   * Returns `handle.toString()` if it cannot be serialized to JSON.\n   */\n  dump(handle: QuickJSHandle): any {\n    this.runtime.assertOwned(handle)\n    const type = this.typeof(handle)\n    if (type === \"string\") {\n      return this.getString(handle)\n    } else if (type === \"number\") {\n      return this.getNumber(handle)\n    } else if (type === \"bigint\") {\n      return this.getBigInt(handle)\n    } else if (type === \"undefined\") {\n      return undefined\n    } else if (type === \"symbol\") {\n      return this.getSymbol(handle)\n    }\n\n    // It's confusing if we dump(promise) and just get back {} because promise\n    // has no properties, so dump promise state.\n    const asPromiseState = this.getPromiseState(handle)\n    if (asPromiseState.type === \"fulfilled\" && !asPromiseState.notAPromise) {\n      handle.dispose()\n      return { type: asPromiseState.type, value: asPromiseState.value.consume(this.dump) }\n    } else if (asPromiseState.type === \"pending\") {\n      handle.dispose()\n      return { type: asPromiseState.type }\n    } else if (asPromiseState.type === \"rejected\") {\n      handle.dispose()\n      return { type: asPromiseState.type, error: asPromiseState.error.consume(this.dump) }\n    }\n\n    const str = this.memory.consumeJSCharPointer(this.ffi.QTS_Dump(this.ctx.value, handle.value))\n    try {\n      return JSON.parse(str)\n    } catch (err) {\n      return str\n    }\n  }\n\n  /**\n   * Unwrap a SuccessOrFail result such as a {@link VmCallResult} or a\n   * {@link ExecutePendingJobsResult}, where the fail branch contains a handle to a QuickJS error value.\n   * If the result is a success, returns the value.\n   * If the result is an error, converts the error to a native object and throws the error.\n   */\n  unwrapResult<T>(result: SuccessOrFail<T, QuickJSHandle>): T {\n    if (result.error) {\n      const context: QuickJSContext =\n        \"context\" in result.error ? (result.error as { context: QuickJSContext }).context : this\n      const cause = result.error.consume((error) => this.dump(error))\n\n      if (cause && typeof cause === \"object\" && typeof cause.message === \"string\") {\n        const { message, name, stack } = cause\n        const exception = new QuickJSUnwrapError(\"\")\n        const hostStack = exception.stack\n\n        if (typeof name === \"string\") {\n          exception.name = cause.name\n        }\n\n        if (typeof stack === \"string\") {\n          exception.stack = `${name}: ${message}\\n${cause.stack}Host: ${hostStack}`\n        }\n\n        Object.assign(exception, { cause, context, message })\n        throw exception\n      }\n\n      throw new QuickJSUnwrapError(cause, context)\n    }\n\n    return result.value\n  }\n\n  /** @private */\n  protected fnNextId = -32768 // min value of signed 16bit int used by Quickjs\n  /** @private */\n  protected fnMaps = new Map<number, Map<number, VmFunctionImplementation<QuickJSHandle>>>()\n\n  /** @private */\n  protected getFunction(fn_id: number): VmFunctionImplementation<QuickJSHandle> | undefined {\n    const map_id = fn_id >> 8\n    const fnMap = this.fnMaps.get(map_id)\n    if (!fnMap) {\n      return undefined\n    }\n    return fnMap.get(fn_id)\n  }\n\n  /** @private */\n  protected setFunction(fn_id: number, handle: VmFunctionImplementation<QuickJSHandle>) {\n    const map_id = fn_id >> 8\n    let fnMap = this.fnMaps.get(map_id)\n    if (!fnMap) {\n      fnMap = new Map<number, VmFunctionImplementation<QuickJSHandle>>()\n      this.fnMaps.set(map_id, fnMap)\n    }\n    return fnMap.set(fn_id, handle)\n  }\n\n  /**\n   * @hidden\n   */\n  private cToHostCallbacks: ContextCallbacks = {\n    callFunction: (ctx, this_ptr, argc, argv, fn_id) => {\n      if (ctx !== this.ctx.value) {\n        throw new Error(\"QuickJSContext instance received C -> JS call with mismatched ctx\")\n      }\n\n      const fn = this.getFunction(fn_id)\n      if (!fn) {\n        // this \"throw\" is not catch-able from the TS side. could we somehow handle this higher up?\n        throw new Error(`QuickJSContext had no callback with id ${fn_id}`)\n      }\n\n      return Scope.withScopeMaybeAsync(this, function* (awaited, scope) {\n        const thisHandle = scope.manage(\n          new WeakLifetime(\n            this_ptr,\n            this.memory.copyJSValue,\n            this.memory.freeJSValue,\n            this.runtime,\n          ),\n        )\n        const argHandles = new Array<QuickJSHandle>(argc)\n        for (let i = 0; i < argc; i++) {\n          const ptr = this.ffi.QTS_ArgvGetJSValueConstPointer(argv, i)\n          argHandles[i] = scope.manage(\n            new WeakLifetime(ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime),\n          )\n        }\n\n        try {\n          const result = yield* awaited(fn.apply(thisHandle, argHandles))\n          if (result) {\n            if (\"error\" in result && result.error) {\n              debugLog(\"throw error\", result.error)\n              throw result.error\n            }\n            const handle = scope.manage(result instanceof Lifetime ? result : result.value)\n            return this.ffi.QTS_DupValuePointer(this.ctx.value, handle.value)\n          }\n          return 0 as JSValuePointer\n        } catch (error) {\n          return this.errorToHandle(error as Error).consume((errorHandle) =>\n            this.ffi.QTS_Throw(this.ctx.value, errorHandle.value),\n          )\n        }\n      }) as JSValuePointer\n    },\n  }\n\n  private errorToHandle(error: Error | QuickJSHandle): QuickJSHandle {\n    if (error instanceof Lifetime) {\n      return error\n    }\n\n    return this.newError(error)\n  }\n\n  /**\n   * Outputs QuickJS Objects in binary form\n   *\n   * **WARNING**: QuickJS's binary JSON doesn't have a standard so expect it to change between version\n   *\n   * ```ts\n   * // imagine sending data to another via IPC\n   * let dataLifetime = context.newString(\"This is an example\")\n   *  ?.consume(handle => context.encodeBinaryJSON(handle))\n   *  ?.consume(handle => context.getArrayBuffer(handle))\n   * socket.write(dataLifetime?.value)\n   * ```\n   */\n  encodeBinaryJSON(handle: QuickJSHandle): QuickJSHandle {\n    const ptr = this.ffi.QTS_bjson_encode(this.ctx.value, handle.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Outputs Handle of the given QuickJS Object in binary form\n   *\n   * ```ts\n   * // imagine receiving data from another via IPC\n   * socket.on(\"data\", chunk => {\n   *  context.newArrayBuffer(chunk)\n   *    ?.consume(handle => context.decodeBinaryJSON(handle))\n   *    ?.consume(handle => console.log(context.dump(handle)))\n   * })\n   * ```\n   */\n  decodeBinaryJSON(handle: QuickJSHandle): QuickJSHandle {\n    const ptr = this.ffi.QTS_bjson_decode(this.ctx.value, handle.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n}\n","import { UsingDisposable, type Disposable } from \"./lifetime\"\nimport type { QuickJSHandle } from \"./types\"\nimport type { QuickJSRuntime } from \"./runtime\"\nimport type { QuickJSContext } from \"./context\"\nexport type { PromiseExecutor } from \"./types\"\n\n/**\n * A promise state inside QuickJS, which can be pending, fulfilled, or rejected.\n * You can unwrap a JSPromiseState with {@link QuickJSContext#unwrapResult}.\n */\nexport type JSPromiseState =\n  | JSPromiseStatePending\n  | JSPromiseStateFulfilled\n  | JSPromiseStateRejected\n\n/**\n * Pending promise state.\n * See {@link JSPromiseState}.\n */\nexport interface JSPromiseStatePending {\n  type: \"pending\"\n  /**\n   * The error property here allows unwrapping a JSPromiseState with {@link QuickJSContext#unwrapResult}.\n   * Unwrapping a pending promise will throw a {@link QuickJSPromisePending} error.\n   */\n  get error(): Error\n}\n\n/**\n * Fulfilled promise state.\n * See {@link JSPromiseState}.\n */\nexport interface JSPromiseStateFulfilled {\n  type: \"fulfilled\"\n  value: QuickJSHandle\n  error?: undefined\n  /** Trying to get the promise state of a non-Promise value returns a fulfilled state with the original value, and `notAPromise: true`. */\n  notAPromise?: boolean\n}\n\n/**\n * Rejected promise state.\n * See {@link JSPromiseState}.\n */\nexport interface JSPromiseStateRejected {\n  type: \"rejected\"\n  error: QuickJSHandle\n}\n\n/**\n * QuickJSDeferredPromise wraps a QuickJS promise {@link handle} and allows\n * {@link resolve}ing or {@link reject}ing that promise. Use it to bridge asynchronous\n * code on the host to APIs inside a QuickJSContext.\n *\n * Managing the lifetime of promises is tricky. There are three\n * {@link QuickJSHandle}s inside of each deferred promise object: (1) the promise\n * itself, (2) the `resolve` callback, and (3) the `reject` callback.\n *\n * - If the promise will be fulfilled before the end of it's {@link owner}'s lifetime,\n *   the only cleanup necessary is `deferred.handle.dispose()`, because\n *   calling {@link resolve} or {@link reject} will dispose of both callbacks automatically.\n *\n * - As the return value of a {@link VmFunctionImplementation}, return {@link handle},\n *   and ensure that either {@link resolve} or {@link reject} will be called. No other\n *   clean-up is necessary.\n *\n * - In other cases, call {@link dispose}, which will dispose {@link handle} as well as the\n *   QuickJS handles that back {@link resolve} and {@link reject}. For this object,\n *   {@link dispose} is idempotent.\n */\nexport class QuickJSDeferredPromise extends UsingDisposable implements Disposable {\n  public owner: QuickJSRuntime\n  public context: QuickJSContext\n\n  /**\n   * A handle of the Promise instance inside the QuickJSContext.\n   * You must dispose {@link handle} or the entire QuickJSDeferredPromise once you\n   * are finished with it.\n   */\n  public handle: QuickJSHandle\n\n  /**\n   * A native promise that will resolve once this deferred is settled.\n   */\n  public settled: Promise<void>\n\n  private resolveHandle: QuickJSHandle\n  private rejectHandle: QuickJSHandle\n  private onSettled!: () => void\n\n  /**\n   * Use {@link QuickJSContext#newPromise} to create a new promise instead of calling\n   * this constructor directly.\n   */\n  constructor(args: {\n    context: QuickJSContext\n    promiseHandle: QuickJSHandle\n    resolveHandle: QuickJSHandle\n    rejectHandle: QuickJSHandle\n  }) {\n    super()\n    this.context = args.context\n    this.owner = args.context.runtime\n    this.handle = args.promiseHandle\n    this.settled = new Promise((resolve) => {\n      this.onSettled = resolve\n    })\n    this.resolveHandle = args.resolveHandle\n    this.rejectHandle = args.rejectHandle\n  }\n\n  /**\n   * Resolve {@link handle} with the given value, if any.\n   * Calling this method after calling {@link dispose} is a no-op.\n   *\n   * Note that after resolving a promise, you may need to call\n   * {@link QuickJSRuntime#executePendingJobs} to propagate the result to the promise's\n   * callbacks.\n   */\n  resolve = (value?: QuickJSHandle) => {\n    if (!this.resolveHandle.alive) {\n      return\n    }\n\n    this.context\n      .unwrapResult(\n        this.context.callFunction(\n          this.resolveHandle,\n          this.context.undefined,\n          value || this.context.undefined,\n        ),\n      )\n      .dispose()\n\n    this.disposeResolvers()\n    this.onSettled()\n  }\n\n  /**\n   * Reject {@link handle} with the given value, if any.\n   * Calling this method after calling {@link dispose} is a no-op.\n   *\n   * Note that after rejecting a promise, you may need to call\n   * {@link QuickJSRuntime#executePendingJobs} to propagate the result to the promise's\n   * callbacks.\n   */\n  reject = (value?: QuickJSHandle) => {\n    if (!this.rejectHandle.alive) {\n      return\n    }\n\n    this.context\n      .unwrapResult(\n        this.context.callFunction(\n          this.rejectHandle,\n          this.context.undefined,\n          value || this.context.undefined,\n        ),\n      )\n      .dispose()\n\n    this.disposeResolvers()\n    this.onSettled()\n  }\n\n  get alive() {\n    return this.handle.alive || this.resolveHandle.alive || this.rejectHandle.alive\n  }\n\n  dispose = () => {\n    if (this.handle.alive) {\n      this.handle.dispose()\n    }\n    this.disposeResolvers()\n  }\n\n  private disposeResolvers() {\n    if (this.resolveHandle.alive) {\n      this.resolveHandle.dispose()\n    }\n\n    if (this.rejectHandle.alive) {\n      this.rejectHandle.dispose()\n    }\n  }\n}\n","import type {\n  EitherModule,\n  OwnedHeapCharPointer,\n  JSContextPointerPointer,\n  JSValueConstPointerPointer,\n  JSValuePointerPointer,\n  JSVoidPointer,\n} from \"@jitl/quickjs-ffi-types\"\nimport { Lifetime } from \"./lifetime\"\nimport type { QuickJSHandle } from \"./types\"\n\n/**\n * @private\n */\ntype HeapUint8Array = {\n  pointer: JSVoidPointer\n  numBytes: number\n}\n\n/**\n * @private\n */\nexport class ModuleMemory {\n  constructor(public module: EitherModule) {}\n\n  toPointerArray(handleArray: QuickJSHandle[]): Lifetime<JSValueConstPointerPointer> {\n    const typedArray = new Int32Array(handleArray.map((handle) => handle.value))\n    const numBytes = typedArray.length * typedArray.BYTES_PER_ELEMENT\n    const ptr = this.module._malloc(numBytes) as JSValueConstPointerPointer\n    const heapBytes = new Uint8Array(this.module.HEAPU8.buffer, ptr, numBytes)\n    heapBytes.set(new Uint8Array(typedArray.buffer))\n    return new Lifetime(ptr, undefined, (ptr) => this.module._free(ptr))\n  }\n\n  newMutablePointerArray<T extends JSContextPointerPointer | JSValuePointerPointer>(\n    length: number,\n  ): Lifetime<{ typedArray: Int32Array; ptr: T }> {\n    const zeros = new Int32Array(new Array(length).fill(0))\n    const numBytes = zeros.length * zeros.BYTES_PER_ELEMENT\n    const ptr = this.module._malloc(numBytes) as T\n    const typedArray = new Int32Array(this.module.HEAPU8.buffer, ptr, length)\n    typedArray.set(zeros)\n    return new Lifetime({ typedArray, ptr }, undefined, (value) => this.module._free(value.ptr))\n  }\n\n  newHeapCharPointer(string: string): Lifetime<{ ptr: OwnedHeapCharPointer; strlen: number }> {\n    const strlen = this.module.lengthBytesUTF8(string)\n    const dataBytes = strlen + 1\n    const ptr: OwnedHeapCharPointer = this.module._malloc(dataBytes) as OwnedHeapCharPointer\n    this.module.stringToUTF8(string, ptr, dataBytes)\n    return new Lifetime({ ptr, strlen }, undefined, (value) => this.module._free(value.ptr))\n  }\n\n  newHeapBufferPointer(buffer: Uint8Array): Lifetime<HeapUint8Array> {\n    const numBytes = buffer.byteLength\n    const ptr: JSVoidPointer = this.module._malloc(numBytes) as JSVoidPointer\n    this.module.HEAPU8.set(buffer, ptr)\n    return new Lifetime({ pointer: ptr, numBytes }, undefined, (value) =>\n      this.module._free(value.pointer),\n    )\n  }\n\n  consumeHeapCharPointer(ptr: OwnedHeapCharPointer): string {\n    const str = this.module.UTF8ToString(ptr)\n    this.module._free(ptr)\n    return str\n  }\n}\n","import type { JSContextPointer, JSValueConstPointer, JSValuePointer } from \"@jitl/quickjs-ffi-types\"\nimport { EvalFlags, IntrinsicsFlags } from \"@jitl/quickjs-ffi-types\"\nimport type { QuickJSContext } from \"./context\"\nimport type { SuccessOrFail, VmFunctionImplementation } from \"./vm-interface\"\nimport type { Disposable, Lifetime } from \"./lifetime\"\nimport type { QuickJSAsyncContext } from \"./context-asyncify\"\nimport type { InterruptHandler, QuickJSRuntime } from \"./runtime\"\nimport { QuickJSUnknownIntrinsic } from \"./errors\"\n\n/**\n * A QuickJSHandle to a constant that will never change, and does not need to\n * be disposed.\n */\nexport type StaticJSValue = Lifetime<JSValueConstPointer, JSValueConstPointer, QuickJSRuntime>\n\n/**\n * A QuickJSHandle to a borrowed value that does not need to be disposed.\n *\n * In QuickJS, a JSValueConst is a \"borrowed\" reference that isn't owned by the\n * current scope. That means that the current scope should not `JS_FreeValue`\n * it, or retain a reference to it after the scope exits, because it may be\n * freed by its owner.\n *\n * quickjs-emscripten takes care of disposing JSValueConst references.\n */\nexport type JSValueConst = Lifetime<JSValueConstPointer, JSValuePointer, QuickJSRuntime>\n\n/**\n * A owned QuickJSHandle that should be disposed or returned.\n *\n * The QuickJS interpreter passes Javascript values between functions as\n * `JSValue` structs that references some internal data. Because passing\n * structs cross the Empscripten FFI interfaces is bothersome, we use pointers\n * to these structs instead.\n *\n * A JSValue reference is \"owned\" in its scope. before exiting the scope, it\n * should be freed,  by calling `JS_FreeValue(ctx, js_value)`) or returned from\n * the scope. We extend that contract - a JSValuePointer (`JSValue*`) must also\n * be `free`d.\n *\n * You can do so from Javascript by calling the .dispose() method.\n */\nexport type JSValue = Lifetime<JSValuePointer, JSValuePointer, QuickJSRuntime>\n\n/**\n * Wraps a C pointer to a QuickJS JSValue, which represents a Javascript value inside\n * a QuickJS virtual machine.\n *\n * Values must not be shared between QuickJSContext instances.\n * You must dispose of any handles you create by calling the `.dispose()` method.\n */\nexport type QuickJSHandle = StaticJSValue | JSValue | JSValueConst\n\nexport type JSModuleExport =\n  | {\n      type: \"function\"\n      name: string\n      implementation: (vm: QuickJSContext) => VmFunctionImplementation<QuickJSHandle>\n    }\n  | { type: \"value\"; name: string; value: (vm: QuickJSContext) => QuickJSHandle }\n\nexport interface JSModuleDefinition {\n  name: string\n  exports: JSModuleExport[]\n}\n\nexport type JSModuleLoadSuccess = string\nexport type JSModuleLoadFailure = Error | QuickJSHandle\nexport type JSModuleLoadResult =\n  | JSModuleLoadSuccess\n  | SuccessOrFail<JSModuleLoadSuccess, JSModuleLoadFailure>\n\nexport interface JSModuleLoaderAsync {\n  /** Load module (async) */\n  (\n    moduleName: string,\n    context: QuickJSAsyncContext,\n  ): JSModuleLoadResult | Promise<JSModuleLoadResult>\n}\nexport interface JSModuleLoader {\n  /** Load module (sync) */\n  (moduleName: string, context: QuickJSContext): JSModuleLoadResult\n}\n\nexport type JSModuleNormalizeSuccess = string\nexport type JSModuleNormalizeFailure = Error | QuickJSHandle\nexport type JSModuleNormalizeResult =\n  | JSModuleNormalizeSuccess\n  | SuccessOrFail<JSModuleNormalizeSuccess, JSModuleNormalizeFailure>\n\nexport interface JSModuleNormalizerAsync {\n  (\n    baseModuleName: string,\n    requestedName: string,\n    vm: QuickJSAsyncContext,\n  ): JSModuleNormalizeResult | Promise<JSModuleNormalizeResult>\n}\nexport interface JSModuleNormalizer extends JSModuleNormalizerAsync {\n  (baseModuleName: string, requestedName: string, vm: QuickJSContext): JSModuleNormalizeResult\n}\n\ntype TODO<hint extends string = \"?\", typeHint = unknown> = hint & typeHint & never\n\nconst UnstableSymbol = Symbol(\"Unstable\")\n\nexport type PartiallyImplemented<T> = never &\n  T & {\n    [UnstableSymbol]: \"This feature may unimplemented, broken, throw errors, etc.\"\n  }\n\nexport interface RuntimeOptionsBase {\n  interruptHandler?: InterruptHandler\n  maxStackSizeBytes?: number\n  memoryLimitBytes?: number\n\n  promiseRejectionHandler?: TODO<\"JSHostPromiseRejectionTracker\">\n  runtimeInfo?: TODO<\"JS_SetRuntimeInfo\", string>\n  gcThreshold?: TODO<\"JS_SetGCThreshold\", number>\n  sharedArrayBufferFunctions?: TODO<\n    \"JS_SetJSSharedArrayBufferFunctions\",\n    { sab_alloc: TODO; sab_free: TODO; sab_dup: TODO; sab_opaque: TODO }\n  >\n\n  /**\n   * Extra lifetimes the runtime should dispose of after it is destroyed.\n   * @private\n   */\n  ownedLifetimes?: Disposable[]\n}\n\nexport interface RuntimeOptions extends RuntimeOptionsBase {\n  moduleLoader?: JSModuleLoader\n}\n\nexport interface AsyncRuntimeOptions extends RuntimeOptionsBase {\n  moduleLoader?: JSModuleLoaderAsync | JSModuleLoader\n}\n\n// This guy could be declared as Partial<Record<keyof typeof IntrinsicsFlags, boolean>>,\n// but it leads to bad docs.\n/**\n * Language features that can be enabled or disabled in a QuickJSContext.\n * @see {@link ContextOptions}\n */\nexport type Intrinsics = {\n  BaseObjects?: boolean\n  Date?: boolean\n  Eval?: boolean\n  StringNormalize?: boolean\n  RegExp?: boolean\n  RegExpCompiler?: boolean\n  JSON?: boolean\n  Proxy?: boolean\n  MapSet?: boolean\n  TypedArrays?: boolean\n  Promise?: boolean\n  BigInt?: boolean\n  BigFloat?: boolean\n  BigDecimal?: boolean\n  OperatorOverloading?: boolean\n  BignumExt?: boolean\n}\n\ntype _Assert<T, U extends T> = U\ntype _intrinsicsHasKeysOfIntrinsicFlags = _Assert<keyof Intrinsics, keyof typeof IntrinsicsFlags>\ntype _intrinsicsHasKeysOfIntrinsicFlags2 = _Assert<keyof typeof IntrinsicsFlags, keyof Intrinsics>\n\n/**\n * The default {@link Intrinsics} language features enabled in a QuickJSContext.\n * @see {@link ContextOptions}\n */\nexport const DefaultIntrinsics = Object.freeze({\n  BaseObjects: true,\n  Date: true,\n  Eval: true,\n  StringNormalize: true,\n  RegExp: true,\n  JSON: true,\n  Proxy: true,\n  MapSet: true,\n  TypedArrays: true,\n  Promise: true,\n} as const satisfies Intrinsics)\n\n/**\n * @private\n */\nexport function intrinsicsToFlags(intrinsics: Intrinsics | undefined): IntrinsicsFlags {\n  if (!intrinsics) {\n    return 0 as IntrinsicsFlags\n  }\n\n  let result = 0\n  for (const [maybeIntrinsicName, enabled] of Object.entries(intrinsics)) {\n    if (!(maybeIntrinsicName in IntrinsicsFlags)) {\n      throw new QuickJSUnknownIntrinsic(maybeIntrinsicName)\n    }\n    const intrinsicName = maybeIntrinsicName as keyof typeof IntrinsicsFlags\n\n    if (enabled) {\n      result |= IntrinsicsFlags[intrinsicName]\n    }\n  }\n  return result as IntrinsicsFlags\n}\n\n/**\n * Options for creating a {@link QuickJSContext} or {@link QuickJSAsyncContext}\n * Pass to {@link QuickJSRuntime#newContext}.\n */\nexport interface ContextOptions {\n  /**\n   * What built-in objects and language features to enable?\n   * If unset, the default intrinsics will be used.\n   * To omit all intrinsics, pass an empty array.\n   *\n   * To remove a specific intrinsic, but retain the other defaults,\n   * override it from {@link DefaultIntrinsics}\n   * ```ts\n   * const contextWithoutDateOrEval = runtime.newContext({\n   *   intrinsics: {\n   *     ...DefaultIntrinsics,\n   *     Date: false,\n   *   }\n   * })\n   * ```\n   */\n  intrinsics?: Intrinsics\n\n  /**\n   * Wrap the provided context instead of constructing a new one.\n   * @private\n   */\n  contextPointer?: JSContextPointer\n\n  /**\n   * Extra lifetimes the context should dispose of after it is destroyed.\n   * @private\n   */\n  ownedLifetimes?: Disposable[]\n}\n\nexport interface ContextEvalOptions {\n  /**\n   * Global code (default), or \"module\" code?\n   *\n   * - When type is `\"global\"`, the code is evaluated in the global scope of the QuickJSContext, and the return value is the result of the last expression.\n   * - When type is `\"module\"`, the code is evaluated is a module scope, may use `import`, `export`, and top-level `await`. The return value is the module's exports, or a promise for the module's exports.\n   */\n  type?: \"global\" | \"module\"\n  /** Force \"strict\" mode */\n  strict?: boolean\n  /** Force \"strip\" mode */\n  strip?: boolean\n  /**\n   * compile but do not run. The result is an object with a\n   * JS_TAG_FUNCTION_BYTECODE or JS_TAG_MODULE tag. It can be executed\n   * with JS_EvalFunction().\n   */\n  compileOnly?: boolean\n  /** don't include the stack frames before this eval in the Error() backtraces */\n  backtraceBarrier?: boolean\n}\n\n/** Convert {@link ContextEvalOptions} to a bitfield flags */\nexport function evalOptionsToFlags(evalOptions: ContextEvalOptions | number | undefined): number {\n  if (typeof evalOptions === \"number\") {\n    return evalOptions\n  }\n\n  if (evalOptions === undefined) {\n    return 0\n  }\n\n  const { type, strict, strip, compileOnly, backtraceBarrier } = evalOptions\n  let flags = 0\n  if (type === \"global\") flags |= EvalFlags.JS_EVAL_TYPE_GLOBAL\n  if (type === \"module\") flags |= EvalFlags.JS_EVAL_TYPE_MODULE\n  if (strict) flags |= EvalFlags.JS_EVAL_FLAG_STRICT\n  if (strip) flags |= EvalFlags.JS_EVAL_FLAG_STRIP\n  if (compileOnly) flags |= EvalFlags.JS_EVAL_FLAG_COMPILE_ONLY\n  if (backtraceBarrier) flags |= EvalFlags.JS_EVAL_FLAG_BACKTRACE_BARRIER\n  return flags\n}\n\nexport type PromiseExecutor<ResolveT, RejectT> = (\n  resolve: (value: ResolveT | PromiseLike<ResolveT>) => void,\n  reject: (reason: RejectT) => void,\n) => void\n\nexport function concat<T>(...values: Array<T[] | T | undefined>): T[] {\n  let result: T[] = []\n  for (const value of values) {\n    if (value !== undefined) {\n      result = result.concat(value)\n    }\n  }\n  return result\n}\n","import type {\n  BorrowedHeapCharPointer,\n  JSContextPointer,\n  JSContextPointerPointer,\n  JSRuntimePointer,\n  EitherFFI,\n  EitherModule,\n} from \"@jitl/quickjs-ffi-types\"\nimport { maybeAsyncFn } from \"./asyncify-helpers\"\nimport { QuickJSContext } from \"./context\"\nimport { debugLog } from \"./debug\"\nimport { QuickJSWrongOwner } from \"./errors\"\nimport type { Disposable } from \"./lifetime\"\nimport { Lifetime, Scope, UsingDisposable } from \"./lifetime\"\nimport { ModuleMemory } from \"./memory\"\nimport type { QuickJSModuleCallbacks, RuntimeCallbacks } from \"./module\"\nimport type { ContextOptions, JSModuleLoader, JSModuleNormalizer, QuickJSHandle } from \"./types\"\nimport { intrinsicsToFlags } from \"./types\"\nimport type { SuccessOrFail } from \"./vm-interface\"\n\n/**\n * Callback called regularly while the VM executes code.\n * Determines if a VM's execution should be interrupted.\n *\n * @returns `true` to interrupt JS execution inside the VM.\n * @returns `false` or `undefined` to continue JS execution inside the VM.\n */\nexport type InterruptHandler = (runtime: QuickJSRuntime) => boolean | undefined\n\n/**\n * Used as an optional for the results of executing pendingJobs.\n * On success, `value` contains the number of async jobs executed\n * by the runtime.\n * @source\n */\nexport type ExecutePendingJobsResult = SuccessOrFail<\n  /** Number of jobs successfully executed. */\n  number,\n  /** The error that occurred. */\n  QuickJSHandle & {\n    /** The context where the error occurred. */\n    context: QuickJSContext\n  }\n>\n\n/**\n * A runtime represents a Javascript runtime corresponding to an object heap.\n * Several runtimes can exist at the same time but they cannot exchange objects.\n * Inside a given runtime, no multi-threading is supported.\n *\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain.\n *\n * Create a runtime via {@link QuickJSWASMModule.newRuntime}.\n *\n * You should create separate runtime instances for untrusted code from\n * different sources for isolation. However, stronger isolation is also\n * available (at the cost of memory usage), by creating separate WebAssembly\n * modules to further isolate untrusted code.\n * See {@link newQuickJSWASMModule}.\n *\n * Implement memory and CPU constraints with {@link setInterruptHandler}\n * (called regularly while the interpreter runs), {@link setMemoryLimit}, and\n * {@link setMaxStackSize}.\n * Use {@link computeMemoryUsage} or {@link dumpMemoryUsage} to guide memory limit\n * tuning.\n *\n * Configure ES module loading with {@link setModuleLoader}.\n */\nexport class QuickJSRuntime extends UsingDisposable implements Disposable {\n  /**\n   * If this runtime was created as as part of a context, points to the context\n   * associated with the runtime.\n   *\n   * If this runtime was created stand-alone, this may or may not contain a context.\n   * A context here may be allocated if one is needed by the runtime, eg for {@link computeMemoryUsage}.\n   */\n  public context: QuickJSContext | undefined\n\n  /** @private */\n  protected module: EitherModule\n  /** @private */\n  protected memory: ModuleMemory\n  /** @private */\n  protected ffi: EitherFFI\n  /** @private */\n  protected rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected callbacks: QuickJSModuleCallbacks\n  /** @private */\n  protected scope = new Scope()\n\n  /** @private */\n  protected contextMap = new Map<JSContextPointer, QuickJSContext>()\n  /** @private */\n  protected moduleLoader: JSModuleLoader | undefined\n  /** @private */\n  protected moduleNormalizer: JSModuleNormalizer | undefined\n\n  /** @private */\n  constructor(args: {\n    module: EitherModule\n    ffi: EitherFFI\n    rt: Lifetime<JSRuntimePointer>\n    callbacks: QuickJSModuleCallbacks\n    ownedLifetimes?: Disposable[]\n  }) {\n    super()\n    args.ownedLifetimes?.forEach((lifetime) => this.scope.manage(lifetime))\n    this.module = args.module\n    this.memory = new ModuleMemory(this.module)\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.callbacks = args.callbacks\n    this.scope.manage(this.rt)\n    this.callbacks.setRuntimeCallbacks(this.rt.value, this.cToHostCallbacks)\n\n    this.executePendingJobs = this.executePendingJobs.bind(this)\n  }\n\n  get alive() {\n    return this.scope.alive\n  }\n\n  dispose() {\n    return this.scope.dispose()\n  }\n\n  /**\n   * Create a new context within this runtime. Contexts have isolated globals,\n   * but you can explicitly share objects between contexts with the same\n   * runtime.\n   *\n   * You should dispose a created context before disposing this runtime.\n   */\n  newContext(options: ContextOptions = {}): QuickJSContext {\n    const intrinsics = intrinsicsToFlags(options.intrinsics)\n    const ctx = new Lifetime(\n      options.contextPointer || this.ffi.QTS_NewContext(this.rt.value, intrinsics),\n      undefined,\n      (ctx_ptr) => {\n        this.contextMap.delete(ctx_ptr)\n        this.callbacks.deleteContext(ctx_ptr)\n        this.ffi.QTS_FreeContext(ctx_ptr)\n      },\n    )\n\n    const context = new QuickJSContext({\n      module: this.module,\n      ctx,\n      ffi: this.ffi,\n      rt: this.rt,\n      ownedLifetimes: options.ownedLifetimes,\n      runtime: this,\n      callbacks: this.callbacks,\n    })\n    this.contextMap.set(ctx.value, context)\n\n    return context\n  }\n\n  /**\n   * Set the loader for EcmaScript modules requested by any context in this\n   * runtime.\n   *\n   * The loader can be removed with {@link removeModuleLoader}.\n   */\n  setModuleLoader(moduleLoader: JSModuleLoader, moduleNormalizer?: JSModuleNormalizer): void {\n    this.moduleLoader = moduleLoader\n    this.moduleNormalizer = moduleNormalizer\n    this.ffi.QTS_RuntimeEnableModuleLoader(this.rt.value, this.moduleNormalizer ? 1 : 0)\n  }\n\n  /**\n   * Remove the the loader set by {@link setModuleLoader}. This disables module loading.\n   */\n  removeModuleLoader(): void {\n    this.moduleLoader = undefined\n    this.ffi.QTS_RuntimeDisableModuleLoader(this.rt.value)\n  }\n\n  // Runtime management -------------------------------------------------------\n\n  /**\n   * In QuickJS, promises and async functions create pendingJobs. These do not execute\n   * immediately and need to be run by calling {@link executePendingJobs}.\n   *\n   * @return true if there is at least one pendingJob queued up.\n   */\n  hasPendingJob(): boolean {\n    return Boolean(this.ffi.QTS_IsJobPending(this.rt.value))\n  }\n\n  private interruptHandler: InterruptHandler | undefined\n\n  /**\n   * Set a callback which is regularly called by the QuickJS engine when it is\n   * executing code. This callback can be used to implement an execution\n   * timeout.\n   *\n   * The interrupt handler can be removed with {@link removeInterruptHandler}.\n   */\n  setInterruptHandler(cb: InterruptHandler) {\n    const prevInterruptHandler = this.interruptHandler\n    this.interruptHandler = cb\n    if (!prevInterruptHandler) {\n      this.ffi.QTS_RuntimeEnableInterruptHandler(this.rt.value)\n    }\n  }\n\n  /**\n   * Remove the interrupt handler, if any.\n   * See {@link setInterruptHandler}.\n   */\n  removeInterruptHandler() {\n    if (this.interruptHandler) {\n      this.ffi.QTS_RuntimeDisableInterruptHandler(this.rt.value)\n      this.interruptHandler = undefined\n    }\n  }\n\n  /**\n   * Execute pendingJobs on the runtime until `maxJobsToExecute` jobs are\n   * executed (default all pendingJobs), the queue is exhausted, or the runtime\n   * encounters an exception.\n   *\n   * In QuickJS, promises and async functions *inside the runtime* create\n   * pendingJobs. These do not execute immediately and need to triggered to run.\n   *\n   * @param maxJobsToExecute - When negative, run all pending jobs. Otherwise execute\n   * at most `maxJobsToExecute` before returning.\n   *\n   * @return On success, the number of executed jobs. On error, the exception\n   * that stopped execution, and the context it occurred in. Note that\n   * executePendingJobs will not normally return errors thrown inside async\n   * functions or rejected promises. Those errors are available by calling\n   * {@link QuickJSContext#resolvePromise} on the promise handle returned by the async function.\n   */\n  executePendingJobs(maxJobsToExecute: number | void = -1): ExecutePendingJobsResult {\n    const ctxPtrOut = this.memory.newMutablePointerArray<JSContextPointerPointer>(1)\n    const valuePtr = this.ffi.QTS_ExecutePendingJob(\n      this.rt.value,\n      maxJobsToExecute ?? -1,\n      ctxPtrOut.value.ptr,\n    )\n\n    const ctxPtr = ctxPtrOut.value.typedArray[0] as JSContextPointer\n    ctxPtrOut.dispose()\n    if (ctxPtr === 0) {\n      // No jobs executed.\n      this.ffi.QTS_FreeValuePointerRuntime(this.rt.value, valuePtr)\n      return { value: 0 }\n    }\n\n    const context =\n      this.contextMap.get(ctxPtr) ??\n      this.newContext({\n        contextPointer: ctxPtr,\n      })\n\n    const resultValue = context.getMemory(this.rt.value).heapValueHandle(valuePtr)\n    const typeOfRet = context.typeof(resultValue)\n    if (typeOfRet === \"number\") {\n      const executedJobs = context.getNumber(resultValue)\n      resultValue.dispose()\n      return { value: executedJobs }\n    } else {\n      const error = Object.assign(resultValue, { context })\n      return {\n        error,\n      }\n    }\n  }\n\n  /**\n   * Set the max memory this runtime can allocate.\n   * To remove the limit, set to `-1`.\n   */\n  setMemoryLimit(limitBytes: number) {\n    if (limitBytes < 0 && limitBytes !== -1) {\n      throw new Error(\"Cannot set memory limit to negative number. To unset, pass -1\")\n    }\n\n    this.ffi.QTS_RuntimeSetMemoryLimit(this.rt.value, limitBytes)\n  }\n\n  /**\n   * Compute memory usage for this runtime. Returns the result as a handle to a\n   * JSValue object. Use {@link QuickJSContext#dump} to convert to a native object.\n   * Calling this method will allocate more memory inside the runtime. The information\n   * is accurate as of just before the call to `computeMemoryUsage`.\n   * For a human-digestible representation, see {@link dumpMemoryUsage}.\n   */\n  computeMemoryUsage(): QuickJSHandle {\n    const serviceContextMemory = this.getSystemContext().getMemory(this.rt.value)\n    return serviceContextMemory.heapValueHandle(\n      this.ffi.QTS_RuntimeComputeMemoryUsage(this.rt.value, serviceContextMemory.ctx.value),\n    )\n  }\n\n  /**\n   * @returns a human-readable description of memory usage in this runtime.\n   * For programmatic access to this information, see {@link computeMemoryUsage}.\n   */\n  dumpMemoryUsage(): string {\n    return this.memory.consumeHeapCharPointer(this.ffi.QTS_RuntimeDumpMemoryUsage(this.rt.value))\n  }\n\n  /**\n   * Set the max stack size for this runtime, in bytes.\n   * To remove the limit, set to `0`.\n   */\n  setMaxStackSize(stackSize: number) {\n    if (stackSize < 0) {\n      throw new Error(\"Cannot set memory limit to negative number. To unset, pass 0.\")\n    }\n\n    this.ffi.QTS_RuntimeSetMaxStackSize(this.rt.value, stackSize)\n  }\n\n  /**\n   * Assert that `handle` is owned by this runtime.\n   * @throws QuickJSWrongOwner if owned by a different runtime.\n   */\n  assertOwned(handle: QuickJSHandle) {\n    if (handle.owner && handle.owner.rt !== this.rt) {\n      throw new QuickJSWrongOwner(\n        `Handle is not owned by this runtime: ${handle.owner.rt.value} != ${this.rt.value}`,\n      )\n    }\n  }\n\n  private getSystemContext() {\n    if (!this.context) {\n      // We own this context and should dispose of it.\n      this.context = this.scope.manage(this.newContext())\n    }\n    return this.context\n  }\n\n  private cToHostCallbacks: RuntimeCallbacks = {\n    shouldInterrupt: (rt) => {\n      if (rt !== this.rt.value) {\n        throw new Error(\"QuickJSContext instance received C -> JS interrupt with mismatched rt\")\n      }\n\n      const fn = this.interruptHandler\n      if (!fn) {\n        throw new Error(\"QuickJSContext had no interrupt handler\")\n      }\n\n      return fn(this) ? 1 : 0\n    },\n\n    loadModuleSource: maybeAsyncFn(this, function* (awaited, rt, ctx, moduleName) {\n      const moduleLoader = this.moduleLoader\n      if (!moduleLoader) {\n        throw new Error(\"Runtime has no module loader\")\n      }\n\n      if (rt !== this.rt.value) {\n        throw new Error(\"Runtime pointer mismatch\")\n      }\n\n      const context =\n        this.contextMap.get(ctx) ??\n        this.newContext({\n          contextPointer: ctx,\n        })\n\n      try {\n        const result = yield* awaited(moduleLoader(moduleName, context))\n\n        if (typeof result === \"object\" && \"error\" in result && result.error) {\n          debugLog(\"cToHostLoadModule: loader returned error\", result.error)\n          throw result.error\n        }\n\n        const moduleSource =\n          typeof result === \"string\" ? result : \"value\" in result ? result.value : result\n\n        return this.memory.newHeapCharPointer(moduleSource).value.ptr\n      } catch (error) {\n        debugLog(\"cToHostLoadModule: caught error\", error)\n        context.throw(error as any)\n        return 0 as BorrowedHeapCharPointer\n      }\n    }),\n\n    normalizeModule: maybeAsyncFn(\n      this,\n      function* (awaited, rt, ctx, baseModuleName, moduleNameRequest) {\n        const moduleNormalizer = this.moduleNormalizer\n        if (!moduleNormalizer) {\n          throw new Error(\"Runtime has no module normalizer\")\n        }\n\n        if (rt !== this.rt.value) {\n          throw new Error(\"Runtime pointer mismatch\")\n        }\n\n        const context: QuickJSContext =\n          this.contextMap.get(ctx) ??\n          this.newContext({\n            /* TODO: Does this happen? Are we responsible for disposing? I don't think so */\n            contextPointer: ctx,\n          })\n\n        try {\n          const result = yield* awaited(\n            moduleNormalizer(baseModuleName, moduleNameRequest, context),\n          )\n\n          if (typeof result === \"object\" && \"error\" in result && result.error) {\n            debugLog(\"cToHostNormalizeModule: normalizer returned error\", result.error)\n            throw result.error\n          }\n\n          const name = typeof result === \"string\" ? result : result.value\n          return context.getMemory(this.rt.value).newHeapCharPointer(name).value.ptr\n        } catch (error) {\n          debugLog(\"normalizeModule: caught error\", error)\n          context.throw(error as any)\n          return 0 as BorrowedHeapCharPointer\n        }\n      },\n    ),\n  }\n}\n","import type {\n  Asyncify,\n  AsyncifySleepResult,\n  EitherModule,\n  EmscriptenModuleCallbacks,\n  BorrowedHeapCharPointer,\n  JSContextPointer,\n  JSRuntimePointer,\n  JSValuePointer,\n  EitherFFI,\n} from \"@jitl/quickjs-ffi-types\"\nimport type { QuickJSContext } from \"./context\"\nimport { debugLog } from \"./debug\"\nimport { QuickJSAsyncifyError, QuickJSAsyncifySuspended } from \"./errors\"\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { CustomizeVariantOptions } from \"./from-variant\"\nimport { Lifetime, Scope } from \"./lifetime\"\nimport type { InterruptHandler } from \"./runtime\"\nimport { QuickJSRuntime } from \"./runtime\"\nimport type { ContextOptions, JSModuleLoader, RuntimeOptions, RuntimeOptionsBase } from \"./types\"\nimport { concat } from \"./types\"\n\ntype EmscriptenCallback<BaseArgs extends any[], Result> = (\n  ...args: [Asyncify | undefined, ...BaseArgs]\n) => Result | AsyncifySleepResult<Result>\ntype MaybeAsyncEmscriptenCallback<T extends EmscriptenCallback<any, any>> =\n  T extends EmscriptenCallback<infer Args, infer Result>\n    ? (...args: Args) => Result | Promise<Result>\n    : never\ntype MaybeAsyncEmscriptenCallbacks = {\n  [K in keyof EmscriptenModuleCallbacks]: MaybeAsyncEmscriptenCallback<EmscriptenModuleCallbacks[K]>\n}\n\n/**\n * @private\n */\nexport interface ContextCallbacks {\n  callFunction: MaybeAsyncEmscriptenCallbacks[\"callFunction\"]\n}\n\n/**\n * @private\n */\nexport interface RuntimeCallbacks {\n  shouldInterrupt: MaybeAsyncEmscriptenCallbacks[\"shouldInterrupt\"]\n  loadModuleSource: MaybeAsyncEmscriptenCallbacks[\"loadModuleSource\"]\n  normalizeModule: MaybeAsyncEmscriptenCallbacks[\"normalizeModule\"]\n}\n\nclass QuickJSEmscriptenModuleCallbacks implements EmscriptenModuleCallbacks {\n  public callFunction: EmscriptenModuleCallbacks[\"callFunction\"]\n  public shouldInterrupt: EmscriptenModuleCallbacks[\"shouldInterrupt\"]\n  public loadModuleSource: EmscriptenModuleCallbacks[\"loadModuleSource\"]\n  public normalizeModule: EmscriptenModuleCallbacks[\"normalizeModule\"]\n  constructor(args: EmscriptenModuleCallbacks) {\n    this.callFunction = args.callFunction\n    this.shouldInterrupt = args.shouldInterrupt\n    this.loadModuleSource = args.loadModuleSource\n    this.normalizeModule = args.normalizeModule\n  }\n}\n\n/**\n * Options for {@link QuickJSWASMModule#evalCode}.\n */\nexport interface ModuleEvalOptions {\n  /**\n   * Interrupt evaluation if `shouldInterrupt` returns `true`.\n   * See {@link shouldInterruptAfterDeadline}.\n   */\n  shouldInterrupt?: InterruptHandler\n\n  /**\n   * Memory limit, in bytes, of WebAssembly heap memory used by the QuickJS VM.\n   */\n  memoryLimitBytes?: number\n\n  /**\n   * Stack size limit for this vm, in bytes\n   * To remove the limit, set to `0`.\n   */\n  maxStackSizeBytes?: number\n\n  /**\n   * Module loader for any `import` statements or expressions.\n   */\n  moduleLoader?: JSModuleLoader\n}\n\n/**\n * We use static functions per module to dispatch runtime or context calls from\n * C to the host.  This class manages the indirection from a specific runtime or\n * context pointer to the appropriate callback handler.\n *\n * @private\n */\nexport class QuickJSModuleCallbacks {\n  private module: EitherModule\n  private contextCallbacks = new Map<JSContextPointer, ContextCallbacks>()\n  private runtimeCallbacks = new Map<JSRuntimePointer, RuntimeCallbacks>()\n\n  constructor(module: EitherModule) {\n    this.module = module\n    this.module.callbacks = this.cToHostCallbacks\n  }\n\n  setRuntimeCallbacks(rt: JSRuntimePointer, callbacks: RuntimeCallbacks) {\n    this.runtimeCallbacks.set(rt, callbacks)\n  }\n\n  deleteRuntime(rt: JSRuntimePointer) {\n    this.runtimeCallbacks.delete(rt)\n  }\n\n  setContextCallbacks(ctx: JSContextPointer, callbacks: ContextCallbacks) {\n    this.contextCallbacks.set(ctx, callbacks)\n  }\n\n  deleteContext(ctx: JSContextPointer) {\n    this.contextCallbacks.delete(ctx)\n  }\n\n  private suspendedCount = 0\n  private suspended: QuickJSAsyncifySuspended | undefined\n\n  private handleAsyncify<T>(\n    asyncify: Asyncify | undefined,\n    fn: () => T | Promise<T>,\n  ): T | AsyncifySleepResult<T> {\n    if (asyncify) {\n      // We must always call asyncify.handleSync around our function.\n      // This allows asyncify to resume suspended execution on the second call.\n      // Asyncify internally can detect sync behavior, and avoid suspending.\n      return asyncify.handleSleep((done) => {\n        try {\n          const result = fn()\n          if (!(result instanceof Promise)) {\n            debugLog(\"asyncify.handleSleep: not suspending:\", result)\n            done(result)\n            return\n          }\n\n          // Is promise, we intend to suspend.\n          if (this.suspended) {\n            throw new QuickJSAsyncifyError(\n              `Already suspended at: ${this.suspended.stack}\\nAttempted to suspend at:`,\n            )\n          } else {\n            this.suspended = new QuickJSAsyncifySuspended(`(${this.suspendedCount++})`)\n            debugLog(\"asyncify.handleSleep: suspending:\", this.suspended)\n          }\n\n          result.then(\n            (resolvedResult) => {\n              this.suspended = undefined\n              debugLog(\"asyncify.handleSleep: resolved:\", resolvedResult)\n              done(resolvedResult)\n            },\n            (error) => {\n              debugLog(\"asyncify.handleSleep: rejected:\", error)\n              console.error(\"QuickJS: cannot handle error in suspended function\", error)\n              this.suspended = undefined\n            },\n          )\n        } catch (error) {\n          debugLog(\"asyncify.handleSleep: error:\", error)\n          this.suspended = undefined\n          throw error\n        }\n      })\n    }\n\n    // No asyncify - we should never return a promise.\n    const value = fn()\n    if (value instanceof Promise) {\n      throw new Error(\"Promise return value not supported in non-asyncify context.\")\n    }\n    return value\n  }\n\n  private cToHostCallbacks = new QuickJSEmscriptenModuleCallbacks({\n    callFunction: (asyncify, ctx, this_ptr, argc, argv, fn_id) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const vm = this.contextCallbacks.get(ctx)\n          if (!vm) {\n            throw new Error(`QuickJSContext(ctx = ${ctx}) not found for C function call \"${fn_id}\"`)\n          }\n          return vm.callFunction(ctx, this_ptr, argc, argv, fn_id)\n        } catch (error) {\n          console.error(\"[C to host error: returning null]\", error)\n          return 0 as JSValuePointer\n        }\n      }),\n\n    shouldInterrupt: (asyncify, rt) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const vm = this.runtimeCallbacks.get(rt)\n          if (!vm) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C interrupt`)\n          }\n          return vm.shouldInterrupt(rt)\n        } catch (error) {\n          console.error(\"[C to host interrupt: returning error]\", error)\n          return 1\n        }\n      }),\n\n    loadModuleSource: (asyncify, rt, ctx, moduleName) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const runtimeCallbacks = this.runtimeCallbacks.get(rt)\n          if (!runtimeCallbacks) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`)\n          }\n\n          const loadModule = runtimeCallbacks.loadModuleSource\n          if (!loadModule) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`)\n          }\n          return loadModule(rt, ctx, moduleName)\n        } catch (error) {\n          console.error(\"[C to host module loader error: returning null]\", error)\n          return 0 as BorrowedHeapCharPointer\n        }\n      }),\n\n    normalizeModule: (asyncify, rt, ctx, moduleBaseName, moduleName) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const runtimeCallbacks = this.runtimeCallbacks.get(rt)\n          if (!runtimeCallbacks) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`)\n          }\n\n          const normalizeModule = runtimeCallbacks.normalizeModule\n          if (!normalizeModule) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`)\n          }\n          return normalizeModule(rt, ctx, moduleBaseName, moduleName)\n        } catch (error) {\n          console.error(\"[C to host module loader error: returning null]\", error)\n          return 0 as BorrowedHeapCharPointer\n        }\n      }),\n  })\n}\n\n/**\n * Process RuntimeOptions and apply them to a QuickJSRuntime.\n * @private\n */\nexport function applyBaseRuntimeOptions(\n  runtime: QuickJSRuntime,\n  options: RuntimeOptionsBase,\n): void {\n  if (options.interruptHandler) {\n    runtime.setInterruptHandler(options.interruptHandler)\n  }\n\n  if (options.maxStackSizeBytes !== undefined) {\n    runtime.setMaxStackSize(options.maxStackSizeBytes)\n  }\n\n  if (options.memoryLimitBytes !== undefined) {\n    runtime.setMemoryLimit(options.memoryLimitBytes)\n  }\n}\n\n/**\n * Process ModuleEvalOptions and apply them to a QuickJSRuntime.\n * @private\n */\nexport function applyModuleEvalRuntimeOptions<T extends QuickJSRuntime>(\n  runtime: T,\n  options: ModuleEvalOptions,\n) {\n  if (options.moduleLoader) {\n    runtime.setModuleLoader(options.moduleLoader)\n  }\n\n  if (options.shouldInterrupt) {\n    runtime.setInterruptHandler(options.shouldInterrupt)\n  }\n\n  if (options.memoryLimitBytes !== undefined) {\n    runtime.setMemoryLimit(options.memoryLimitBytes)\n  }\n\n  if (options.maxStackSizeBytes !== undefined) {\n    runtime.setMaxStackSize(options.maxStackSizeBytes)\n  }\n}\n\n/**\n * This class presents a Javascript interface to QuickJS, a Javascript interpreter\n * that supports EcmaScript 2020 (ES2020).\n *\n * It wraps a single WebAssembly module containing the QuickJS library and\n * associated helper C code. WebAssembly modules are completely isolated from\n * each other by the host's WebAssembly runtime. Separate WebAssembly modules\n * have the most isolation guarantees possible with this library.\n *\n * The simplest way to start running code is {@link evalCode}. This shortcut\n * method will evaluate Javascript safely and return the result as a native\n * Javascript value.\n *\n * For more control over the execution environment, or to interact with values\n * inside QuickJS, create a context with {@link newContext} or a runtime with\n * {@link newRuntime}.\n */\nexport class QuickJSWASMModule {\n  /** @private */\n  protected ffi: EitherFFI\n  /** @private */\n  protected callbacks: QuickJSModuleCallbacks\n  /** @private */\n  protected module: EitherModule\n\n  /** @private */\n  constructor(module: EitherModule, ffi: EitherFFI) {\n    this.module = module\n    this.ffi = ffi\n    this.callbacks = new QuickJSModuleCallbacks(module)\n  }\n\n  /**\n   * Create a runtime.\n   * Use the runtime to set limits on CPU and memory usage and configure module\n   * loading for one or more {@link QuickJSContext}s inside the runtime.\n   */\n  newRuntime(options: RuntimeOptions = {}): QuickJSRuntime {\n    const rt = new Lifetime(this.ffi.QTS_NewRuntime(), undefined, (rt_ptr) => {\n      this.callbacks.deleteRuntime(rt_ptr)\n      this.ffi.QTS_FreeRuntime(rt_ptr)\n    })\n\n    const runtime = new QuickJSRuntime({\n      module: this.module,\n      callbacks: this.callbacks,\n      ffi: this.ffi,\n      rt,\n    })\n\n    applyBaseRuntimeOptions(runtime, options)\n\n    if (options.moduleLoader) {\n      runtime.setModuleLoader(options.moduleLoader)\n    }\n\n    return runtime\n  }\n\n  /**\n   * A simplified API to create a new {@link QuickJSRuntime} and a\n   * {@link QuickJSContext} inside that runtime at the same time. The runtime will\n   * be disposed when the context is disposed.\n   */\n  newContext(options: ContextOptions = {}): QuickJSContext {\n    const runtime = this.newRuntime()\n    const context = runtime.newContext({\n      ...options,\n      ownedLifetimes: concat(runtime, options.ownedLifetimes),\n    })\n    runtime.context = context\n    return context\n  }\n\n  /**\n   * One-off evaluate code without needing to create a {@link QuickJSRuntime} or\n   * {@link QuickJSContext} explicitly.\n   *\n   * To protect against infinite loops, use the `shouldInterrupt` option. The\n   * {@link shouldInterruptAfterDeadline} function will create a time-based deadline.\n   *\n   * If you need more control over how the code executes, create a\n   * {@link QuickJSRuntime} (with {@link newRuntime}) or a {@link QuickJSContext} (with\n   * {@link newContext} or {@link QuickJSRuntime#newContext}), and use its\n   * {@link QuickJSContext#evalCode} method.\n   *\n   * Asynchronous callbacks may not run during the first call to `evalCode`. If\n   * you need to work with async code inside QuickJS, create a runtime and use\n   * {@link QuickJSRuntime#executePendingJobs}.\n   *\n   * @returns The result is coerced to a native Javascript value using JSON\n   * serialization, so properties and values unsupported by JSON will be dropped.\n   *\n   * @throws If `code` throws during evaluation, the exception will be\n   * converted into a native Javascript value and thrown.\n   *\n   * @throws if `options.shouldInterrupt` interrupted execution, will throw a Error\n   * with name `\"InternalError\"` and  message `\"interrupted\"`.\n   */\n  evalCode(code: string, options: ModuleEvalOptions = {}): unknown {\n    return Scope.withScope((scope) => {\n      const vm = scope.manage(this.newContext())\n\n      applyModuleEvalRuntimeOptions(vm.runtime, options)\n      const result = vm.evalCode(code, \"eval.js\")\n\n      if (options.memoryLimitBytes !== undefined) {\n        // Remove memory limit so we can dump the result without exceeding it.\n        vm.runtime.setMemoryLimit(-1)\n      }\n\n      if (result.error) {\n        const error = vm.dump(scope.manage(result.error))\n        throw error\n      }\n\n      const value = vm.dump(scope.manage(result.value))\n      return value\n    })\n  }\n\n  /**\n   * Retrieve the WebAssembly memory used by this QuickJS module.\n   * Use this access very carefully - you are responsible for safe interaction with the memory.\n   *\n   * To supply a custom, pre-initialized memory to QuickJS, create a new variant\n   * and provide the {@link CustomizeVariantOptions#wasmMemory} option.\n   *\n   * @experimental\n   */\n  getWasmMemory(): WebAssembly.Memory {\n    const extensions = this.module.quickjsEmscriptenInit?.(() => {})\n    const memory = extensions?.getWasmMemory?.()\n    if (!memory) {\n      throw new Error(`Variant does not support getting WebAssembly.Memory`)\n    }\n    return memory\n  }\n\n  /**\n   * Get a low-level interface to the QuickJS functions in this WebAssembly\n   * module.\n   * @experimental\n   * @unstable No warranty is provided with this API. It could change at any time.\n   * @private\n   */\n  getFFI(): EitherFFI {\n    return this.ffi\n  }\n}\n"],"mappings":"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","names":["QTS_DEBUG","debugLog","args","QTS_DEBUG","errors_exports","__export","QuickJSAsyncifyError","QuickJSAsyncifySuspended","QuickJSEmscriptenModuleError","QuickJSMemoryLeakDetected","QuickJSNotImplemented","QuickJSPromisePending","QuickJSUnknownIntrinsic","QuickJSUnwrapError","QuickJSUseAfterFree","QuickJSWrongOwner","cause","context","awaitYield","value","awaitYieldOf","generator","awaitEachYieldedPromise","AwaitYield","maybeAsyncFn","that","fn","args","maybeAsync","startGenerator","gen","handleNextStep","step","error","UsingDisposable","SymbolDispose","prototypeAsAny","Lifetime","_Lifetime","_value","copier","disposer","_owner","QTS_DEBUG","map","result","QuickJSUseAfterFree","StaticLifetime","value","owner","WeakLifetime","scopeFinally","scope","blockError","disposeError","error","Scope","_Scope","block","_this","maybeAsync","awaited","lifetime","lifetimes","JSPromiseStateEnum","QuickJSDeferredPromise","UsingDisposable","args","value","resolve","ModuleMemory","module","handleArray","typedArray","handle","numBytes","ptr","Lifetime","length","zeros","value","string","strlen","dataBytes","buffer","str","EvalFlags","IntrinsicsFlags","UnstableSymbol","DefaultIntrinsics","intrinsicsToFlags","intrinsics","result","maybeIntrinsicName","enabled","IntrinsicsFlags","QuickJSUnknownIntrinsic","evalOptionsToFlags","evalOptions","type","strict","strip","compileOnly","backtraceBarrier","flags","EvalFlags","concat","values","value","ContextMemory","ModuleMemory","args","Scope","ptr","lifetime","str","Lifetime","QuickJSContext","UsingDisposable","ctx","this_ptr","argc","argv","fn_id","fn","awaited","scope","thisHandle","WeakLifetime","argHandles","i","result","debugLog","handle","error","errorHandle","StaticLifetime","num","charHandle","description","key","bigIntHandle","asString","prototype","buffer","array","value","deferredPromise","mutablePointerArray","promisePtr","promiseHandle","resolveHandle","rejectHandle","jsvaluePtr","QuickJSDeferredPromise","name","fnId","len","state","JSPromiseStateEnum","QuickJSPromisePending","promiseLikeHandle","vmResolveResult","vmPromise","vmPromiseResolve","resolve","promiseThenHandle","quickJSKey","descriptor","configurable","enumerable","hasValue","get","set","func","thisVal","resultPtr","argsArrayPtr","errorPtr","code","filename","options","detectModule","flags","evalOptionsToFlags","rt","type","asPromiseState","context","cause","message","stack","exception","QuickJSUnwrapError","hostStack","map_id","fnMap","QuickJSRuntime","UsingDisposable","args","Scope","rt","fn","maybeAsyncFn","awaited","ctx","moduleName","moduleLoader","context","result","debugLog","moduleSource","error","baseModuleName","moduleNameRequest","moduleNormalizer","name","lifetime","ModuleMemory","options","intrinsics","intrinsicsToFlags","Lifetime","ctx_ptr","QuickJSContext","cb","prevInterruptHandler","maxJobsToExecute","ctxPtrOut","valuePtr","ctxPtr","resultValue","executedJobs","limitBytes","serviceContextMemory","stackSize","handle","QuickJSWrongOwner","QuickJSEmscriptenModuleCallbacks","args","QuickJSModuleCallbacks","module","asyncify","ctx","this_ptr","argc","argv","fn_id","vm","error","rt","moduleName","runtimeCallbacks","loadModule","moduleBaseName","normalizeModule","callbacks","fn","done","result","debugLog","QuickJSAsyncifyError","QuickJSAsyncifySuspended","resolvedResult","value","applyBaseRuntimeOptions","runtime","options","applyModuleEvalRuntimeOptions","QuickJSWASMModule","ffi","Lifetime","rt_ptr","QuickJSRuntime","context","concat","code","Scope","scope","memory"]}