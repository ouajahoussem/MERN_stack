{"version":3,"sources":["../src/index.ts","../src/from-variant.ts","../src/vm-interface.ts","../src/interrupt-helpers.ts","../src/module-test.ts"],"sourcesContent":["export * from \"@jitl/quickjs-ffi-types\"\n\n// Sync classes\nexport { QuickJSWASMModule } from \"./module\"\nexport { QuickJSContext } from \"./context\"\nexport { QuickJSRuntime, InterruptHandler, ExecutePendingJobsResult } from \"./runtime\"\n\n// Async classes\nexport { QuickJSAsyncWASMModule } from \"./module-asyncify\"\nexport { QuickJSAsyncRuntime } from \"./runtime-asyncify\"\nexport { QuickJSAsyncContext, AsyncFunctionImplementation } from \"./context-asyncify\"\n\n// Build variants\nexport * from \"./from-variant\"\n\n// Export helpers\nexport * from \"./vm-interface\"\nexport * from \"./lifetime\"\nexport * from \"./interrupt-helpers\"\n/** Collects the informative errors this library may throw. */\nexport * as errors from \"./errors\"\nexport * from \"./deferred-promise\"\nexport * from \"./module-test\"\nexport type {\n  StaticJSValue,\n  JSValueConst,\n  JSValue,\n  QuickJSHandle,\n  ContextOptions,\n  ContextEvalOptions,\n  RuntimeOptions,\n  AsyncRuntimeOptions,\n  RuntimeOptionsBase,\n  JSModuleLoader,\n  JSModuleLoadResult,\n  JSModuleLoaderAsync,\n  JSModuleLoadSuccess,\n  JSModuleLoadFailure,\n  JSModuleNormalizer,\n  JSModuleNormalizerAsync,\n  JSModuleNormalizeResult,\n  JSModuleNormalizeFailure,\n  JSModuleNormalizeSuccess,\n  Intrinsics,\n} from \"./types\"\nexport { DefaultIntrinsics } from \"./types\"\nexport type { ModuleEvalOptions } from \"./module\"\nexport { QuickJSPropertyKey } from \"./context\"\nexport { debugLog } from \"./debug\"\n","import type {\n  QuickJSSyncVariant,\n  QuickJSAsyncVariant,\n  QuickJSVariant,\n  EmscriptenModuleLoaderOptions,\n  SourceMapData,\n  QuickJSEmscriptenExtensions,\n} from \"@jitl/quickjs-ffi-types\"\nimport type { QuickJSWASMModule } from \"./module.js\"\nimport type { QuickJSAsyncWASMModule } from \"./module-asyncify.js\"\nimport { QuickJSEmscriptenModuleError } from \"./errors.js\"\nimport { debugLog } from \"./debug.js\"\n\n// Otherwise we have build errors?\nexport { QuickJSSyncVariant, QuickJSAsyncVariant, QuickJSVariant }\n\nexport type PromisedDefault<T> =\n  | T\n  | Promise<T>\n  | Promise<{ default: T }>\n  | Promise<{ default: { default: T } }>\n\n/**\n * Create a new, completely isolated WebAssembly module containing the QuickJS library.\n * See the documentation on {@link QuickJSWASMModule}.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n *\n * @example\n * ```ts\n * const quickjs = new newQuickJSWASMModuleFromVariant(\n *   import('@jitl/quickjs-browser-release-sync-wasm')\n * )\n * ```\n */\nexport async function newQuickJSWASMModuleFromVariant(\n  /**\n   * A {@link QuickJSSyncVariant} to construct the WebAssembly module.\n   */\n  variantOrPromise: PromisedDefault<QuickJSSyncVariant>,\n): Promise<QuickJSWASMModule> {\n  const variant = smartUnwrap(await variantOrPromise)\n  const [wasmModuleLoader, QuickJSFFI, { QuickJSWASMModule }] = await Promise.all([\n    variant.importModuleLoader().then(smartUnwrap),\n    variant.importFFI(),\n    import(\"./module.js\").then(smartUnwrap),\n  ])\n  const wasmModule = await wasmModuleLoader()\n  wasmModule.type = \"sync\"\n  const ffi = new QuickJSFFI(wasmModule)\n  return new QuickJSWASMModule(wasmModule, ffi)\n}\n\n/**\n * Create a new, completely isolated WebAssembly module containing a version of the QuickJS library\n * compiled with Emscripten's [ASYNCIFY](https://emscripten.org/docs/porting/asyncify.html) transform.\n *\n * This version of the library offers features that enable synchronous code\n * inside the VM to interact with asynchronous code in the host environment.\n * See the documentation on {@link QuickJSAsyncWASMModule}, {@link QuickJSAsyncRuntime},\n * and {@link QuickJSAsyncContext}.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n *\n * @example\n * ```ts\n * const quickjs = new newQuickJSAsyncWASMModuleFromVariant(\n *   import('@jitl/quickjs-browser-debug-asyncify-wasm')\n * )\n * ```\n */\nexport async function newQuickJSAsyncWASMModuleFromVariant(\n  /**\n   * A {@link QuickJSAsyncVariant} to construct the WebAssembly module.\n   */\n  variantOrPromise: PromisedDefault<QuickJSAsyncVariant>,\n): Promise<QuickJSAsyncWASMModule> {\n  const variant = smartUnwrap(await variantOrPromise)\n  const [wasmModuleLoader, QuickJSAsyncFFI, { QuickJSAsyncWASMModule }] = await Promise.all([\n    variant.importModuleLoader().then(smartUnwrap),\n    variant.importFFI(),\n    import(\"./module-asyncify.js\").then(smartUnwrap),\n  ])\n  const wasmModule = await wasmModuleLoader()\n  wasmModule.type = \"async\"\n  const ffi = new QuickJSAsyncFFI(wasmModule)\n  return new QuickJSAsyncWASMModule(wasmModule, ffi)\n}\n\n/**\n * Helper intended to memoize the creation of a WebAssembly module.\n * ```typescript\n * const getDebugModule = memoizePromiseFactory(() => newQuickJSWASMModule(DEBUG_SYNC))\n * ```\n */\nexport function memoizePromiseFactory<T>(fn: () => Promise<T>): () => Promise<T> {\n  let promise: Promise<T> | undefined\n  return () => {\n    return (promise ??= fn())\n  }\n}\n\nfunction smartUnwrap<T extends object>(val: T | { default: T } | { default: { default: T } }): T {\n  if (val && `default` in val && val.default) {\n    if (val.default && `default` in val.default && val.default.default) {\n      return val.default.default\n    }\n    return val.default as T\n  }\n  return val as T\n}\n\nexport type OrLoader<T> = T | (() => Promise<T>)\n\nexport interface CustomizeVariantOptions {\n  /** If given, Emscripten will try to load the WebAssembly module data from this location (path or URI) as appropriate for the current platform. */\n  wasmLocation?: string\n  /** If given, Emscripten will compile the WebAssembly.Module from these bytes. */\n  wasmBinary?: OrLoader<ArrayBuffer>\n  /** If given, Emscripten will instantiate the WebAssembly.Instance from this existing WebAssembly.Module */\n  wasmModule?: OrLoader<WebAssembly.Module>\n  /** If given, use the Memory when instantiating the WebAssembly.Instance. */\n  wasmMemory?: OrLoader<WebAssembly.Memory>\n  /** If given, Emscripten will try to load the source map for the WebAssembly module from this location (path or URI) as appropriate for the current platform. */\n  wasmSourceMapLocation?: string\n  /** If given, we will provide the source map to Emscripten directly. This may only be respected if wasmModule is also provided. */\n  wasmSourceMapData?: OrLoader<string | SourceMapData>\n  /**\n   * If set, this method will be called when the runtime needs to load a file,\n   * such as a .wasm WebAssembly file, .mem memory init file, or a file\n   * generated by the file packager.\n   *\n   * The function receives two parameters:\n   *\n   * - `fileName`, the relative path to the file as configured in build\n   * process, eg `\"emscripten-module.wasm\"`.\n   * - `prefix` (path to the main JavaScript fileâ€™s directory). This may be `''`\n   * (empty string) in some cases if the Emscripten Javascript code can't locate\n   * itself. Try logging it in your environment.\n   *\n   * It should return the actual URI or path to the requested file.\n   *\n   * This lets you host file packages on a different location than the directory\n   * of the JavaScript file (which is the default expectation), for example if\n   * you want to host them on a CDN.\n   */\n  locateFile?: EmscriptenModuleLoaderOptions[\"locateFile\"]\n  /** The enumerable properties of this object will be passed verbatim, although they may be overwritten if you pass other options. */\n  emscriptenModule?: EmscriptenModuleLoaderOptions\n  /** Debug logger */\n  log?: typeof console.log\n}\n\n/**\n * Create a new variant by overriding how Emscripten obtains the WebAssembly module.\n * This may be necessary in Cloudflare Workers, which can't compile WebAssembly modules from binary data.\n */\nexport function newVariant<T extends QuickJSVariant>(\n  baseVariant: T,\n  options: CustomizeVariantOptions,\n): T {\n  const variant: T = {\n    ...baseVariant,\n    async importModuleLoader() {\n      const moduleLoader = smartUnwrap(await baseVariant.importModuleLoader())\n      return async function newModuleLoader() {\n        const moduleLoaderArg: EmscriptenModuleLoaderOptions = options.emscriptenModule\n          ? { ...options.emscriptenModule }\n          : {}\n        const log =\n          options.log ?? ((...args: unknown[]) => debugLog(\"newVariant moduleLoader:\", ...args))\n        const tapValue = <T>(message: unknown[], val: T) => {\n          log(...message, val)\n          return val\n        }\n\n        const force = <T>(val: OrLoader<T> | undefined): T | undefined | Promise<T> => {\n          if (typeof val === \"function\") {\n            return (val as () => Promise<T>)()\n          }\n          return val\n        }\n\n        if (options.wasmLocation || options.wasmSourceMapLocation || options.locateFile) {\n          moduleLoaderArg.locateFile = (fileName: string, relativeTo: string) => {\n            const args = { fileName, relativeTo }\n            if (fileName.endsWith(\".wasm\") && options.wasmLocation !== undefined) {\n              return tapValue(\n                [\"locateFile .wasm: provide wasmLocation\", args],\n                options.wasmLocation,\n              )\n            }\n\n            if (fileName.endsWith(\".map\")) {\n              if (options.wasmSourceMapLocation !== undefined) {\n                return tapValue(\n                  [\"locateFile .map: provide wasmSourceMapLocation\", args],\n                  options.wasmSourceMapLocation,\n                )\n              }\n\n              if (options.wasmLocation && !options.locateFile) {\n                return tapValue(\n                  [\"locateFile .map: infer from wasmLocation\", args],\n                  options.wasmLocation + \".map\",\n                )\n              }\n            }\n\n            if (options.locateFile) {\n              return tapValue(\n                [\"locateFile: use provided fn\", args],\n                options.locateFile(fileName, relativeTo),\n              )\n            }\n\n            return tapValue([\"locateFile: unhandled, passthrough\", args], fileName)\n          }\n        }\n\n        if (options.wasmBinary) {\n          moduleLoaderArg.wasmBinary = await force(options.wasmBinary)\n        }\n\n        if (options.wasmMemory) {\n          moduleLoaderArg.wasmMemory = await force(options.wasmMemory)\n        }\n\n        const optionsWasmModule = options.wasmModule\n        let modulePromise: Promise<WebAssembly.Module | undefined> | undefined\n        if (optionsWasmModule) {\n          moduleLoaderArg.instantiateWasm = async (imports, onSuccess) => {\n            modulePromise ??= Promise.resolve(force(optionsWasmModule))\n            const wasmModule = await modulePromise\n            if (!wasmModule) {\n              // This should never happen\n              throw new QuickJSEmscriptenModuleError(\n                `options.wasmModule returned ${String(wasmModule)}`,\n              )\n            }\n            const instance = await WebAssembly.instantiate(wasmModule, imports)\n            onSuccess(instance)\n            return instance.exports\n          }\n        }\n\n        moduleLoaderArg.monitorRunDependencies = (left: number) => {\n          log(\"monitorRunDependencies:\", left)\n        }\n\n        // This will be replaced with the actual function by --pre-js\n        // Having the mock around makes our code simpler gives us handy logging\n        // if we need to understand any issues\n        moduleLoaderArg.quickjsEmscriptenInit = () => newMockExtensions(log)\n\n        const resultPromise = moduleLoader(moduleLoaderArg)\n        const extensions = moduleLoaderArg.quickjsEmscriptenInit?.(log)\n        if (\n          optionsWasmModule &&\n          extensions?.receiveWasmOffsetConverter &&\n          !extensions.existingWasmOffsetConverter\n        ) {\n          // Unlikely to be available, we'll usually end up mocking this.\n          // Still if the user has both, we'll take it.\n          const wasmBinary = (await force(options.wasmBinary)) ?? new ArrayBuffer(0)\n\n          modulePromise ??= Promise.resolve(force(optionsWasmModule))\n          const wasmModule = await modulePromise\n          if (!wasmModule) {\n            // This should never happen\n            throw new QuickJSEmscriptenModuleError(\n              `options.wasmModule returned ${String(wasmModule)}`,\n            )\n          }\n          extensions.receiveWasmOffsetConverter(wasmBinary, wasmModule)\n        }\n\n        if (extensions?.receiveSourceMapJSON) {\n          const loadedSourceMapData = await force(options.wasmSourceMapData)\n          if (typeof loadedSourceMapData === \"string\") {\n            extensions.receiveSourceMapJSON(JSON.parse(loadedSourceMapData))\n          } else if (loadedSourceMapData) {\n            extensions.receiveSourceMapJSON(loadedSourceMapData)\n          } else {\n            extensions.receiveSourceMapJSON({ version: 3, names: [], sources: [], mappings: \"\" })\n          }\n        }\n\n        return resultPromise\n      }\n    },\n  }\n  return variant\n}\n\nfunction newMockExtensions(log: typeof console.log): QuickJSEmscriptenExtensions {\n  const mockMessage = `mock called, emscripten module may not be initialized yet`\n  return {\n    mock: true,\n    removeRunDependency(name: string) {\n      log(`${mockMessage}: removeRunDependency called:`, name)\n    },\n    receiveSourceMapJSON(data: unknown) {\n      log(`${mockMessage}: receiveSourceMapJSON called:`, data)\n    },\n    WasmOffsetConverter: undefined,\n    receiveWasmOffsetConverter(bytes: ArrayBuffer, mod: WebAssembly.Module) {\n      log(`${mockMessage}: receiveWasmOffsetConverter called:`, bytes, mod)\n    },\n  }\n}\n","/**\n * Used as an optional.\n * `{ value: S } | { error: E }`.\n */\nexport type SuccessOrFail<S, F> =\n  | {\n      value: S\n      error?: undefined\n    }\n  | {\n      error: F\n    }\n\nexport function isSuccess<S, F>(successOrFail: SuccessOrFail<S, F>): successOrFail is { value: S } {\n  return \"error\" in successOrFail === false\n}\n\nexport function isFail<S, F>(successOrFail: SuccessOrFail<S, F>): successOrFail is { error: F } {\n  return \"error\" in successOrFail === true\n}\n\n/**\n * Used as an optional for results of a Vm call.\n * `{ value: VmHandle } | { error: VmHandle }`.\n */\nexport type VmCallResult<VmHandle> = SuccessOrFail<VmHandle, VmHandle>\n\n/**\n * A VmFunctionImplementation takes handles as arguments.\n * It should return a handle, or be void.\n *\n * To indicate an exception, a VMs can throw either a handle (transferred\n * directly) or any other Javascript value (only the poperties `name` and\n * `message` will be transferred). Or, the VmFunctionImplementation may return\n * a VmCallResult's `{ error: handle }` error variant.\n *\n * VmFunctionImplementation should not free its arguments or its return value.\n * It should not retain a reference to its return value or thrown error.\n */\nexport type VmFunctionImplementation<VmHandle> = (\n  this: VmHandle,\n  ...args: VmHandle[]\n) => VmHandle | VmCallResult<VmHandle> | void\n\n/**\n * A minimal interface to a Javascript execution environment.\n *\n * Higher-level tools should build over the LowLevelJavascriptVm interface to\n * share as much as possible between executors.\n *\n * From https://www.figma.com/blog/how-we-built-the-figma-plugin-system/\n */\nexport interface LowLevelJavascriptVm<VmHandle> {\n  global: VmHandle\n  undefined: VmHandle\n\n  typeof(handle: VmHandle): string\n\n  getNumber(handle: VmHandle): number\n  getString(handle: VmHandle): string\n\n  newNumber(value: number): VmHandle\n  newString(value: string): VmHandle\n  newObject(prototype?: VmHandle): VmHandle\n  newFunction(name: string, value: VmFunctionImplementation<VmHandle>): VmHandle\n\n  // For accessing properties of objects\n  getProp(handle: VmHandle, key: string | VmHandle): VmHandle\n  setProp(handle: VmHandle, key: string | VmHandle, value: VmHandle): void\n  defineProp(\n    handle: VmHandle,\n    key: string | VmHandle,\n    descriptor: VmPropertyDescriptor<VmHandle>,\n  ): void\n\n  callFunction(func: VmHandle, thisVal: VmHandle, ...args: VmHandle[]): VmCallResult<VmHandle>\n  evalCode(code: string, filename?: string): VmCallResult<VmHandle>\n}\n\n/**\n * From https://www.figma.com/blog/how-we-built-the-figma-plugin-system/\n */\nexport interface VmPropertyDescriptor<VmHandle> {\n  value?: VmHandle\n  configurable?: boolean\n  enumerable?: boolean\n  get?: (this: VmHandle) => VmHandle\n  set?: (this: VmHandle, value: VmHandle) => void\n}\n","import type { InterruptHandler } from \"./runtime\"\n\n/**\n * Returns an interrupt handler that interrupts Javascript execution after a deadline time.\n *\n * @param deadline - Interrupt execution if it's still running after this time.\n *   Number values are compared against `Date.now()`\n */\nexport function shouldInterruptAfterDeadline(deadline: Date | number): InterruptHandler {\n  const deadlineAsNumber = typeof deadline === \"number\" ? deadline : deadline.getTime()\n\n  return function () {\n    return Date.now() > deadlineAsNumber\n  }\n}\n","import type { QuickJSContext } from \"./context\"\nimport type { ModuleEvalOptions, QuickJSWASMModule } from \"./module\"\nimport type { QuickJSRuntime } from \"./runtime\"\nimport type { ContextOptions, RuntimeOptions } from \"./types\"\nimport { QuickJSMemoryLeakDetected } from \"./errors\"\nimport { Lifetime } from \"./lifetime\"\n\n/**\n * A test wrapper of {@link QuickJSWASMModule} that keeps a reference to each\n * context or runtime created.\n *\n * Call {@link disposeAll} to reset these sets and calls `dispose` on any left alive\n * (which may throw an error).\n *\n * Call {@link assertNoMemoryAllocated} at the end of a test, when you expect that you've\n * freed all the memory you've ever allocated.\n */\nexport class TestQuickJSWASMModule implements Pick<QuickJSWASMModule, keyof QuickJSWASMModule> {\n  contexts = new Set<QuickJSContext>()\n  runtimes = new Set<QuickJSRuntime>()\n  constructor(private parent: QuickJSWASMModule) {}\n\n  newRuntime(options?: RuntimeOptions): QuickJSRuntime {\n    const runtime = this.parent.newRuntime({\n      ...options,\n      ownedLifetimes: [\n        new Lifetime(undefined, undefined, () => this.runtimes.delete(runtime)),\n        ...(options?.ownedLifetimes ?? []),\n      ],\n    })\n    this.runtimes.add(runtime)\n    return runtime\n  }\n\n  newContext(options?: ContextOptions): QuickJSContext {\n    const context = this.parent.newContext({\n      ...options,\n      ownedLifetimes: [\n        new Lifetime(undefined, undefined, () => this.contexts.delete(context)),\n        ...(options?.ownedLifetimes ?? []),\n      ],\n    })\n    this.contexts.add(context)\n    return context\n  }\n\n  evalCode(code: string, options?: ModuleEvalOptions): unknown {\n    return this.parent.evalCode(code, options)\n  }\n\n  disposeAll() {\n    const allDisposables = [...this.contexts, ...this.runtimes]\n    this.runtimes.clear()\n    this.contexts.clear()\n    allDisposables.forEach((d) => {\n      if (d.alive) {\n        d.dispose()\n      }\n    })\n  }\n\n  assertNoMemoryAllocated() {\n    const leaksDetected = this.getFFI().QTS_RecoverableLeakCheck()\n    if (leaksDetected) {\n      // Note: this is currently only available when building from source\n      // with debug builds.\n      throw new QuickJSMemoryLeakDetected(\"Leak sanitizer detected un-freed memory\")\n    }\n\n    if (this.contexts.size > 0) {\n      throw new QuickJSMemoryLeakDetected(`${this.contexts.size} contexts leaked`)\n    }\n\n    if (this.runtimes.size > 0) {\n      throw new QuickJSMemoryLeakDetected(`${this.runtimes.size} runtimes leaked`)\n    }\n  }\n\n  getWasmMemory(): WebAssembly.Memory {\n    return this.parent.getWasmMemory()\n  }\n\n  /** @private */\n  getFFI() {\n    return this.parent.getFFI()\n  }\n}\n"],"mappings":"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","names":["newQuickJSWASMModuleFromVariant","variantOrPromise","variant","smartUnwrap","wasmModuleLoader","QuickJSFFI","QuickJSWASMModule","wasmModule","ffi","newQuickJSAsyncWASMModuleFromVariant","QuickJSAsyncFFI","QuickJSAsyncWASMModule","memoizePromiseFactory","fn","promise","val","newVariant","baseVariant","options","moduleLoader","moduleLoaderArg","log","args","debugLog","tapValue","message","force","fileName","relativeTo","optionsWasmModule","modulePromise","imports","onSuccess","QuickJSEmscriptenModuleError","instance","left","newMockExtensions","resultPromise","extensions","wasmBinary","loadedSourceMapData","mockMessage","name","data","bytes","mod","isSuccess","successOrFail","isFail","shouldInterruptAfterDeadline","deadline","deadlineAsNumber","TestQuickJSWASMModule","parent","options","runtime","Lifetime","context","code","allDisposables","d","QuickJSMemoryLeakDetected"]}