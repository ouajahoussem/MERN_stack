{"version":3,"sources":["../src/debug.ts","../src/errors.ts","../src/asyncify-helpers.ts","../src/lifetime.ts","../src/deferred-promise.ts","../src/memory.ts","../src/types.ts","../src/context.ts","../src/runtime.ts","../src/module.ts","../src/context-asyncify.ts","../src/runtime-asyncify.ts","../src/module-asyncify.ts","../src/index.ts","../src/from-variant.ts","../src/vm-interface.ts","../src/interrupt-helpers.ts","../src/module-test.ts"],"sourcesContent":["/**\n * @private\n * Mutable variable. Use {@link setDebugMode} to enable.\n */\nexport let QTS_DEBUG = false\n\n/**\n * Enable (or disable) debug logging and object creation tracking in the Javascript API.\n * To get debug logging in the WebAssembly module, you need to use a debug build variant.\n */\nexport function setDebugMode(enabled: boolean = true) {\n  QTS_DEBUG = enabled\n}\n\n/**\n * @private\n */\nexport function debugLog(...args: any[]) {\n  if (QTS_DEBUG) {\n    console.log(...args)\n  }\n}\n","import type { QuickJSContext } from \"./context\"\n\n/**\n * Error thrown if {@link QuickJSContext#unwrapResult} unwraps an error value that isn't an object.\n */\nexport class QuickJSUnwrapError extends Error {\n  name = \"QuickJSUnwrapError\"\n  constructor(\n    public cause: unknown,\n    public context?: QuickJSContext,\n  ) {\n    super(String(cause))\n  }\n}\n\nexport class QuickJSWrongOwner extends Error {\n  name = \"QuickJSWrongOwner\"\n}\n\nexport class QuickJSUseAfterFree extends Error {\n  name = \"QuickJSUseAfterFree\"\n}\n\nexport class QuickJSNotImplemented extends Error {\n  name = \"QuickJSNotImplemented\"\n}\n\nexport class QuickJSAsyncifyError extends Error {\n  name = \"QuickJSAsyncifyError\"\n}\n\nexport class QuickJSAsyncifySuspended extends Error {\n  name = \"QuickJSAsyncifySuspended\"\n}\n\nexport class QuickJSMemoryLeakDetected extends Error {\n  name = \"QuickJSMemoryLeakDetected\"\n}\n\nexport class QuickJSEmscriptenModuleError extends Error {\n  name = \"QuickJSEmscriptenModuleError\"\n}\n\nexport class QuickJSUnknownIntrinsic extends TypeError {\n  name = \"QuickJSUnknownIntrinsic\"\n}\n\nexport class QuickJSPromisePending extends Error {\n  name = \"QuickJSPromisePending\"\n}\n","function* awaitYield<T>(value: T | Promise<T>) {\n  return (yield value) as T\n}\n\nfunction awaitYieldOf<T, Yielded>(\n  generator: Generator<Yielded | Promise<Yielded>, T, Yielded>,\n): Generator<T | Promise<T>, T, T> {\n  return awaitYield(awaitEachYieldedPromise(generator))\n}\n\nexport type AwaitYield = typeof awaitYield & {\n  of: typeof awaitYieldOf\n}\n\nconst AwaitYield: AwaitYield = awaitYield as AwaitYield\nAwaitYield.of = awaitYieldOf\n\n/**\n * Create a function that may or may not be async, using a generator\n *\n * Within the generator, call `yield* awaited(maybePromise)` to await a value\n * that may or may not be a promise.\n *\n * If the inner function never yields a promise, it will return synchronously.\n */\nexport function maybeAsyncFn<\n  /** Function arguments */\n  Args extends any[],\n  This,\n  /** Function return type */\n  Return,\n  /** Yields to unwrap */\n  Yielded,\n>(\n  that: This,\n  fn: (\n    this: This,\n    awaited: AwaitYield,\n    ...args: Args\n  ) => Generator<Yielded | Promise<Yielded>, Return, Yielded>,\n): (...args: Args) => Return | Promise<Return> {\n  return (...args: Args) => {\n    const generator = fn.call(that, AwaitYield, ...args)\n    return awaitEachYieldedPromise(generator)\n  }\n}\n\n// class Example {\n//   private maybeAsyncMethod = maybeAsyncFn(this, function* (awaited, a: number) {\n//     yield* awaited(new Promise((resolve) => setTimeout(resolve, a)))\n//     return 5\n//   })\n// }\n\nexport type MaybeAsyncBlock<Return, This, Yielded, Args extends any[] = []> = (\n  this: This,\n  awaited: AwaitYield,\n  ...args: Args\n) => Generator<Yielded | Promise<Yielded>, Return, Yielded>\n\nexport function maybeAsync<Return, This, Yielded>(\n  that: This,\n  startGenerator: (\n    this: This,\n    await: AwaitYield,\n  ) => Generator<Yielded | Promise<Yielded>, Return, Yielded>,\n): Return | Promise<Return> {\n  const generator = startGenerator.call(that, AwaitYield)\n  return awaitEachYieldedPromise(generator)\n}\n\nexport function awaitEachYieldedPromise<Yielded, Returned>(\n  gen: Generator<Yielded | Promise<Yielded>, Returned, Yielded>,\n): Returned | Promise<Returned> {\n  type NextResult = ReturnType<typeof gen.next>\n\n  function handleNextStep(step: NextResult): Returned | Promise<Returned> {\n    if (step.done) {\n      return step.value\n    }\n\n    if (step.value instanceof Promise) {\n      return step.value.then(\n        (value) => handleNextStep(gen.next(value)),\n        (error) => handleNextStep(gen.throw(error)),\n      )\n    }\n\n    return handleNextStep(gen.next(step.value))\n  }\n\n  return handleNextStep(gen.next())\n}\n","import type { MaybeAsyncBlock } from \"./asyncify-helpers\"\nimport { maybeAsync } from \"./asyncify-helpers\"\nimport { QTS_DEBUG } from \"./debug\"\nimport { QuickJSUseAfterFree } from \"./errors\"\nimport type { QuickJSHandle } from \"./types\"\n\n/**\n * An object that can be disposed.\n * {@link Lifetime} is the canonical implementation of Disposable.\n * Use {@link Scope} to manage cleaning up multiple disposables.\n */\nexport interface Disposable {\n  /**\n   * Dispose of the underlying resources used by this object.\n   */\n  dispose(): void\n\n  /**\n   * @returns true if the object is alive\n   * @returns false after the object has been {@link dispose}d\n   */\n  alive: boolean\n\n  /**\n   * A method that is used to release resources held by an object. Called by the semantics of the `using` statement.\n   */\n  [Symbol.dispose](): void\n}\n\n/**\n * Base abstract class that helps implement {@link Disposable} by providing a default implementation of {@link Symbol.dispose}.\n */\nexport abstract class UsingDisposable implements Disposable {\n  /**\n   * @returns true if the object is alive\n   * @returns false after the object has been {@link dispose}d\n   */\n  declare abstract readonly alive: boolean\n  /**\n   * Dispose of the underlying resources used by this object.\n   */\n  abstract dispose(): void\n  /**\n   * Just calls the standard .dispose() method of this class.\n   */\n  [Symbol.dispose]() {\n    return this.dispose()\n  }\n}\n\n// Polyfill as needed if Symbol.dispose is not available.\n// This polyfill matches ESBuild's behavior.\nconst SymbolDispose = Symbol.dispose ?? Symbol.for(\"Symbol.dispose\")\nconst prototypeAsAny = UsingDisposable.prototype as any\nif (!prototypeAsAny[SymbolDispose]) {\n  prototypeAsAny[SymbolDispose] = function () {\n    return this.dispose()\n  }\n}\n\n/**\n * A lifetime prevents access to a value after the lifetime has been\n * {@link dispose}ed.\n *\n * Typically, quickjs-emscripten uses Lifetimes to protect C memory pointers.\n */\nexport class Lifetime<T, TCopy = never, Owner = never>\n  extends UsingDisposable\n  implements Disposable\n{\n  protected _alive: boolean = true\n  protected _constructorStack = QTS_DEBUG ? new Error(\"Lifetime constructed\").stack : undefined\n\n  /**\n   * When the Lifetime is disposed, it will call `disposer(_value)`. Use the\n   * disposer function to implement whatever cleanup needs to happen at the end\n   * of `value`'s lifetime.\n   *\n   * `_owner` is not used or controlled by the lifetime. It's just metadata for\n   * the creator.\n   */\n  constructor(\n    protected readonly _value: T,\n    protected readonly copier?: (value: T | TCopy) => TCopy,\n    protected readonly disposer?: (value: T | TCopy) => void,\n    protected readonly _owner?: Owner,\n  ) {\n    super()\n  }\n\n  get alive() {\n    return this._alive\n  }\n\n  /**\n   * The value this Lifetime protects. You must never retain the value - it\n   * may become invalid, leading to memory errors.\n   *\n   * @throws If the lifetime has been {@link dispose}d already.\n   */\n  get value() {\n    this.assertAlive()\n    return this._value\n  }\n\n  get owner() {\n    return this._owner\n  }\n\n  get dupable() {\n    return !!this.copier\n  }\n\n  /**\n   * Create a new handle pointing to the same {@link value}.\n   */\n  dup() {\n    this.assertAlive()\n    if (!this.copier) {\n      throw new Error(\"Non-dupable lifetime\")\n    }\n    return new Lifetime<TCopy, TCopy, Owner>(\n      this.copier(this._value),\n      this.copier,\n      this.disposer,\n      this._owner,\n    )\n  }\n\n  /**\n   * Call `map` with this lifetime, then dispose the lifetime.\n   * @return the result of `map(this)`.\n   */\n  consume<O>(map: (lifetime: this) => O): O\n  // A specific type definition is needed for our common use-case\n  // https://github.com/microsoft/TypeScript/issues/30271\n  consume<O>(map: (lifetime: QuickJSHandle) => O): O\n  consume<O>(map: (lifetime: any) => O): O {\n    this.assertAlive()\n    const result = map(this)\n    this.dispose()\n    return result\n  }\n\n  /**\n   * Dispose of {@link value} and perform cleanup.\n   */\n  dispose() {\n    this.assertAlive()\n    if (this.disposer) {\n      this.disposer(this._value)\n    }\n    this._alive = false\n  }\n\n  private assertAlive() {\n    if (!this.alive) {\n      if (this._constructorStack) {\n        throw new QuickJSUseAfterFree(\n          `Lifetime not alive\\n${this._constructorStack}\\nLifetime used`,\n        )\n      }\n      throw new QuickJSUseAfterFree(\"Lifetime not alive\")\n    }\n  }\n}\n\n/**\n * A Lifetime that lives forever. Used for constants.\n */\nexport class StaticLifetime<T, Owner = never> extends Lifetime<T, T, Owner> {\n  constructor(value: T, owner?: Owner) {\n    super(value, undefined, undefined, owner)\n  }\n\n  // Static lifetime doesn't need a copier to be copiable\n  get dupable() {\n    return true\n  }\n\n  // Copy returns the same instance.\n  dup() {\n    return this\n  }\n\n  // Dispose does nothing.\n  dispose() {}\n}\n\n/**\n * A Lifetime that does not own its `value`. A WeakLifetime never calls its\n * `disposer` function, but can be `dup`ed to produce regular lifetimes that\n * do.\n *\n * Used for function arguments.\n */\nexport class WeakLifetime<T, TCopy = never, Owner = never> extends Lifetime<T, TCopy, Owner> {\n  constructor(\n    value: T,\n    copier?: (value: T | TCopy) => TCopy,\n    disposer?: (value: TCopy) => void,\n    owner?: Owner,\n  ) {\n    // We don't care if the disposer doesn't support freeing T\n    super(value, copier, disposer as (value: T | TCopy) => void, owner)\n  }\n\n  dispose() {\n    this._alive = false\n  }\n}\n\nfunction scopeFinally(scope: Scope, blockError: Error | undefined) {\n  // console.log('scopeFinally', scope, blockError)\n  let disposeError: Error | undefined\n  try {\n    scope.dispose()\n  } catch (error) {\n    disposeError = error as any\n  }\n\n  if (blockError && disposeError) {\n    Object.assign(blockError, {\n      message: `${blockError.message}\\n Then, failed to dispose scope: ${disposeError.message}`,\n      disposeError,\n    })\n    throw blockError\n  }\n\n  if (blockError || disposeError) {\n    throw blockError || disposeError\n  }\n}\n\n/**\n * Scope helps reduce the burden of manually tracking and disposing of\n * Lifetimes. See {@link withScope}. and {@link withScopeAsync}.\n */\nexport class Scope extends UsingDisposable implements Disposable {\n  /**\n   * Run `block` with a new Scope instance that will be disposed after the block returns.\n   * Inside `block`, call `scope.manage` on each lifetime you create to have the lifetime\n   * automatically disposed after the block returns.\n   *\n   * @warning Do not use with async functions. Instead, use {@link withScopeAsync}.\n   */\n  static withScope<R>(block: (scope: Scope) => R): R {\n    const scope = new Scope()\n    let blockError: Error | undefined\n    try {\n      return block(scope)\n    } catch (error) {\n      blockError = error as any\n      throw error\n    } finally {\n      scopeFinally(scope, blockError)\n    }\n  }\n\n  static withScopeMaybeAsync<Return, This, Yielded>(\n    _this: This,\n    block: MaybeAsyncBlock<Return, This, Yielded, [Scope]>,\n  ): Return | Promise<Return> {\n    return maybeAsync(undefined, function* (awaited) {\n      const scope = new Scope()\n      let blockError: Error | undefined\n      try {\n        return yield* awaited.of(block.call(_this, awaited, scope))\n      } catch (error) {\n        blockError = error as any\n        throw error\n      } finally {\n        scopeFinally(scope, blockError)\n      }\n    })\n  }\n\n  /**\n   * Run `block` with a new Scope instance that will be disposed after the\n   * block's returned promise settles. Inside `block`, call `scope.manage` on each\n   * lifetime you create to have the lifetime automatically disposed after the\n   * block returns.\n   */\n  static async withScopeAsync<R>(block: (scope: Scope) => Promise<R>): Promise<R> {\n    const scope = new Scope()\n    let blockError: Error | undefined\n    try {\n      return await block(scope)\n    } catch (error) {\n      blockError = error as any\n      throw error\n    } finally {\n      scopeFinally(scope, blockError)\n    }\n  }\n\n  private _disposables: Lifetime<Set<Disposable>> = new Lifetime(new Set())\n\n  /**\n   * Track `lifetime` so that it is disposed when this scope is disposed.\n   */\n  manage<T extends Disposable>(lifetime: T): T {\n    this._disposables.value.add(lifetime)\n    return lifetime\n  }\n\n  get alive() {\n    return this._disposables.alive\n  }\n\n  dispose() {\n    const lifetimes = Array.from(this._disposables.value.values()).reverse()\n    for (const lifetime of lifetimes) {\n      if (lifetime.alive) {\n        lifetime.dispose()\n      }\n    }\n    this._disposables.dispose()\n  }\n}\n","import { UsingDisposable, type Disposable } from \"./lifetime\"\nimport type { QuickJSHandle } from \"./types\"\nimport type { QuickJSRuntime } from \"./runtime\"\nimport type { QuickJSContext } from \"./context\"\nexport type { PromiseExecutor } from \"./types\"\n\n/**\n * A promise state inside QuickJS, which can be pending, fulfilled, or rejected.\n * You can unwrap a JSPromiseState with {@link QuickJSContext#unwrapResult}.\n */\nexport type JSPromiseState =\n  | JSPromiseStatePending\n  | JSPromiseStateFulfilled\n  | JSPromiseStateRejected\n\n/**\n * Pending promise state.\n * See {@link JSPromiseState}.\n */\nexport interface JSPromiseStatePending {\n  type: \"pending\"\n  /**\n   * The error property here allows unwrapping a JSPromiseState with {@link QuickJSContext#unwrapResult}.\n   * Unwrapping a pending promise will throw a {@link QuickJSPromisePending} error.\n   */\n  get error(): Error\n}\n\n/**\n * Fulfilled promise state.\n * See {@link JSPromiseState}.\n */\nexport interface JSPromiseStateFulfilled {\n  type: \"fulfilled\"\n  value: QuickJSHandle\n  error?: undefined\n  /** Trying to get the promise state of a non-Promise value returns a fulfilled state with the original value, and `notAPromise: true`. */\n  notAPromise?: boolean\n}\n\n/**\n * Rejected promise state.\n * See {@link JSPromiseState}.\n */\nexport interface JSPromiseStateRejected {\n  type: \"rejected\"\n  error: QuickJSHandle\n}\n\n/**\n * QuickJSDeferredPromise wraps a QuickJS promise {@link handle} and allows\n * {@link resolve}ing or {@link reject}ing that promise. Use it to bridge asynchronous\n * code on the host to APIs inside a QuickJSContext.\n *\n * Managing the lifetime of promises is tricky. There are three\n * {@link QuickJSHandle}s inside of each deferred promise object: (1) the promise\n * itself, (2) the `resolve` callback, and (3) the `reject` callback.\n *\n * - If the promise will be fulfilled before the end of it's {@link owner}'s lifetime,\n *   the only cleanup necessary is `deferred.handle.dispose()`, because\n *   calling {@link resolve} or {@link reject} will dispose of both callbacks automatically.\n *\n * - As the return value of a {@link VmFunctionImplementation}, return {@link handle},\n *   and ensure that either {@link resolve} or {@link reject} will be called. No other\n *   clean-up is necessary.\n *\n * - In other cases, call {@link dispose}, which will dispose {@link handle} as well as the\n *   QuickJS handles that back {@link resolve} and {@link reject}. For this object,\n *   {@link dispose} is idempotent.\n */\nexport class QuickJSDeferredPromise extends UsingDisposable implements Disposable {\n  public owner: QuickJSRuntime\n  public context: QuickJSContext\n\n  /**\n   * A handle of the Promise instance inside the QuickJSContext.\n   * You must dispose {@link handle} or the entire QuickJSDeferredPromise once you\n   * are finished with it.\n   */\n  public handle: QuickJSHandle\n\n  /**\n   * A native promise that will resolve once this deferred is settled.\n   */\n  public settled: Promise<void>\n\n  private resolveHandle: QuickJSHandle\n  private rejectHandle: QuickJSHandle\n  private onSettled!: () => void\n\n  /**\n   * Use {@link QuickJSContext#newPromise} to create a new promise instead of calling\n   * this constructor directly.\n   */\n  constructor(args: {\n    context: QuickJSContext\n    promiseHandle: QuickJSHandle\n    resolveHandle: QuickJSHandle\n    rejectHandle: QuickJSHandle\n  }) {\n    super()\n    this.context = args.context\n    this.owner = args.context.runtime\n    this.handle = args.promiseHandle\n    this.settled = new Promise((resolve) => {\n      this.onSettled = resolve\n    })\n    this.resolveHandle = args.resolveHandle\n    this.rejectHandle = args.rejectHandle\n  }\n\n  /**\n   * Resolve {@link handle} with the given value, if any.\n   * Calling this method after calling {@link dispose} is a no-op.\n   *\n   * Note that after resolving a promise, you may need to call\n   * {@link QuickJSRuntime#executePendingJobs} to propagate the result to the promise's\n   * callbacks.\n   */\n  resolve = (value?: QuickJSHandle) => {\n    if (!this.resolveHandle.alive) {\n      return\n    }\n\n    this.context\n      .unwrapResult(\n        this.context.callFunction(\n          this.resolveHandle,\n          this.context.undefined,\n          value || this.context.undefined,\n        ),\n      )\n      .dispose()\n\n    this.disposeResolvers()\n    this.onSettled()\n  }\n\n  /**\n   * Reject {@link handle} with the given value, if any.\n   * Calling this method after calling {@link dispose} is a no-op.\n   *\n   * Note that after rejecting a promise, you may need to call\n   * {@link QuickJSRuntime#executePendingJobs} to propagate the result to the promise's\n   * callbacks.\n   */\n  reject = (value?: QuickJSHandle) => {\n    if (!this.rejectHandle.alive) {\n      return\n    }\n\n    this.context\n      .unwrapResult(\n        this.context.callFunction(\n          this.rejectHandle,\n          this.context.undefined,\n          value || this.context.undefined,\n        ),\n      )\n      .dispose()\n\n    this.disposeResolvers()\n    this.onSettled()\n  }\n\n  get alive() {\n    return this.handle.alive || this.resolveHandle.alive || this.rejectHandle.alive\n  }\n\n  dispose = () => {\n    if (this.handle.alive) {\n      this.handle.dispose()\n    }\n    this.disposeResolvers()\n  }\n\n  private disposeResolvers() {\n    if (this.resolveHandle.alive) {\n      this.resolveHandle.dispose()\n    }\n\n    if (this.rejectHandle.alive) {\n      this.rejectHandle.dispose()\n    }\n  }\n}\n","import type {\n  EitherModule,\n  OwnedHeapCharPointer,\n  JSContextPointerPointer,\n  JSValueConstPointerPointer,\n  JSValuePointerPointer,\n  JSVoidPointer,\n} from \"@jitl/quickjs-ffi-types\"\nimport { Lifetime } from \"./lifetime\"\nimport type { QuickJSHandle } from \"./types\"\n\n/**\n * @private\n */\ntype HeapUint8Array = {\n  pointer: JSVoidPointer\n  numBytes: number\n}\n\n/**\n * @private\n */\nexport class ModuleMemory {\n  constructor(public module: EitherModule) {}\n\n  toPointerArray(handleArray: QuickJSHandle[]): Lifetime<JSValueConstPointerPointer> {\n    const typedArray = new Int32Array(handleArray.map((handle) => handle.value))\n    const numBytes = typedArray.length * typedArray.BYTES_PER_ELEMENT\n    const ptr = this.module._malloc(numBytes) as JSValueConstPointerPointer\n    const heapBytes = new Uint8Array(this.module.HEAPU8.buffer, ptr, numBytes)\n    heapBytes.set(new Uint8Array(typedArray.buffer))\n    return new Lifetime(ptr, undefined, (ptr) => this.module._free(ptr))\n  }\n\n  newMutablePointerArray<T extends JSContextPointerPointer | JSValuePointerPointer>(\n    length: number,\n  ): Lifetime<{ typedArray: Int32Array; ptr: T }> {\n    const zeros = new Int32Array(new Array(length).fill(0))\n    const numBytes = zeros.length * zeros.BYTES_PER_ELEMENT\n    const ptr = this.module._malloc(numBytes) as T\n    const typedArray = new Int32Array(this.module.HEAPU8.buffer, ptr, length)\n    typedArray.set(zeros)\n    return new Lifetime({ typedArray, ptr }, undefined, (value) => this.module._free(value.ptr))\n  }\n\n  newHeapCharPointer(string: string): Lifetime<{ ptr: OwnedHeapCharPointer; strlen: number }> {\n    const strlen = this.module.lengthBytesUTF8(string)\n    const dataBytes = strlen + 1\n    const ptr: OwnedHeapCharPointer = this.module._malloc(dataBytes) as OwnedHeapCharPointer\n    this.module.stringToUTF8(string, ptr, dataBytes)\n    return new Lifetime({ ptr, strlen }, undefined, (value) => this.module._free(value.ptr))\n  }\n\n  newHeapBufferPointer(buffer: Uint8Array): Lifetime<HeapUint8Array> {\n    const numBytes = buffer.byteLength\n    const ptr: JSVoidPointer = this.module._malloc(numBytes) as JSVoidPointer\n    this.module.HEAPU8.set(buffer, ptr)\n    return new Lifetime({ pointer: ptr, numBytes }, undefined, (value) =>\n      this.module._free(value.pointer),\n    )\n  }\n\n  consumeHeapCharPointer(ptr: OwnedHeapCharPointer): string {\n    const str = this.module.UTF8ToString(ptr)\n    this.module._free(ptr)\n    return str\n  }\n}\n","import type { JSContextPointer, JSValueConstPointer, JSValuePointer } from \"@jitl/quickjs-ffi-types\"\nimport { EvalFlags, IntrinsicsFlags } from \"@jitl/quickjs-ffi-types\"\nimport type { QuickJSContext } from \"./context\"\nimport type { SuccessOrFail, VmFunctionImplementation } from \"./vm-interface\"\nimport type { Disposable, Lifetime } from \"./lifetime\"\nimport type { QuickJSAsyncContext } from \"./context-asyncify\"\nimport type { InterruptHandler, QuickJSRuntime } from \"./runtime\"\nimport { QuickJSUnknownIntrinsic } from \"./errors\"\n\n/**\n * A QuickJSHandle to a constant that will never change, and does not need to\n * be disposed.\n */\nexport type StaticJSValue = Lifetime<JSValueConstPointer, JSValueConstPointer, QuickJSRuntime>\n\n/**\n * A QuickJSHandle to a borrowed value that does not need to be disposed.\n *\n * In QuickJS, a JSValueConst is a \"borrowed\" reference that isn't owned by the\n * current scope. That means that the current scope should not `JS_FreeValue`\n * it, or retain a reference to it after the scope exits, because it may be\n * freed by its owner.\n *\n * quickjs-emscripten takes care of disposing JSValueConst references.\n */\nexport type JSValueConst = Lifetime<JSValueConstPointer, JSValuePointer, QuickJSRuntime>\n\n/**\n * A owned QuickJSHandle that should be disposed or returned.\n *\n * The QuickJS interpreter passes Javascript values between functions as\n * `JSValue` structs that references some internal data. Because passing\n * structs cross the Empscripten FFI interfaces is bothersome, we use pointers\n * to these structs instead.\n *\n * A JSValue reference is \"owned\" in its scope. before exiting the scope, it\n * should be freed,  by calling `JS_FreeValue(ctx, js_value)`) or returned from\n * the scope. We extend that contract - a JSValuePointer (`JSValue*`) must also\n * be `free`d.\n *\n * You can do so from Javascript by calling the .dispose() method.\n */\nexport type JSValue = Lifetime<JSValuePointer, JSValuePointer, QuickJSRuntime>\n\n/**\n * Wraps a C pointer to a QuickJS JSValue, which represents a Javascript value inside\n * a QuickJS virtual machine.\n *\n * Values must not be shared between QuickJSContext instances.\n * You must dispose of any handles you create by calling the `.dispose()` method.\n */\nexport type QuickJSHandle = StaticJSValue | JSValue | JSValueConst\n\nexport type JSModuleExport =\n  | {\n      type: \"function\"\n      name: string\n      implementation: (vm: QuickJSContext) => VmFunctionImplementation<QuickJSHandle>\n    }\n  | { type: \"value\"; name: string; value: (vm: QuickJSContext) => QuickJSHandle }\n\nexport interface JSModuleDefinition {\n  name: string\n  exports: JSModuleExport[]\n}\n\nexport type JSModuleLoadSuccess = string\nexport type JSModuleLoadFailure = Error | QuickJSHandle\nexport type JSModuleLoadResult =\n  | JSModuleLoadSuccess\n  | SuccessOrFail<JSModuleLoadSuccess, JSModuleLoadFailure>\n\nexport interface JSModuleLoaderAsync {\n  /** Load module (async) */\n  (\n    moduleName: string,\n    context: QuickJSAsyncContext,\n  ): JSModuleLoadResult | Promise<JSModuleLoadResult>\n}\nexport interface JSModuleLoader {\n  /** Load module (sync) */\n  (moduleName: string, context: QuickJSContext): JSModuleLoadResult\n}\n\nexport type JSModuleNormalizeSuccess = string\nexport type JSModuleNormalizeFailure = Error | QuickJSHandle\nexport type JSModuleNormalizeResult =\n  | JSModuleNormalizeSuccess\n  | SuccessOrFail<JSModuleNormalizeSuccess, JSModuleNormalizeFailure>\n\nexport interface JSModuleNormalizerAsync {\n  (\n    baseModuleName: string,\n    requestedName: string,\n    vm: QuickJSAsyncContext,\n  ): JSModuleNormalizeResult | Promise<JSModuleNormalizeResult>\n}\nexport interface JSModuleNormalizer extends JSModuleNormalizerAsync {\n  (baseModuleName: string, requestedName: string, vm: QuickJSContext): JSModuleNormalizeResult\n}\n\ntype TODO<hint extends string = \"?\", typeHint = unknown> = hint & typeHint & never\n\nconst UnstableSymbol = Symbol(\"Unstable\")\n\nexport type PartiallyImplemented<T> = never &\n  T & {\n    [UnstableSymbol]: \"This feature may unimplemented, broken, throw errors, etc.\"\n  }\n\nexport interface RuntimeOptionsBase {\n  interruptHandler?: InterruptHandler\n  maxStackSizeBytes?: number\n  memoryLimitBytes?: number\n\n  promiseRejectionHandler?: TODO<\"JSHostPromiseRejectionTracker\">\n  runtimeInfo?: TODO<\"JS_SetRuntimeInfo\", string>\n  gcThreshold?: TODO<\"JS_SetGCThreshold\", number>\n  sharedArrayBufferFunctions?: TODO<\n    \"JS_SetJSSharedArrayBufferFunctions\",\n    { sab_alloc: TODO; sab_free: TODO; sab_dup: TODO; sab_opaque: TODO }\n  >\n\n  /**\n   * Extra lifetimes the runtime should dispose of after it is destroyed.\n   * @private\n   */\n  ownedLifetimes?: Disposable[]\n}\n\nexport interface RuntimeOptions extends RuntimeOptionsBase {\n  moduleLoader?: JSModuleLoader\n}\n\nexport interface AsyncRuntimeOptions extends RuntimeOptionsBase {\n  moduleLoader?: JSModuleLoaderAsync | JSModuleLoader\n}\n\n// This guy could be declared as Partial<Record<keyof typeof IntrinsicsFlags, boolean>>,\n// but it leads to bad docs.\n/**\n * Language features that can be enabled or disabled in a QuickJSContext.\n * @see {@link ContextOptions}\n */\nexport type Intrinsics = {\n  BaseObjects?: boolean\n  Date?: boolean\n  Eval?: boolean\n  StringNormalize?: boolean\n  RegExp?: boolean\n  RegExpCompiler?: boolean\n  JSON?: boolean\n  Proxy?: boolean\n  MapSet?: boolean\n  TypedArrays?: boolean\n  Promise?: boolean\n  BigInt?: boolean\n  BigFloat?: boolean\n  BigDecimal?: boolean\n  OperatorOverloading?: boolean\n  BignumExt?: boolean\n}\n\ntype _Assert<T, U extends T> = U\ntype _intrinsicsHasKeysOfIntrinsicFlags = _Assert<keyof Intrinsics, keyof typeof IntrinsicsFlags>\ntype _intrinsicsHasKeysOfIntrinsicFlags2 = _Assert<keyof typeof IntrinsicsFlags, keyof Intrinsics>\n\n/**\n * The default {@link Intrinsics} language features enabled in a QuickJSContext.\n * @see {@link ContextOptions}\n */\nexport const DefaultIntrinsics = Object.freeze({\n  BaseObjects: true,\n  Date: true,\n  Eval: true,\n  StringNormalize: true,\n  RegExp: true,\n  JSON: true,\n  Proxy: true,\n  MapSet: true,\n  TypedArrays: true,\n  Promise: true,\n} as const satisfies Intrinsics)\n\n/**\n * @private\n */\nexport function intrinsicsToFlags(intrinsics: Intrinsics | undefined): IntrinsicsFlags {\n  if (!intrinsics) {\n    return 0 as IntrinsicsFlags\n  }\n\n  let result = 0\n  for (const [maybeIntrinsicName, enabled] of Object.entries(intrinsics)) {\n    if (!(maybeIntrinsicName in IntrinsicsFlags)) {\n      throw new QuickJSUnknownIntrinsic(maybeIntrinsicName)\n    }\n    const intrinsicName = maybeIntrinsicName as keyof typeof IntrinsicsFlags\n\n    if (enabled) {\n      result |= IntrinsicsFlags[intrinsicName]\n    }\n  }\n  return result as IntrinsicsFlags\n}\n\n/**\n * Options for creating a {@link QuickJSContext} or {@link QuickJSAsyncContext}\n * Pass to {@link QuickJSRuntime#newContext}.\n */\nexport interface ContextOptions {\n  /**\n   * What built-in objects and language features to enable?\n   * If unset, the default intrinsics will be used.\n   * To omit all intrinsics, pass an empty array.\n   *\n   * To remove a specific intrinsic, but retain the other defaults,\n   * override it from {@link DefaultIntrinsics}\n   * ```ts\n   * const contextWithoutDateOrEval = runtime.newContext({\n   *   intrinsics: {\n   *     ...DefaultIntrinsics,\n   *     Date: false,\n   *   }\n   * })\n   * ```\n   */\n  intrinsics?: Intrinsics\n\n  /**\n   * Wrap the provided context instead of constructing a new one.\n   * @private\n   */\n  contextPointer?: JSContextPointer\n\n  /**\n   * Extra lifetimes the context should dispose of after it is destroyed.\n   * @private\n   */\n  ownedLifetimes?: Disposable[]\n}\n\nexport interface ContextEvalOptions {\n  /**\n   * Global code (default), or \"module\" code?\n   *\n   * - When type is `\"global\"`, the code is evaluated in the global scope of the QuickJSContext, and the return value is the result of the last expression.\n   * - When type is `\"module\"`, the code is evaluated is a module scope, may use `import`, `export`, and top-level `await`. The return value is the module's exports, or a promise for the module's exports.\n   */\n  type?: \"global\" | \"module\"\n  /** Force \"strict\" mode */\n  strict?: boolean\n  /** Force \"strip\" mode */\n  strip?: boolean\n  /**\n   * compile but do not run. The result is an object with a\n   * JS_TAG_FUNCTION_BYTECODE or JS_TAG_MODULE tag. It can be executed\n   * with JS_EvalFunction().\n   */\n  compileOnly?: boolean\n  /** don't include the stack frames before this eval in the Error() backtraces */\n  backtraceBarrier?: boolean\n}\n\n/** Convert {@link ContextEvalOptions} to a bitfield flags */\nexport function evalOptionsToFlags(evalOptions: ContextEvalOptions | number | undefined): number {\n  if (typeof evalOptions === \"number\") {\n    return evalOptions\n  }\n\n  if (evalOptions === undefined) {\n    return 0\n  }\n\n  const { type, strict, strip, compileOnly, backtraceBarrier } = evalOptions\n  let flags = 0\n  if (type === \"global\") flags |= EvalFlags.JS_EVAL_TYPE_GLOBAL\n  if (type === \"module\") flags |= EvalFlags.JS_EVAL_TYPE_MODULE\n  if (strict) flags |= EvalFlags.JS_EVAL_FLAG_STRICT\n  if (strip) flags |= EvalFlags.JS_EVAL_FLAG_STRIP\n  if (compileOnly) flags |= EvalFlags.JS_EVAL_FLAG_COMPILE_ONLY\n  if (backtraceBarrier) flags |= EvalFlags.JS_EVAL_FLAG_BACKTRACE_BARRIER\n  return flags\n}\n\nexport type PromiseExecutor<ResolveT, RejectT> = (\n  resolve: (value: ResolveT | PromiseLike<ResolveT>) => void,\n  reject: (reason: RejectT) => void,\n) => void\n\nexport function concat<T>(...values: Array<T[] | T | undefined>): T[] {\n  let result: T[] = []\n  for (const value of values) {\n    if (value !== undefined) {\n      result = result.concat(value)\n    }\n  }\n  return result\n}\n","import { JSPromiseStateEnum } from \"@jitl/quickjs-ffi-types\"\nimport type {\n  EvalFlags,\n  EitherModule,\n  EvalDetectModule,\n  JSBorrowedCharPointer,\n  JSContextPointer,\n  JSRuntimePointer,\n  JSValueConstPointer,\n  JSValuePointer,\n  JSValuePointerPointer,\n  EitherFFI,\n} from \"@jitl/quickjs-ffi-types\"\nimport { debugLog } from \"./debug\"\nimport type { JSPromiseState } from \"./deferred-promise\"\nimport { QuickJSDeferredPromise } from \"./deferred-promise\"\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { shouldInterruptAfterDeadline } from \"./interrupt-helpers\"\nimport { QuickJSPromisePending, QuickJSUnwrapError } from \"./errors\"\nimport type { Disposable } from \"./lifetime\"\nimport { Lifetime, Scope, StaticLifetime, UsingDisposable, WeakLifetime } from \"./lifetime\"\nimport { ModuleMemory } from \"./memory\"\nimport type { ContextCallbacks, QuickJSModuleCallbacks } from \"./module\"\nimport type {\n  QuickJSRuntime,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ExecutePendingJobsResult,\n} from \"./runtime\"\nimport type { ContextEvalOptions, JSValue, PromiseExecutor, QuickJSHandle } from \"./types\"\nimport { evalOptionsToFlags } from \"./types\"\nimport type {\n  LowLevelJavascriptVm,\n  SuccessOrFail,\n  VmCallResult,\n  VmFunctionImplementation,\n  VmPropertyDescriptor,\n} from \"./vm-interface\"\n\n/**\n * Property key for getting or setting a property on a handle with\n * {@link QuickJSContext#getProp}, {@link QuickJSContext#setProp}, or {@link QuickJSContext#defineProp}.\n */\nexport type QuickJSPropertyKey = number | string | QuickJSHandle\n\n/**\n * @private\n */\nclass ContextMemory extends ModuleMemory implements Disposable {\n  readonly owner: QuickJSRuntime\n  readonly ctx: Lifetime<JSContextPointer>\n  readonly rt: Lifetime<JSRuntimePointer>\n  readonly module: EitherModule\n  readonly ffi: EitherFFI\n  readonly scope = new Scope()\n\n  /** @private */\n  constructor(args: {\n    owner: QuickJSRuntime\n    module: EitherModule\n    ffi: EitherFFI\n    ctx: Lifetime<JSContextPointer>\n    rt: Lifetime<JSRuntimePointer>\n    ownedLifetimes?: Disposable[]\n  }) {\n    super(args.module)\n    args.ownedLifetimes?.forEach((lifetime) => this.scope.manage(lifetime))\n    this.owner = args.owner\n    this.module = args.module\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.ctx = this.scope.manage(args.ctx)\n  }\n\n  get alive() {\n    return this.scope.alive\n  }\n\n  dispose() {\n    return this.scope.dispose()\n  }\n\n  [Symbol.dispose]() {\n    return this.dispose()\n  }\n\n  /**\n   * Track `lifetime` so that it is disposed when this scope is disposed.\n   */\n  manage<T extends Disposable>(lifetime: T): T {\n    return this.scope.manage(lifetime)\n  }\n\n  copyJSValue = (ptr: JSValuePointer | JSValueConstPointer) => {\n    return this.ffi.QTS_DupValuePointer(this.ctx.value, ptr)\n  }\n\n  freeJSValue = (ptr: JSValuePointer) => {\n    this.ffi.QTS_FreeValuePointer(this.ctx.value, ptr)\n  }\n\n  consumeJSCharPointer(ptr: JSBorrowedCharPointer): string {\n    const str = this.module.UTF8ToString(ptr)\n    this.ffi.QTS_FreeCString(this.ctx.value, ptr)\n    return str\n  }\n\n  heapValueHandle(ptr: JSValuePointer): JSValue {\n    return new Lifetime(ptr, this.copyJSValue, this.freeJSValue, this.owner)\n  }\n}\n\n/**\n * QuickJSContext wraps a QuickJS Javascript context (JSContext*) within a\n * runtime. The contexts within the same runtime may exchange objects freely.\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain. The {@link runtime} references the context's runtime.\n *\n * This class's methods return {@link QuickJSHandle}, which wrap C pointers (JSValue*).\n * It's the caller's responsibility to call `.dispose()` on any\n * handles you create to free memory once you're done with the handle.\n *\n * Use {@link QuickJSRuntime#newContext} or {@link QuickJSWASMModule#newContext}\n * to create a new QuickJSContext.\n *\n * Create QuickJS values inside the interpreter with methods like\n * {@link newNumber}, {@link newString}, {@link newArray}, {@link newObject},\n * {@link newFunction}, and {@link newPromise}.\n *\n * Call {@link setProp} or {@link defineProp} to customize objects. Use those methods\n * with {@link global} to expose the values you create to the interior of the\n * interpreter, so they can be used in {@link evalCode}.\n *\n * Use {@link evalCode} or {@link callFunction} to execute Javascript inside the VM. If\n * you're using asynchronous code inside the QuickJSContext, you may need to also\n * call {@link QuickJSRuntime#executePendingJobs}. Executing code inside the runtime returns a\n * result object representing successful execution or an error. You must dispose\n * of any such results to avoid leaking memory inside the VM.\n *\n * Implement memory and CPU constraints at the runtime level, using {@link runtime}.\n * See {@link QuickJSRuntime} for more information.\n *\n */\n// TODO: Manage own callback registration\nexport class QuickJSContext\n  extends UsingDisposable\n  implements LowLevelJavascriptVm<QuickJSHandle>, Disposable\n{\n  /**\n   * The runtime that created this context.\n   */\n  public readonly runtime: QuickJSRuntime\n\n  /** @private */\n  protected readonly ctx: Lifetime<JSContextPointer>\n  /** @private */\n  protected readonly rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected readonly module: EitherModule\n  /** @private */\n  protected readonly ffi: EitherFFI\n  /** @private */\n  protected memory: ContextMemory\n\n  /** @private */\n  protected _undefined: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _null: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _false: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _true: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _global: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _BigInt: QuickJSHandle | undefined = undefined\n\n  /**\n   * Use {@link QuickJSRuntime#newContext} or {@link QuickJSWASMModule#newContext}\n   * to create a new QuickJSContext.\n   */\n  constructor(args: {\n    module: EitherModule\n    ffi: EitherFFI\n    ctx: Lifetime<JSContextPointer>\n    rt: Lifetime<JSRuntimePointer>\n    runtime: QuickJSRuntime\n    ownedLifetimes?: Disposable[]\n    callbacks: QuickJSModuleCallbacks\n  }) {\n    super()\n    this.runtime = args.runtime\n    this.module = args.module\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.ctx = args.ctx\n    this.memory = new ContextMemory({\n      ...args,\n      owner: this.runtime,\n    })\n    args.callbacks.setContextCallbacks(this.ctx.value, this.cToHostCallbacks)\n    this.dump = this.dump.bind(this)\n    this.getString = this.getString.bind(this)\n    this.getNumber = this.getNumber.bind(this)\n    this.resolvePromise = this.resolvePromise.bind(this)\n  }\n\n  // @implement Disposable ----------------------------------------------------\n\n  get alive() {\n    return this.memory.alive\n  }\n\n  /**\n   * Dispose of this VM's underlying resources.\n   *\n   * @throws Calling this method without disposing of all created handles\n   * will result in an error.\n   */\n  dispose() {\n    this.memory.dispose()\n  }\n\n  // Globals ------------------------------------------------------------------\n\n  /**\n   * [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined).\n   */\n  get undefined(): QuickJSHandle {\n    if (this._undefined) {\n      return this._undefined\n    }\n\n    // Undefined is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetUndefined()\n    return (this._undefined = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null).\n   */\n  get null(): QuickJSHandle {\n    if (this._null) {\n      return this._null\n    }\n\n    // Null is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetNull()\n    return (this._null = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`true`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/true).\n   */\n  get true(): QuickJSHandle {\n    if (this._true) {\n      return this._true\n    }\n\n    // True is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetTrue()\n    return (this._true = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`false`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/false).\n   */\n  get false(): QuickJSHandle {\n    if (this._false) {\n      return this._false\n    }\n\n    // False is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetFalse()\n    return (this._false = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`global`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects).\n   * A handle to the global object inside the interpreter.\n   * You can set properties to create global variables.\n   */\n  get global(): QuickJSHandle {\n    if (this._global) {\n      return this._global\n    }\n\n    // The global is a JSValue, but since it's lifetime is as long as the VM's,\n    // we should manage it.\n    const ptr = this.ffi.QTS_GetGlobalObject(this.ctx.value)\n\n    // Automatically clean up this reference when we dispose\n    this.memory.manage(this.memory.heapValueHandle(ptr))\n\n    // This isn't technically a static lifetime, but since it has the same\n    // lifetime as the VM, it's okay to fake one since when the VM is\n    // disposed, no other functions will accept the value.\n    this._global = new StaticLifetime(ptr, this.runtime)\n    return this._global\n  }\n\n  // New values ---------------------------------------------------------------\n\n  /**\n   * Converts a Javascript number into a QuickJS value.\n   */\n  newNumber(num: number): QuickJSHandle {\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFloat64(this.ctx.value, num))\n  }\n\n  /**\n   * Create a QuickJS [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) value.\n   */\n  newString(str: string): QuickJSHandle {\n    const ptr = this.memory\n      .newHeapCharPointer(str)\n      .consume((charHandle) => this.ffi.QTS_NewString(this.ctx.value, charHandle.value.ptr))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a QuickJS [symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) value.\n   * No two symbols created with this function will be the same value.\n   */\n  newUniqueSymbol(description: string | symbol): QuickJSHandle {\n    const key = (typeof description === \"symbol\" ? description.description : description) ?? \"\"\n    const ptr = this.memory\n      .newHeapCharPointer(key)\n      .consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value.ptr, 0))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Get a symbol from the [global registry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry) for the given key.\n   * All symbols created with the same key will be the same value.\n   */\n  newSymbolFor(key: string | symbol): QuickJSHandle {\n    const description = (typeof key === \"symbol\" ? key.description : key) ?? \"\"\n    const ptr = this.memory\n      .newHeapCharPointer(description)\n      .consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value.ptr, 1))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a QuickJS [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) value.\n   */\n  newBigInt(num: bigint): QuickJSHandle {\n    if (!this._BigInt) {\n      const bigIntHandle = this.getProp(this.global, \"BigInt\")\n      this.memory.manage(bigIntHandle)\n      this._BigInt = new StaticLifetime(bigIntHandle.value as JSValueConstPointer, this.runtime)\n    }\n\n    const bigIntHandle = this._BigInt\n    const asString = String(num)\n    return this.newString(asString).consume((handle) =>\n      this.unwrapResult(this.callFunction(bigIntHandle, this.undefined, handle)),\n    )\n  }\n\n  /**\n   * `{}`.\n   * Create a new QuickJS [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer).\n   *\n   * @param prototype - Like [`Object.create`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create).\n   */\n  newObject(prototype?: QuickJSHandle): QuickJSHandle {\n    if (prototype) {\n      this.runtime.assertOwned(prototype)\n    }\n    const ptr = prototype\n      ? this.ffi.QTS_NewObjectProto(this.ctx.value, prototype.value)\n      : this.ffi.QTS_NewObject(this.ctx.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * `[]`.\n   * Create a new QuickJS [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).\n   */\n  newArray(): QuickJSHandle {\n    const ptr = this.ffi.QTS_NewArray(this.ctx.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   *  Create a new QuickJS [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer).\n   */\n  newArrayBuffer(buffer: ArrayBufferLike): QuickJSHandle {\n    const array = new Uint8Array(buffer)\n    const handle = this.memory.newHeapBufferPointer(array)\n    const ptr = this.ffi.QTS_NewArrayBuffer(this.ctx.value, handle.value.pointer, array.length)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a new {@link QuickJSDeferredPromise}. Use `deferred.resolve(handle)` and\n   * `deferred.reject(handle)` to fulfill the promise handle available at `deferred.handle`.\n   * Note that you are responsible for calling `deferred.dispose()` to free the underlying\n   * resources; see the documentation on {@link QuickJSDeferredPromise} for details.\n   */\n  newPromise(): QuickJSDeferredPromise\n  /**\n   * Create a new {@link QuickJSDeferredPromise} that resolves when the\n   * given native Promise<QuickJSHandle> resolves. Rejections will be coerced\n   * to a QuickJS error.\n   *\n   * You can still resolve/reject the created promise \"early\" using its methods.\n   */\n  newPromise(promise: Promise<QuickJSHandle>): QuickJSDeferredPromise\n  /**\n   * Construct a new native Promise<QuickJSHandle>, and then convert it into a\n   * {@link QuickJSDeferredPromise}.\n   *\n   * You can still resolve/reject the created promise \"early\" using its methods.\n   */\n  newPromise(\n    newPromiseFn: PromiseExecutor<QuickJSHandle, Error | QuickJSHandle>,\n  ): QuickJSDeferredPromise\n  newPromise(\n    value?: PromiseExecutor<QuickJSHandle, Error | QuickJSHandle> | Promise<QuickJSHandle>,\n  ): QuickJSDeferredPromise {\n    const deferredPromise = Scope.withScope((scope) => {\n      const mutablePointerArray = scope.manage(\n        this.memory.newMutablePointerArray<JSValuePointerPointer>(2),\n      )\n      const promisePtr = this.ffi.QTS_NewPromiseCapability(\n        this.ctx.value,\n        mutablePointerArray.value.ptr,\n      )\n      const promiseHandle = this.memory.heapValueHandle(promisePtr)\n      const [resolveHandle, rejectHandle] = Array.from(mutablePointerArray.value.typedArray).map(\n        (jsvaluePtr) => this.memory.heapValueHandle(jsvaluePtr as any),\n      )\n      return new QuickJSDeferredPromise({\n        context: this,\n        promiseHandle,\n        resolveHandle,\n        rejectHandle,\n      })\n    })\n\n    if (value && typeof value === \"function\") {\n      value = new Promise(value)\n    }\n\n    if (value) {\n      Promise.resolve(value).then(deferredPromise.resolve, (error) =>\n        error instanceof Lifetime\n          ? deferredPromise.reject(error)\n          : this.newError(error).consume(deferredPromise.reject),\n      )\n    }\n\n    return deferredPromise\n  }\n\n  /**\n   * Convert a Javascript function into a QuickJS function value.\n   * See {@link VmFunctionImplementation} for more details.\n   *\n   * A {@link VmFunctionImplementation} should not free its arguments or its return\n   * value. A VmFunctionImplementation should also not retain any references to\n   * its return value.\n   *\n   * The function argument handles are automatically disposed when the function\n   * returns. If you want to retain a handle beyond the end of the function, you\n   * can call {@link Lifetime#dup} to create a copy of the handle that you own\n   * and must dispose manually. For example, you need to use this API and do some\n   * extra book keeping to implement `setInterval`:\n   *\n   * ```typescript\n   * // This won't work because `callbackHandle` expires when the function returns,\n   * // so when the interval fires, the callback handle is already disposed.\n   * const WRONG_setIntervalHandle = context.newFunction(\"setInterval\", (callbackHandle, delayHandle) => {\n   *   const delayMs = context.getNumber(delayHandle)\n   *   const intervalId = globalThis.setInterval(() => {\n   *     // ERROR: callbackHandle is already disposed here.\n   *     context.callFunction(callbackHandle)\n   *   }, intervalId)\n   *   return context.newNumber(intervalId)\n   * })\n   *\n   * // This works since we dup the callbackHandle.\n   * // We just need to make sure we clean it up manually when the interval is cleared --\n   * // so we need to keep track of those interval IDs, and make sure we clean all\n   * // of them up when we dispose the owning context.\n   *\n   * const setIntervalHandle = context.newFunction(\"setInterval\", (callbackHandle, delayHandle) => {\n   *   // Ensure the guest can't overload us by scheduling too many intervals.\n   *   if (QuickJSInterval.INTERVALS.size > 100) {\n   *     throw new Error(`Too many intervals scheduled already`)\n   *   }\n   *\n   *   const delayMs = context.getNumber(delayHandle)\n   *   const longLivedCallbackHandle = callbackHandle.dup()\n   *   const intervalId = globalThis.setInterval(() => {\n   *     context.callFunction(longLivedCallbackHandle)\n   *   }, intervalId)\n   *   const disposable = new QuickJSInterval(longLivedCallbackHandle, context, intervalId)\n   *   QuickJSInterval.INTERVALS.set(intervalId, disposable)\n   *   return context.newNumber(intervalId)\n   * })\n   *\n   * const clearIntervalHandle = context.newFunction(\"clearInterval\", (intervalIdHandle) => {\n   *   const intervalId = context.getNumber(intervalIdHandle)\n   *   const disposable = QuickJSInterval.INTERVALS.get(intervalId)\n   *   disposable?.dispose()\n   * })\n   *\n   * class QuickJSInterval extends UsingDisposable {\n   *   static INTERVALS = new Map<number, QuickJSInterval>()\n   *\n   *   static disposeContext(context: QuickJSContext) {\n   *     for (const interval of QuickJSInterval.INTERVALS.values()) {\n   *       if (interval.context === context) {\n   *         interval.dispose()\n   *       }\n   *     }\n   *   }\n   *\n   *   constructor(\n   *     public fnHandle: QuickJSHandle,\n   *     public context: QuickJSContext,\n   *     public intervalId: number,\n   *   ) {\n   *     super()\n   *   }\n   *\n   *   dispose() {\n   *     globalThis.clearInterval(this.intervalId)\n   *     this.fnHandle.dispose()\n   *     QuickJSInterval.INTERVALS.delete(this.fnHandle.value)\n   *   }\n   *\n   *   get alive() {\n   *     return this.fnHandle.alive\n   *   }\n   * }\n   * ```\n   *\n   * To implement an async function, create a promise with {@link newPromise}, then\n   * return the deferred promise handle from `deferred.handle` from your\n   * function implementation:\n   *\n   * ```typescript\n   * const deferred = vm.newPromise()\n   * someNativeAsyncFunction().then(deferred.resolve)\n   * return deferred.handle\n   * ```\n   */\n  newFunction(name: string, fn: VmFunctionImplementation<QuickJSHandle>): QuickJSHandle {\n    const fnId = ++this.fnNextId\n    this.setFunction(fnId, fn)\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFunction(this.ctx.value, fnId, name))\n  }\n\n  newError(error: { name: string; message: string }): QuickJSHandle\n  newError(message: string): QuickJSHandle\n  newError(): QuickJSHandle\n  newError(error?: string | { name: string; message: string }): QuickJSHandle {\n    const errorHandle = this.memory.heapValueHandle(this.ffi.QTS_NewError(this.ctx.value))\n\n    if (error && typeof error === \"object\") {\n      if (error.name !== undefined) {\n        this.newString(error.name).consume((handle) => this.setProp(errorHandle, \"name\", handle))\n      }\n\n      if (error.message !== undefined) {\n        this.newString(error.message).consume((handle) =>\n          this.setProp(errorHandle, \"message\", handle),\n        )\n      }\n    } else if (typeof error === \"string\") {\n      this.newString(error).consume((handle) => this.setProp(errorHandle, \"message\", handle))\n    } else if (error !== undefined) {\n      // This isn't supported in the type signature but maybe it will make life easier.\n      this.newString(String(error)).consume((handle) =>\n        this.setProp(errorHandle, \"message\", handle),\n      )\n    }\n\n    return errorHandle\n  }\n\n  // Read values --------------------------------------------------------------\n\n  /**\n   * `typeof` operator. **Not** [standards compliant](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof).\n   *\n   * @remarks\n   * Does not support BigInt values correctly.\n   */\n  typeof(handle: QuickJSHandle) {\n    this.runtime.assertOwned(handle)\n    return this.memory.consumeHeapCharPointer(this.ffi.QTS_Typeof(this.ctx.value, handle.value))\n  }\n\n  /**\n   * Converts `handle` into a Javascript number.\n   * @returns `NaN` on error, otherwise a `number`.\n   */\n  getNumber(handle: QuickJSHandle): number {\n    this.runtime.assertOwned(handle)\n    return this.ffi.QTS_GetFloat64(this.ctx.value, handle.value)\n  }\n\n  /**\n   * Converts `handle` to a Javascript string.\n   */\n  getString(handle: QuickJSHandle): string {\n    this.runtime.assertOwned(handle)\n    return this.memory.consumeJSCharPointer(this.ffi.QTS_GetString(this.ctx.value, handle.value))\n  }\n\n  /**\n   * Converts `handle` into a Javascript symbol. If the symbol is in the global\n   * registry in the guest, it will be created with Symbol.for on the host.\n   */\n  getSymbol(handle: QuickJSHandle): symbol {\n    this.runtime.assertOwned(handle)\n    const key = this.memory.consumeJSCharPointer(\n      this.ffi.QTS_GetSymbolDescriptionOrKey(this.ctx.value, handle.value),\n    )\n    const isGlobal = this.ffi.QTS_IsGlobalSymbol(this.ctx.value, handle.value)\n    return isGlobal ? Symbol.for(key) : Symbol(key)\n  }\n\n  /**\n   * Converts `handle` to a Javascript bigint.\n   */\n  getBigInt(handle: QuickJSHandle): bigint {\n    this.runtime.assertOwned(handle)\n    const asString = this.getString(handle)\n    return BigInt(asString)\n  }\n\n  /**\n   * Coverts `handle` to a JavaScript ArrayBuffer\n   */\n  getArrayBuffer(handle: QuickJSHandle): Lifetime<Uint8Array> {\n    this.runtime.assertOwned(handle)\n    const len = this.ffi.QTS_GetArrayBufferLength(this.ctx.value, handle.value)\n    const ptr = this.ffi.QTS_GetArrayBuffer(this.ctx.value, handle.value)\n    if (!ptr) {\n      throw new Error(\"Couldn't allocate memory to get ArrayBuffer\")\n    }\n    return new Lifetime(this.module.HEAPU8.subarray(ptr, ptr + len), undefined, () =>\n      this.module._free(ptr),\n    )\n  }\n\n  /**\n   * Get the current state of a QuickJS promise, see {@link JSPromiseState} for the possible states.\n   * This can be used to expect a promise to be fulfilled when combined with {@link unwrapResult}:\n   *\n   * ```typescript\n   * const promiseHandle = context.evalCode(`Promise.resolve(42)`);\n   * const resultHandle = context.unwrapResult(\n   *  context.getPromiseState(promiseHandle)\n   * );\n   * context.getNumber(resultHandle) === 42; // true\n   * resultHandle.dispose();\n   * ```\n   */\n  getPromiseState(handle: QuickJSHandle): JSPromiseState {\n    this.runtime.assertOwned(handle)\n    const state = this.ffi.QTS_PromiseState(this.ctx.value, handle.value)\n    if (state < 0) {\n      // Not a promise, but act like `await` would with non-promise, and just return the value.\n      return { type: \"fulfilled\", value: handle, notAPromise: true }\n    }\n\n    if (state === JSPromiseStateEnum.Pending) {\n      return {\n        type: \"pending\",\n        get error() {\n          return new QuickJSPromisePending(`Cannot unwrap a pending promise`)\n        },\n      }\n    }\n\n    const ptr = this.ffi.QTS_PromiseResult(this.ctx.value, handle.value)\n    const result = this.memory.heapValueHandle(ptr)\n    if (state === JSPromiseStateEnum.Fulfilled) {\n      return { type: \"fulfilled\", value: result }\n    }\n    if (state === JSPromiseStateEnum.Rejected) {\n      return { type: \"rejected\", error: result }\n    }\n    result.dispose()\n    throw new Error(`Unknown JSPromiseStateEnum: ${state}`)\n  }\n\n  /**\n   * `Promise.resolve(value)`.\n   * Convert a handle containing a Promise-like value inside the VM into an\n   * actual promise on the host.\n   *\n   * @remarks\n   * You may need to call {@link runtime}.{@link QuickJSRuntime#executePendingJobs} to ensure that the promise is resolved.\n   *\n   * @param promiseLikeHandle - A handle to a Promise-like value with a `.then(onSuccess, onError)` method.\n   */\n  resolvePromise(promiseLikeHandle: QuickJSHandle): Promise<VmCallResult<QuickJSHandle>> {\n    this.runtime.assertOwned(promiseLikeHandle)\n    const vmResolveResult = Scope.withScope((scope) => {\n      const vmPromise = scope.manage(this.getProp(this.global, \"Promise\"))\n      const vmPromiseResolve = scope.manage(this.getProp(vmPromise, \"resolve\"))\n      return this.callFunction(vmPromiseResolve, vmPromise, promiseLikeHandle)\n    })\n    if (vmResolveResult.error) {\n      return Promise.resolve(vmResolveResult)\n    }\n\n    return new Promise<VmCallResult<QuickJSHandle>>((resolve) => {\n      Scope.withScope((scope) => {\n        const resolveHandle = scope.manage(\n          this.newFunction(\"resolve\", (value) => {\n            resolve({ value: value && value.dup() })\n          }),\n        )\n\n        const rejectHandle = scope.manage(\n          this.newFunction(\"reject\", (error) => {\n            resolve({ error: error && error.dup() })\n          }),\n        )\n\n        const promiseHandle = scope.manage(vmResolveResult.value)\n        const promiseThenHandle = scope.manage(this.getProp(promiseHandle, \"then\"))\n        this.unwrapResult(\n          this.callFunction(promiseThenHandle, promiseHandle, resolveHandle, rejectHandle),\n        ).dispose()\n      })\n    })\n  }\n\n  // Properties ---------------------------------------------------------------\n\n  /**\n   * `handle[key]`.\n   * Get a property from a JSValue.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string (which will be converted automatically).\n   */\n  getProp(handle: QuickJSHandle, key: QuickJSPropertyKey): QuickJSHandle {\n    this.runtime.assertOwned(handle)\n    const ptr = this.borrowPropertyKey(key).consume((quickJSKey) =>\n      this.ffi.QTS_GetProp(this.ctx.value, handle.value, quickJSKey.value),\n    )\n    const result = this.memory.heapValueHandle(ptr)\n\n    return result\n  }\n\n  /**\n   * `handle[key] = value`.\n   * Set a property on a JSValue.\n   *\n   * @remarks\n   * Note that the QuickJS authors recommend using {@link defineProp} to define new\n   * properties.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  setProp(handle: QuickJSHandle, key: QuickJSPropertyKey, value: QuickJSHandle) {\n    this.runtime.assertOwned(handle)\n    // free newly allocated value if key was a string or number. No-op if string was already\n    // a QuickJS handle.\n    this.borrowPropertyKey(key).consume((quickJSKey) =>\n      this.ffi.QTS_SetProp(this.ctx.value, handle.value, quickJSKey.value, value.value),\n    )\n  }\n\n  /**\n   * [`Object.defineProperty(handle, key, descriptor)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  defineProp(\n    handle: QuickJSHandle,\n    key: QuickJSPropertyKey,\n    descriptor: VmPropertyDescriptor<QuickJSHandle>,\n  ): void {\n    this.runtime.assertOwned(handle)\n    Scope.withScope((scope) => {\n      const quickJSKey = scope.manage(this.borrowPropertyKey(key))\n\n      const value = descriptor.value || this.undefined\n      const configurable = Boolean(descriptor.configurable)\n      const enumerable = Boolean(descriptor.enumerable)\n      const hasValue = Boolean(descriptor.value)\n      const get = descriptor.get\n        ? scope.manage(this.newFunction(descriptor.get.name, descriptor.get))\n        : this.undefined\n      const set = descriptor.set\n        ? scope.manage(this.newFunction(descriptor.set.name, descriptor.set))\n        : this.undefined\n\n      this.ffi.QTS_DefineProp(\n        this.ctx.value,\n        handle.value,\n        quickJSKey.value,\n        value.value,\n        get.value,\n        set.value,\n        configurable,\n        enumerable,\n        hasValue,\n      )\n    })\n  }\n\n  // Evaluation ---------------------------------------------------------------\n\n  /**\n   * [`func.call(thisVal, ...args)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call).\n   * Call a JSValue as a function.\n   *\n   * See {@link unwrapResult}, which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use {@link resolvePromise} to convert it to a native promise and\n   * {@link runtime}.{@link QuickJSRuntime#executePendingJobs} to finish evaluating the promise.\n   *\n   * @returns A result. If the function threw synchronously, `result.error` be a\n   * handle to the exception. Otherwise `result.value` will be a handle to the\n   * value.\n   */\n  callFunction(\n    func: QuickJSHandle,\n    thisVal: QuickJSHandle,\n    ...args: QuickJSHandle[]\n  ): VmCallResult<QuickJSHandle> {\n    this.runtime.assertOwned(func)\n    const resultPtr = this.memory\n      .toPointerArray(args)\n      .consume((argsArrayPtr) =>\n        this.ffi.QTS_Call(\n          this.ctx.value,\n          func.value,\n          thisVal.value,\n          args.length,\n          argsArrayPtr.value,\n        ),\n      )\n\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Like [`eval(code)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Description).\n   *\n   * Evaluates `code`, as though it's in a file named `filename`, with options `options`.\n   *\n   * - When `options.type` is `\"global\"`, the code is evaluated in the global\n   *   scope of the QuickJSContext, and the return value is the result of the last\n   *   expression.\n   * - When `options.type` is `\"module\"`, the code is evaluated is a module scope.\n   *   It may use `import` and `export` if {@link runtime}.{@link QuickJSRuntime#setModuleLoader} was called.\n   *   It may use top-level await if supported by the underlying QuickJS library.\n   *   The return value is the module's exports, or a promise for the module's exports.\n   * - When `options.type` is unset, the code is evaluated as a module if it\n   *   contains an `import` or `export` statement, otherwise it is evaluated in\n   *   the global scope.\n   *\n   * When working with async code, you many need to call {@link runtime}.{@link QuickJSRuntime#executePendingJobs}\n   * to execute callbacks pending after synchronous evaluation returns.\n   *\n   * See {@link unwrapResult}, which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use {@link resolvePromise} to convert it to a native promise and\n   * {@link QuickJSRuntime#executePendingJobs} to finish evaluating the promise.\n   *\n   * *Note*: to protect against infinite loops, provide an interrupt handler to\n   * {@link QuickJSRuntime#setInterruptHandler}. You can use {@link shouldInterruptAfterDeadline} to\n   * create a time-based deadline.\n   *\n   * @returns The last statement's value. If the code threw synchronously,\n   * `result.error` will be a handle to the exception. If execution was\n   * interrupted, the error will have name `InternalError` and message\n   * `interrupted`.\n   */\n  evalCode(\n    code: string,\n    filename: string = \"eval.js\",\n    /**\n     * If no options are passed, a heuristic will be used to detect if `code` is\n     * an ES module.\n     *\n     * See {@link EvalFlags} for number semantics.\n     */\n    options?: number | ContextEvalOptions,\n  ): VmCallResult<QuickJSHandle> {\n    const detectModule = (options === undefined ? 1 : 0) as EvalDetectModule\n    const flags = evalOptionsToFlags(options) as EvalFlags\n    const resultPtr = this.memory\n      .newHeapCharPointer(code)\n      .consume((charHandle) =>\n        this.ffi.QTS_Eval(\n          this.ctx.value,\n          charHandle.value.ptr,\n          charHandle.value.strlen,\n          filename,\n          detectModule,\n          flags,\n        ),\n      )\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Throw an error in the VM, interrupted whatever current execution is in progress when execution resumes.\n   * @experimental\n   */\n  throw(error: Error | QuickJSHandle) {\n    return this.errorToHandle(error).consume((handle) =>\n      this.ffi.QTS_Throw(this.ctx.value, handle.value),\n    )\n  }\n\n  /**\n   * @private\n   */\n  protected borrowPropertyKey(key: QuickJSPropertyKey): QuickJSHandle {\n    if (typeof key === \"number\") {\n      return this.newNumber(key)\n    }\n\n    if (typeof key === \"string\") {\n      return this.newString(key)\n    }\n\n    // key is already a JSValue, but we're borrowing it. Return a static handle\n    // for internal use only.\n    return new StaticLifetime(key.value as JSValueConstPointer, this.runtime)\n  }\n\n  /**\n   * @private\n   */\n  getMemory(rt: JSRuntimePointer): ContextMemory {\n    if (rt === this.rt.value) {\n      return this.memory\n    } else {\n      throw new Error(\"Private API. Cannot get memory from a different runtime\")\n    }\n  }\n\n  // Utilities ----------------------------------------------------------------\n\n  /**\n   * Dump a JSValue to Javascript in a best-effort fashion.\n   * If the value is a promise, dumps the promise's state.\n   * Returns `handle.toString()` if it cannot be serialized to JSON.\n   */\n  dump(handle: QuickJSHandle): any {\n    this.runtime.assertOwned(handle)\n    const type = this.typeof(handle)\n    if (type === \"string\") {\n      return this.getString(handle)\n    } else if (type === \"number\") {\n      return this.getNumber(handle)\n    } else if (type === \"bigint\") {\n      return this.getBigInt(handle)\n    } else if (type === \"undefined\") {\n      return undefined\n    } else if (type === \"symbol\") {\n      return this.getSymbol(handle)\n    }\n\n    // It's confusing if we dump(promise) and just get back {} because promise\n    // has no properties, so dump promise state.\n    const asPromiseState = this.getPromiseState(handle)\n    if (asPromiseState.type === \"fulfilled\" && !asPromiseState.notAPromise) {\n      handle.dispose()\n      return { type: asPromiseState.type, value: asPromiseState.value.consume(this.dump) }\n    } else if (asPromiseState.type === \"pending\") {\n      handle.dispose()\n      return { type: asPromiseState.type }\n    } else if (asPromiseState.type === \"rejected\") {\n      handle.dispose()\n      return { type: asPromiseState.type, error: asPromiseState.error.consume(this.dump) }\n    }\n\n    const str = this.memory.consumeJSCharPointer(this.ffi.QTS_Dump(this.ctx.value, handle.value))\n    try {\n      return JSON.parse(str)\n    } catch (err) {\n      return str\n    }\n  }\n\n  /**\n   * Unwrap a SuccessOrFail result such as a {@link VmCallResult} or a\n   * {@link ExecutePendingJobsResult}, where the fail branch contains a handle to a QuickJS error value.\n   * If the result is a success, returns the value.\n   * If the result is an error, converts the error to a native object and throws the error.\n   */\n  unwrapResult<T>(result: SuccessOrFail<T, QuickJSHandle>): T {\n    if (result.error) {\n      const context: QuickJSContext =\n        \"context\" in result.error ? (result.error as { context: QuickJSContext }).context : this\n      const cause = result.error.consume((error) => this.dump(error))\n\n      if (cause && typeof cause === \"object\" && typeof cause.message === \"string\") {\n        const { message, name, stack } = cause\n        const exception = new QuickJSUnwrapError(\"\")\n        const hostStack = exception.stack\n\n        if (typeof name === \"string\") {\n          exception.name = cause.name\n        }\n\n        if (typeof stack === \"string\") {\n          exception.stack = `${name}: ${message}\\n${cause.stack}Host: ${hostStack}`\n        }\n\n        Object.assign(exception, { cause, context, message })\n        throw exception\n      }\n\n      throw new QuickJSUnwrapError(cause, context)\n    }\n\n    return result.value\n  }\n\n  /** @private */\n  protected fnNextId = -32768 // min value of signed 16bit int used by Quickjs\n  /** @private */\n  protected fnMaps = new Map<number, Map<number, VmFunctionImplementation<QuickJSHandle>>>()\n\n  /** @private */\n  protected getFunction(fn_id: number): VmFunctionImplementation<QuickJSHandle> | undefined {\n    const map_id = fn_id >> 8\n    const fnMap = this.fnMaps.get(map_id)\n    if (!fnMap) {\n      return undefined\n    }\n    return fnMap.get(fn_id)\n  }\n\n  /** @private */\n  protected setFunction(fn_id: number, handle: VmFunctionImplementation<QuickJSHandle>) {\n    const map_id = fn_id >> 8\n    let fnMap = this.fnMaps.get(map_id)\n    if (!fnMap) {\n      fnMap = new Map<number, VmFunctionImplementation<QuickJSHandle>>()\n      this.fnMaps.set(map_id, fnMap)\n    }\n    return fnMap.set(fn_id, handle)\n  }\n\n  /**\n   * @hidden\n   */\n  private cToHostCallbacks: ContextCallbacks = {\n    callFunction: (ctx, this_ptr, argc, argv, fn_id) => {\n      if (ctx !== this.ctx.value) {\n        throw new Error(\"QuickJSContext instance received C -> JS call with mismatched ctx\")\n      }\n\n      const fn = this.getFunction(fn_id)\n      if (!fn) {\n        // this \"throw\" is not catch-able from the TS side. could we somehow handle this higher up?\n        throw new Error(`QuickJSContext had no callback with id ${fn_id}`)\n      }\n\n      return Scope.withScopeMaybeAsync(this, function* (awaited, scope) {\n        const thisHandle = scope.manage(\n          new WeakLifetime(\n            this_ptr,\n            this.memory.copyJSValue,\n            this.memory.freeJSValue,\n            this.runtime,\n          ),\n        )\n        const argHandles = new Array<QuickJSHandle>(argc)\n        for (let i = 0; i < argc; i++) {\n          const ptr = this.ffi.QTS_ArgvGetJSValueConstPointer(argv, i)\n          argHandles[i] = scope.manage(\n            new WeakLifetime(ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime),\n          )\n        }\n\n        try {\n          const result = yield* awaited(fn.apply(thisHandle, argHandles))\n          if (result) {\n            if (\"error\" in result && result.error) {\n              debugLog(\"throw error\", result.error)\n              throw result.error\n            }\n            const handle = scope.manage(result instanceof Lifetime ? result : result.value)\n            return this.ffi.QTS_DupValuePointer(this.ctx.value, handle.value)\n          }\n          return 0 as JSValuePointer\n        } catch (error) {\n          return this.errorToHandle(error as Error).consume((errorHandle) =>\n            this.ffi.QTS_Throw(this.ctx.value, errorHandle.value),\n          )\n        }\n      }) as JSValuePointer\n    },\n  }\n\n  private errorToHandle(error: Error | QuickJSHandle): QuickJSHandle {\n    if (error instanceof Lifetime) {\n      return error\n    }\n\n    return this.newError(error)\n  }\n\n  /**\n   * Outputs QuickJS Objects in binary form\n   *\n   * **WARNING**: QuickJS's binary JSON doesn't have a standard so expect it to change between version\n   *\n   * ```ts\n   * // imagine sending data to another via IPC\n   * let dataLifetime = context.newString(\"This is an example\")\n   *  ?.consume(handle => context.encodeBinaryJSON(handle))\n   *  ?.consume(handle => context.getArrayBuffer(handle))\n   * socket.write(dataLifetime?.value)\n   * ```\n   */\n  encodeBinaryJSON(handle: QuickJSHandle): QuickJSHandle {\n    const ptr = this.ffi.QTS_bjson_encode(this.ctx.value, handle.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Outputs Handle of the given QuickJS Object in binary form\n   *\n   * ```ts\n   * // imagine receiving data from another via IPC\n   * socket.on(\"data\", chunk => {\n   *  context.newArrayBuffer(chunk)\n   *    ?.consume(handle => context.decodeBinaryJSON(handle))\n   *    ?.consume(handle => console.log(context.dump(handle)))\n   * })\n   * ```\n   */\n  decodeBinaryJSON(handle: QuickJSHandle): QuickJSHandle {\n    const ptr = this.ffi.QTS_bjson_decode(this.ctx.value, handle.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n}\n","import type {\n  BorrowedHeapCharPointer,\n  JSContextPointer,\n  JSContextPointerPointer,\n  JSRuntimePointer,\n  EitherFFI,\n  EitherModule,\n} from \"@jitl/quickjs-ffi-types\"\nimport { maybeAsyncFn } from \"./asyncify-helpers\"\nimport { QuickJSContext } from \"./context\"\nimport { debugLog } from \"./debug\"\nimport { QuickJSWrongOwner } from \"./errors\"\nimport type { Disposable } from \"./lifetime\"\nimport { Lifetime, Scope, UsingDisposable } from \"./lifetime\"\nimport { ModuleMemory } from \"./memory\"\nimport type { QuickJSModuleCallbacks, RuntimeCallbacks } from \"./module\"\nimport type { ContextOptions, JSModuleLoader, JSModuleNormalizer, QuickJSHandle } from \"./types\"\nimport { intrinsicsToFlags } from \"./types\"\nimport type { SuccessOrFail } from \"./vm-interface\"\n\n/**\n * Callback called regularly while the VM executes code.\n * Determines if a VM's execution should be interrupted.\n *\n * @returns `true` to interrupt JS execution inside the VM.\n * @returns `false` or `undefined` to continue JS execution inside the VM.\n */\nexport type InterruptHandler = (runtime: QuickJSRuntime) => boolean | undefined\n\n/**\n * Used as an optional for the results of executing pendingJobs.\n * On success, `value` contains the number of async jobs executed\n * by the runtime.\n * @source\n */\nexport type ExecutePendingJobsResult = SuccessOrFail<\n  /** Number of jobs successfully executed. */\n  number,\n  /** The error that occurred. */\n  QuickJSHandle & {\n    /** The context where the error occurred. */\n    context: QuickJSContext\n  }\n>\n\n/**\n * A runtime represents a Javascript runtime corresponding to an object heap.\n * Several runtimes can exist at the same time but they cannot exchange objects.\n * Inside a given runtime, no multi-threading is supported.\n *\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain.\n *\n * Create a runtime via {@link QuickJSWASMModule.newRuntime}.\n *\n * You should create separate runtime instances for untrusted code from\n * different sources for isolation. However, stronger isolation is also\n * available (at the cost of memory usage), by creating separate WebAssembly\n * modules to further isolate untrusted code.\n * See {@link newQuickJSWASMModule}.\n *\n * Implement memory and CPU constraints with {@link setInterruptHandler}\n * (called regularly while the interpreter runs), {@link setMemoryLimit}, and\n * {@link setMaxStackSize}.\n * Use {@link computeMemoryUsage} or {@link dumpMemoryUsage} to guide memory limit\n * tuning.\n *\n * Configure ES module loading with {@link setModuleLoader}.\n */\nexport class QuickJSRuntime extends UsingDisposable implements Disposable {\n  /**\n   * If this runtime was created as as part of a context, points to the context\n   * associated with the runtime.\n   *\n   * If this runtime was created stand-alone, this may or may not contain a context.\n   * A context here may be allocated if one is needed by the runtime, eg for {@link computeMemoryUsage}.\n   */\n  public context: QuickJSContext | undefined\n\n  /** @private */\n  protected module: EitherModule\n  /** @private */\n  protected memory: ModuleMemory\n  /** @private */\n  protected ffi: EitherFFI\n  /** @private */\n  protected rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected callbacks: QuickJSModuleCallbacks\n  /** @private */\n  protected scope = new Scope()\n\n  /** @private */\n  protected contextMap = new Map<JSContextPointer, QuickJSContext>()\n  /** @private */\n  protected moduleLoader: JSModuleLoader | undefined\n  /** @private */\n  protected moduleNormalizer: JSModuleNormalizer | undefined\n\n  /** @private */\n  constructor(args: {\n    module: EitherModule\n    ffi: EitherFFI\n    rt: Lifetime<JSRuntimePointer>\n    callbacks: QuickJSModuleCallbacks\n    ownedLifetimes?: Disposable[]\n  }) {\n    super()\n    args.ownedLifetimes?.forEach((lifetime) => this.scope.manage(lifetime))\n    this.module = args.module\n    this.memory = new ModuleMemory(this.module)\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.callbacks = args.callbacks\n    this.scope.manage(this.rt)\n    this.callbacks.setRuntimeCallbacks(this.rt.value, this.cToHostCallbacks)\n\n    this.executePendingJobs = this.executePendingJobs.bind(this)\n  }\n\n  get alive() {\n    return this.scope.alive\n  }\n\n  dispose() {\n    return this.scope.dispose()\n  }\n\n  /**\n   * Create a new context within this runtime. Contexts have isolated globals,\n   * but you can explicitly share objects between contexts with the same\n   * runtime.\n   *\n   * You should dispose a created context before disposing this runtime.\n   */\n  newContext(options: ContextOptions = {}): QuickJSContext {\n    const intrinsics = intrinsicsToFlags(options.intrinsics)\n    const ctx = new Lifetime(\n      options.contextPointer || this.ffi.QTS_NewContext(this.rt.value, intrinsics),\n      undefined,\n      (ctx_ptr) => {\n        this.contextMap.delete(ctx_ptr)\n        this.callbacks.deleteContext(ctx_ptr)\n        this.ffi.QTS_FreeContext(ctx_ptr)\n      },\n    )\n\n    const context = new QuickJSContext({\n      module: this.module,\n      ctx,\n      ffi: this.ffi,\n      rt: this.rt,\n      ownedLifetimes: options.ownedLifetimes,\n      runtime: this,\n      callbacks: this.callbacks,\n    })\n    this.contextMap.set(ctx.value, context)\n\n    return context\n  }\n\n  /**\n   * Set the loader for EcmaScript modules requested by any context in this\n   * runtime.\n   *\n   * The loader can be removed with {@link removeModuleLoader}.\n   */\n  setModuleLoader(moduleLoader: JSModuleLoader, moduleNormalizer?: JSModuleNormalizer): void {\n    this.moduleLoader = moduleLoader\n    this.moduleNormalizer = moduleNormalizer\n    this.ffi.QTS_RuntimeEnableModuleLoader(this.rt.value, this.moduleNormalizer ? 1 : 0)\n  }\n\n  /**\n   * Remove the the loader set by {@link setModuleLoader}. This disables module loading.\n   */\n  removeModuleLoader(): void {\n    this.moduleLoader = undefined\n    this.ffi.QTS_RuntimeDisableModuleLoader(this.rt.value)\n  }\n\n  // Runtime management -------------------------------------------------------\n\n  /**\n   * In QuickJS, promises and async functions create pendingJobs. These do not execute\n   * immediately and need to be run by calling {@link executePendingJobs}.\n   *\n   * @return true if there is at least one pendingJob queued up.\n   */\n  hasPendingJob(): boolean {\n    return Boolean(this.ffi.QTS_IsJobPending(this.rt.value))\n  }\n\n  private interruptHandler: InterruptHandler | undefined\n\n  /**\n   * Set a callback which is regularly called by the QuickJS engine when it is\n   * executing code. This callback can be used to implement an execution\n   * timeout.\n   *\n   * The interrupt handler can be removed with {@link removeInterruptHandler}.\n   */\n  setInterruptHandler(cb: InterruptHandler) {\n    const prevInterruptHandler = this.interruptHandler\n    this.interruptHandler = cb\n    if (!prevInterruptHandler) {\n      this.ffi.QTS_RuntimeEnableInterruptHandler(this.rt.value)\n    }\n  }\n\n  /**\n   * Remove the interrupt handler, if any.\n   * See {@link setInterruptHandler}.\n   */\n  removeInterruptHandler() {\n    if (this.interruptHandler) {\n      this.ffi.QTS_RuntimeDisableInterruptHandler(this.rt.value)\n      this.interruptHandler = undefined\n    }\n  }\n\n  /**\n   * Execute pendingJobs on the runtime until `maxJobsToExecute` jobs are\n   * executed (default all pendingJobs), the queue is exhausted, or the runtime\n   * encounters an exception.\n   *\n   * In QuickJS, promises and async functions *inside the runtime* create\n   * pendingJobs. These do not execute immediately and need to triggered to run.\n   *\n   * @param maxJobsToExecute - When negative, run all pending jobs. Otherwise execute\n   * at most `maxJobsToExecute` before returning.\n   *\n   * @return On success, the number of executed jobs. On error, the exception\n   * that stopped execution, and the context it occurred in. Note that\n   * executePendingJobs will not normally return errors thrown inside async\n   * functions or rejected promises. Those errors are available by calling\n   * {@link QuickJSContext#resolvePromise} on the promise handle returned by the async function.\n   */\n  executePendingJobs(maxJobsToExecute: number | void = -1): ExecutePendingJobsResult {\n    const ctxPtrOut = this.memory.newMutablePointerArray<JSContextPointerPointer>(1)\n    const valuePtr = this.ffi.QTS_ExecutePendingJob(\n      this.rt.value,\n      maxJobsToExecute ?? -1,\n      ctxPtrOut.value.ptr,\n    )\n\n    const ctxPtr = ctxPtrOut.value.typedArray[0] as JSContextPointer\n    ctxPtrOut.dispose()\n    if (ctxPtr === 0) {\n      // No jobs executed.\n      this.ffi.QTS_FreeValuePointerRuntime(this.rt.value, valuePtr)\n      return { value: 0 }\n    }\n\n    const context =\n      this.contextMap.get(ctxPtr) ??\n      this.newContext({\n        contextPointer: ctxPtr,\n      })\n\n    const resultValue = context.getMemory(this.rt.value).heapValueHandle(valuePtr)\n    const typeOfRet = context.typeof(resultValue)\n    if (typeOfRet === \"number\") {\n      const executedJobs = context.getNumber(resultValue)\n      resultValue.dispose()\n      return { value: executedJobs }\n    } else {\n      const error = Object.assign(resultValue, { context })\n      return {\n        error,\n      }\n    }\n  }\n\n  /**\n   * Set the max memory this runtime can allocate.\n   * To remove the limit, set to `-1`.\n   */\n  setMemoryLimit(limitBytes: number) {\n    if (limitBytes < 0 && limitBytes !== -1) {\n      throw new Error(\"Cannot set memory limit to negative number. To unset, pass -1\")\n    }\n\n    this.ffi.QTS_RuntimeSetMemoryLimit(this.rt.value, limitBytes)\n  }\n\n  /**\n   * Compute memory usage for this runtime. Returns the result as a handle to a\n   * JSValue object. Use {@link QuickJSContext#dump} to convert to a native object.\n   * Calling this method will allocate more memory inside the runtime. The information\n   * is accurate as of just before the call to `computeMemoryUsage`.\n   * For a human-digestible representation, see {@link dumpMemoryUsage}.\n   */\n  computeMemoryUsage(): QuickJSHandle {\n    const serviceContextMemory = this.getSystemContext().getMemory(this.rt.value)\n    return serviceContextMemory.heapValueHandle(\n      this.ffi.QTS_RuntimeComputeMemoryUsage(this.rt.value, serviceContextMemory.ctx.value),\n    )\n  }\n\n  /**\n   * @returns a human-readable description of memory usage in this runtime.\n   * For programmatic access to this information, see {@link computeMemoryUsage}.\n   */\n  dumpMemoryUsage(): string {\n    return this.memory.consumeHeapCharPointer(this.ffi.QTS_RuntimeDumpMemoryUsage(this.rt.value))\n  }\n\n  /**\n   * Set the max stack size for this runtime, in bytes.\n   * To remove the limit, set to `0`.\n   */\n  setMaxStackSize(stackSize: number) {\n    if (stackSize < 0) {\n      throw new Error(\"Cannot set memory limit to negative number. To unset, pass 0.\")\n    }\n\n    this.ffi.QTS_RuntimeSetMaxStackSize(this.rt.value, stackSize)\n  }\n\n  /**\n   * Assert that `handle` is owned by this runtime.\n   * @throws QuickJSWrongOwner if owned by a different runtime.\n   */\n  assertOwned(handle: QuickJSHandle) {\n    if (handle.owner && handle.owner.rt !== this.rt) {\n      throw new QuickJSWrongOwner(\n        `Handle is not owned by this runtime: ${handle.owner.rt.value} != ${this.rt.value}`,\n      )\n    }\n  }\n\n  private getSystemContext() {\n    if (!this.context) {\n      // We own this context and should dispose of it.\n      this.context = this.scope.manage(this.newContext())\n    }\n    return this.context\n  }\n\n  private cToHostCallbacks: RuntimeCallbacks = {\n    shouldInterrupt: (rt) => {\n      if (rt !== this.rt.value) {\n        throw new Error(\"QuickJSContext instance received C -> JS interrupt with mismatched rt\")\n      }\n\n      const fn = this.interruptHandler\n      if (!fn) {\n        throw new Error(\"QuickJSContext had no interrupt handler\")\n      }\n\n      return fn(this) ? 1 : 0\n    },\n\n    loadModuleSource: maybeAsyncFn(this, function* (awaited, rt, ctx, moduleName) {\n      const moduleLoader = this.moduleLoader\n      if (!moduleLoader) {\n        throw new Error(\"Runtime has no module loader\")\n      }\n\n      if (rt !== this.rt.value) {\n        throw new Error(\"Runtime pointer mismatch\")\n      }\n\n      const context =\n        this.contextMap.get(ctx) ??\n        this.newContext({\n          contextPointer: ctx,\n        })\n\n      try {\n        const result = yield* awaited(moduleLoader(moduleName, context))\n\n        if (typeof result === \"object\" && \"error\" in result && result.error) {\n          debugLog(\"cToHostLoadModule: loader returned error\", result.error)\n          throw result.error\n        }\n\n        const moduleSource =\n          typeof result === \"string\" ? result : \"value\" in result ? result.value : result\n\n        return this.memory.newHeapCharPointer(moduleSource).value.ptr\n      } catch (error) {\n        debugLog(\"cToHostLoadModule: caught error\", error)\n        context.throw(error as any)\n        return 0 as BorrowedHeapCharPointer\n      }\n    }),\n\n    normalizeModule: maybeAsyncFn(\n      this,\n      function* (awaited, rt, ctx, baseModuleName, moduleNameRequest) {\n        const moduleNormalizer = this.moduleNormalizer\n        if (!moduleNormalizer) {\n          throw new Error(\"Runtime has no module normalizer\")\n        }\n\n        if (rt !== this.rt.value) {\n          throw new Error(\"Runtime pointer mismatch\")\n        }\n\n        const context: QuickJSContext =\n          this.contextMap.get(ctx) ??\n          this.newContext({\n            /* TODO: Does this happen? Are we responsible for disposing? I don't think so */\n            contextPointer: ctx,\n          })\n\n        try {\n          const result = yield* awaited(\n            moduleNormalizer(baseModuleName, moduleNameRequest, context),\n          )\n\n          if (typeof result === \"object\" && \"error\" in result && result.error) {\n            debugLog(\"cToHostNormalizeModule: normalizer returned error\", result.error)\n            throw result.error\n          }\n\n          const name = typeof result === \"string\" ? result : result.value\n          return context.getMemory(this.rt.value).newHeapCharPointer(name).value.ptr\n        } catch (error) {\n          debugLog(\"normalizeModule: caught error\", error)\n          context.throw(error as any)\n          return 0 as BorrowedHeapCharPointer\n        }\n      },\n    ),\n  }\n}\n","import type {\n  Asyncify,\n  AsyncifySleepResult,\n  EitherModule,\n  EmscriptenModuleCallbacks,\n  BorrowedHeapCharPointer,\n  JSContextPointer,\n  JSRuntimePointer,\n  JSValuePointer,\n  EitherFFI,\n} from \"@jitl/quickjs-ffi-types\"\nimport type { QuickJSContext } from \"./context\"\nimport { debugLog } from \"./debug\"\nimport { QuickJSAsyncifyError, QuickJSAsyncifySuspended } from \"./errors\"\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { CustomizeVariantOptions } from \"./from-variant\"\nimport { Lifetime, Scope } from \"./lifetime\"\nimport type { InterruptHandler } from \"./runtime\"\nimport { QuickJSRuntime } from \"./runtime\"\nimport type { ContextOptions, JSModuleLoader, RuntimeOptions, RuntimeOptionsBase } from \"./types\"\nimport { concat } from \"./types\"\n\ntype EmscriptenCallback<BaseArgs extends any[], Result> = (\n  ...args: [Asyncify | undefined, ...BaseArgs]\n) => Result | AsyncifySleepResult<Result>\ntype MaybeAsyncEmscriptenCallback<T extends EmscriptenCallback<any, any>> =\n  T extends EmscriptenCallback<infer Args, infer Result>\n    ? (...args: Args) => Result | Promise<Result>\n    : never\ntype MaybeAsyncEmscriptenCallbacks = {\n  [K in keyof EmscriptenModuleCallbacks]: MaybeAsyncEmscriptenCallback<EmscriptenModuleCallbacks[K]>\n}\n\n/**\n * @private\n */\nexport interface ContextCallbacks {\n  callFunction: MaybeAsyncEmscriptenCallbacks[\"callFunction\"]\n}\n\n/**\n * @private\n */\nexport interface RuntimeCallbacks {\n  shouldInterrupt: MaybeAsyncEmscriptenCallbacks[\"shouldInterrupt\"]\n  loadModuleSource: MaybeAsyncEmscriptenCallbacks[\"loadModuleSource\"]\n  normalizeModule: MaybeAsyncEmscriptenCallbacks[\"normalizeModule\"]\n}\n\nclass QuickJSEmscriptenModuleCallbacks implements EmscriptenModuleCallbacks {\n  public callFunction: EmscriptenModuleCallbacks[\"callFunction\"]\n  public shouldInterrupt: EmscriptenModuleCallbacks[\"shouldInterrupt\"]\n  public loadModuleSource: EmscriptenModuleCallbacks[\"loadModuleSource\"]\n  public normalizeModule: EmscriptenModuleCallbacks[\"normalizeModule\"]\n  constructor(args: EmscriptenModuleCallbacks) {\n    this.callFunction = args.callFunction\n    this.shouldInterrupt = args.shouldInterrupt\n    this.loadModuleSource = args.loadModuleSource\n    this.normalizeModule = args.normalizeModule\n  }\n}\n\n/**\n * Options for {@link QuickJSWASMModule#evalCode}.\n */\nexport interface ModuleEvalOptions {\n  /**\n   * Interrupt evaluation if `shouldInterrupt` returns `true`.\n   * See {@link shouldInterruptAfterDeadline}.\n   */\n  shouldInterrupt?: InterruptHandler\n\n  /**\n   * Memory limit, in bytes, of WebAssembly heap memory used by the QuickJS VM.\n   */\n  memoryLimitBytes?: number\n\n  /**\n   * Stack size limit for this vm, in bytes\n   * To remove the limit, set to `0`.\n   */\n  maxStackSizeBytes?: number\n\n  /**\n   * Module loader for any `import` statements or expressions.\n   */\n  moduleLoader?: JSModuleLoader\n}\n\n/**\n * We use static functions per module to dispatch runtime or context calls from\n * C to the host.  This class manages the indirection from a specific runtime or\n * context pointer to the appropriate callback handler.\n *\n * @private\n */\nexport class QuickJSModuleCallbacks {\n  private module: EitherModule\n  private contextCallbacks = new Map<JSContextPointer, ContextCallbacks>()\n  private runtimeCallbacks = new Map<JSRuntimePointer, RuntimeCallbacks>()\n\n  constructor(module: EitherModule) {\n    this.module = module\n    this.module.callbacks = this.cToHostCallbacks\n  }\n\n  setRuntimeCallbacks(rt: JSRuntimePointer, callbacks: RuntimeCallbacks) {\n    this.runtimeCallbacks.set(rt, callbacks)\n  }\n\n  deleteRuntime(rt: JSRuntimePointer) {\n    this.runtimeCallbacks.delete(rt)\n  }\n\n  setContextCallbacks(ctx: JSContextPointer, callbacks: ContextCallbacks) {\n    this.contextCallbacks.set(ctx, callbacks)\n  }\n\n  deleteContext(ctx: JSContextPointer) {\n    this.contextCallbacks.delete(ctx)\n  }\n\n  private suspendedCount = 0\n  private suspended: QuickJSAsyncifySuspended | undefined\n\n  private handleAsyncify<T>(\n    asyncify: Asyncify | undefined,\n    fn: () => T | Promise<T>,\n  ): T | AsyncifySleepResult<T> {\n    if (asyncify) {\n      // We must always call asyncify.handleSync around our function.\n      // This allows asyncify to resume suspended execution on the second call.\n      // Asyncify internally can detect sync behavior, and avoid suspending.\n      return asyncify.handleSleep((done) => {\n        try {\n          const result = fn()\n          if (!(result instanceof Promise)) {\n            debugLog(\"asyncify.handleSleep: not suspending:\", result)\n            done(result)\n            return\n          }\n\n          // Is promise, we intend to suspend.\n          if (this.suspended) {\n            throw new QuickJSAsyncifyError(\n              `Already suspended at: ${this.suspended.stack}\\nAttempted to suspend at:`,\n            )\n          } else {\n            this.suspended = new QuickJSAsyncifySuspended(`(${this.suspendedCount++})`)\n            debugLog(\"asyncify.handleSleep: suspending:\", this.suspended)\n          }\n\n          result.then(\n            (resolvedResult) => {\n              this.suspended = undefined\n              debugLog(\"asyncify.handleSleep: resolved:\", resolvedResult)\n              done(resolvedResult)\n            },\n            (error) => {\n              debugLog(\"asyncify.handleSleep: rejected:\", error)\n              console.error(\"QuickJS: cannot handle error in suspended function\", error)\n              this.suspended = undefined\n            },\n          )\n        } catch (error) {\n          debugLog(\"asyncify.handleSleep: error:\", error)\n          this.suspended = undefined\n          throw error\n        }\n      })\n    }\n\n    // No asyncify - we should never return a promise.\n    const value = fn()\n    if (value instanceof Promise) {\n      throw new Error(\"Promise return value not supported in non-asyncify context.\")\n    }\n    return value\n  }\n\n  private cToHostCallbacks = new QuickJSEmscriptenModuleCallbacks({\n    callFunction: (asyncify, ctx, this_ptr, argc, argv, fn_id) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const vm = this.contextCallbacks.get(ctx)\n          if (!vm) {\n            throw new Error(`QuickJSContext(ctx = ${ctx}) not found for C function call \"${fn_id}\"`)\n          }\n          return vm.callFunction(ctx, this_ptr, argc, argv, fn_id)\n        } catch (error) {\n          console.error(\"[C to host error: returning null]\", error)\n          return 0 as JSValuePointer\n        }\n      }),\n\n    shouldInterrupt: (asyncify, rt) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const vm = this.runtimeCallbacks.get(rt)\n          if (!vm) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C interrupt`)\n          }\n          return vm.shouldInterrupt(rt)\n        } catch (error) {\n          console.error(\"[C to host interrupt: returning error]\", error)\n          return 1\n        }\n      }),\n\n    loadModuleSource: (asyncify, rt, ctx, moduleName) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const runtimeCallbacks = this.runtimeCallbacks.get(rt)\n          if (!runtimeCallbacks) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`)\n          }\n\n          const loadModule = runtimeCallbacks.loadModuleSource\n          if (!loadModule) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`)\n          }\n          return loadModule(rt, ctx, moduleName)\n        } catch (error) {\n          console.error(\"[C to host module loader error: returning null]\", error)\n          return 0 as BorrowedHeapCharPointer\n        }\n      }),\n\n    normalizeModule: (asyncify, rt, ctx, moduleBaseName, moduleName) =>\n      this.handleAsyncify(asyncify, () => {\n        try {\n          const runtimeCallbacks = this.runtimeCallbacks.get(rt)\n          if (!runtimeCallbacks) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`)\n          }\n\n          const normalizeModule = runtimeCallbacks.normalizeModule\n          if (!normalizeModule) {\n            throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`)\n          }\n          return normalizeModule(rt, ctx, moduleBaseName, moduleName)\n        } catch (error) {\n          console.error(\"[C to host module loader error: returning null]\", error)\n          return 0 as BorrowedHeapCharPointer\n        }\n      }),\n  })\n}\n\n/**\n * Process RuntimeOptions and apply them to a QuickJSRuntime.\n * @private\n */\nexport function applyBaseRuntimeOptions(\n  runtime: QuickJSRuntime,\n  options: RuntimeOptionsBase,\n): void {\n  if (options.interruptHandler) {\n    runtime.setInterruptHandler(options.interruptHandler)\n  }\n\n  if (options.maxStackSizeBytes !== undefined) {\n    runtime.setMaxStackSize(options.maxStackSizeBytes)\n  }\n\n  if (options.memoryLimitBytes !== undefined) {\n    runtime.setMemoryLimit(options.memoryLimitBytes)\n  }\n}\n\n/**\n * Process ModuleEvalOptions and apply them to a QuickJSRuntime.\n * @private\n */\nexport function applyModuleEvalRuntimeOptions<T extends QuickJSRuntime>(\n  runtime: T,\n  options: ModuleEvalOptions,\n) {\n  if (options.moduleLoader) {\n    runtime.setModuleLoader(options.moduleLoader)\n  }\n\n  if (options.shouldInterrupt) {\n    runtime.setInterruptHandler(options.shouldInterrupt)\n  }\n\n  if (options.memoryLimitBytes !== undefined) {\n    runtime.setMemoryLimit(options.memoryLimitBytes)\n  }\n\n  if (options.maxStackSizeBytes !== undefined) {\n    runtime.setMaxStackSize(options.maxStackSizeBytes)\n  }\n}\n\n/**\n * This class presents a Javascript interface to QuickJS, a Javascript interpreter\n * that supports EcmaScript 2020 (ES2020).\n *\n * It wraps a single WebAssembly module containing the QuickJS library and\n * associated helper C code. WebAssembly modules are completely isolated from\n * each other by the host's WebAssembly runtime. Separate WebAssembly modules\n * have the most isolation guarantees possible with this library.\n *\n * The simplest way to start running code is {@link evalCode}. This shortcut\n * method will evaluate Javascript safely and return the result as a native\n * Javascript value.\n *\n * For more control over the execution environment, or to interact with values\n * inside QuickJS, create a context with {@link newContext} or a runtime with\n * {@link newRuntime}.\n */\nexport class QuickJSWASMModule {\n  /** @private */\n  protected ffi: EitherFFI\n  /** @private */\n  protected callbacks: QuickJSModuleCallbacks\n  /** @private */\n  protected module: EitherModule\n\n  /** @private */\n  constructor(module: EitherModule, ffi: EitherFFI) {\n    this.module = module\n    this.ffi = ffi\n    this.callbacks = new QuickJSModuleCallbacks(module)\n  }\n\n  /**\n   * Create a runtime.\n   * Use the runtime to set limits on CPU and memory usage and configure module\n   * loading for one or more {@link QuickJSContext}s inside the runtime.\n   */\n  newRuntime(options: RuntimeOptions = {}): QuickJSRuntime {\n    const rt = new Lifetime(this.ffi.QTS_NewRuntime(), undefined, (rt_ptr) => {\n      this.callbacks.deleteRuntime(rt_ptr)\n      this.ffi.QTS_FreeRuntime(rt_ptr)\n    })\n\n    const runtime = new QuickJSRuntime({\n      module: this.module,\n      callbacks: this.callbacks,\n      ffi: this.ffi,\n      rt,\n    })\n\n    applyBaseRuntimeOptions(runtime, options)\n\n    if (options.moduleLoader) {\n      runtime.setModuleLoader(options.moduleLoader)\n    }\n\n    return runtime\n  }\n\n  /**\n   * A simplified API to create a new {@link QuickJSRuntime} and a\n   * {@link QuickJSContext} inside that runtime at the same time. The runtime will\n   * be disposed when the context is disposed.\n   */\n  newContext(options: ContextOptions = {}): QuickJSContext {\n    const runtime = this.newRuntime()\n    const context = runtime.newContext({\n      ...options,\n      ownedLifetimes: concat(runtime, options.ownedLifetimes),\n    })\n    runtime.context = context\n    return context\n  }\n\n  /**\n   * One-off evaluate code without needing to create a {@link QuickJSRuntime} or\n   * {@link QuickJSContext} explicitly.\n   *\n   * To protect against infinite loops, use the `shouldInterrupt` option. The\n   * {@link shouldInterruptAfterDeadline} function will create a time-based deadline.\n   *\n   * If you need more control over how the code executes, create a\n   * {@link QuickJSRuntime} (with {@link newRuntime}) or a {@link QuickJSContext} (with\n   * {@link newContext} or {@link QuickJSRuntime#newContext}), and use its\n   * {@link QuickJSContext#evalCode} method.\n   *\n   * Asynchronous callbacks may not run during the first call to `evalCode`. If\n   * you need to work with async code inside QuickJS, create a runtime and use\n   * {@link QuickJSRuntime#executePendingJobs}.\n   *\n   * @returns The result is coerced to a native Javascript value using JSON\n   * serialization, so properties and values unsupported by JSON will be dropped.\n   *\n   * @throws If `code` throws during evaluation, the exception will be\n   * converted into a native Javascript value and thrown.\n   *\n   * @throws if `options.shouldInterrupt` interrupted execution, will throw a Error\n   * with name `\"InternalError\"` and  message `\"interrupted\"`.\n   */\n  evalCode(code: string, options: ModuleEvalOptions = {}): unknown {\n    return Scope.withScope((scope) => {\n      const vm = scope.manage(this.newContext())\n\n      applyModuleEvalRuntimeOptions(vm.runtime, options)\n      const result = vm.evalCode(code, \"eval.js\")\n\n      if (options.memoryLimitBytes !== undefined) {\n        // Remove memory limit so we can dump the result without exceeding it.\n        vm.runtime.setMemoryLimit(-1)\n      }\n\n      if (result.error) {\n        const error = vm.dump(scope.manage(result.error))\n        throw error\n      }\n\n      const value = vm.dump(scope.manage(result.value))\n      return value\n    })\n  }\n\n  /**\n   * Retrieve the WebAssembly memory used by this QuickJS module.\n   * Use this access very carefully - you are responsible for safe interaction with the memory.\n   *\n   * To supply a custom, pre-initialized memory to QuickJS, create a new variant\n   * and provide the {@link CustomizeVariantOptions#wasmMemory} option.\n   *\n   * @experimental\n   */\n  getWasmMemory(): WebAssembly.Memory {\n    const extensions = this.module.quickjsEmscriptenInit?.(() => {})\n    const memory = extensions?.getWasmMemory?.()\n    if (!memory) {\n      throw new Error(`Variant does not support getting WebAssembly.Memory`)\n    }\n    return memory\n  }\n\n  /**\n   * Get a low-level interface to the QuickJS functions in this WebAssembly\n   * module.\n   * @experimental\n   * @unstable No warranty is provided with this API. It could change at any time.\n   * @private\n   */\n  getFFI(): EitherFFI {\n    return this.ffi\n  }\n}\n","import type {\n  QuickJSAsyncEmscriptenModule,\n  QuickJSAsyncFFI,\n  EvalDetectModule,\n  EvalFlags,\n  JSRuntimePointer,\n  JSValuePointer,\n} from \"@jitl/quickjs-ffi-types\"\nimport { QuickJSContext } from \"./context\"\nimport { debugLog } from \"./debug\"\nimport type { Lifetime } from \"./lifetime\"\nimport type { QuickJSModuleCallbacks } from \"./module\"\nimport type { QuickJSAsyncRuntime } from \"./runtime-asyncify\"\nimport type { ContextEvalOptions, QuickJSHandle } from \"./types\"\nimport { evalOptionsToFlags } from \"./types\"\nimport type { VmCallResult } from \"./vm-interface\"\n\nexport type AsyncFunctionImplementation = (\n  this: QuickJSHandle,\n  ...args: QuickJSHandle[]\n) => Promise<QuickJSHandle | VmCallResult<QuickJSHandle> | void>\n\n/**\n * Asyncified version of {@link QuickJSContext}.\n *\n * *Asyncify* allows normally synchronous code to wait for asynchronous Promises\n * or callbacks. The asyncified version of QuickJSContext can wait for async\n * host functions as though they were synchronous.\n */\nexport class QuickJSAsyncContext extends QuickJSContext {\n  public declare runtime: QuickJSAsyncRuntime\n  /** @private */\n  protected declare module: QuickJSAsyncEmscriptenModule\n  /** @private */\n  protected declare ffi: QuickJSAsyncFFI\n  /** @private */\n  protected declare rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected declare callbacks: QuickJSModuleCallbacks\n\n  /**\n   * Asyncified version of {@link evalCode}.\n   */\n  async evalCodeAsync(\n    code: string,\n    filename: string = \"eval.js\",\n    /** See {@link EvalFlags} for number semantics */\n    options?: number | ContextEvalOptions,\n  ): Promise<VmCallResult<QuickJSHandle>> {\n    const detectModule = (options === undefined ? 1 : 0) as EvalDetectModule\n    const flags = evalOptionsToFlags(options) as EvalFlags\n    let resultPtr = 0 as JSValuePointer\n    try {\n      resultPtr = await this.memory\n        .newHeapCharPointer(code)\n        .consume((charHandle) =>\n          this.ffi.QTS_Eval_MaybeAsync(\n            this.ctx.value,\n            charHandle.value.ptr,\n            charHandle.value.strlen,\n            filename,\n            detectModule,\n            flags,\n          ),\n        )\n    } catch (error) {\n      debugLog(\"QTS_Eval_MaybeAsync threw\", error)\n      throw error\n    }\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Similar to {@link newFunction}.\n   * Convert an async host Javascript function into a synchronous QuickJS function value.\n   *\n   * Whenever QuickJS calls this function, the VM's stack will be unwound while\n   * waiting the async function to complete, and then restored when the returned\n   * promise resolves.\n   *\n   * Asyncified functions must never call other asyncified functions or\n   * `import`, even indirectly, because the stack cannot be unwound twice.\n   *\n   * See [Emscripten's docs on Asyncify](https://emscripten.org/docs/porting/asyncify.html).\n   */\n  newAsyncifiedFunction(name: string, fn: AsyncFunctionImplementation): QuickJSHandle {\n    return this.newFunction(name, fn as any)\n  }\n}\n","import type {\n  QuickJSAsyncEmscriptenModule,\n  QuickJSAsyncFFI,\n  JSContextPointer,\n  JSRuntimePointer,\n} from \"@jitl/quickjs-ffi-types\"\nimport { QuickJSAsyncContext } from \"./context-asyncify\"\nimport type {\n  // Used in doc\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  QuickJSAsyncWASMModule,\n} from \"./module-asyncify\"\nimport type { QuickJSModuleCallbacks } from \"./module\"\nimport { QuickJSRuntime } from \"./runtime\"\nimport type {\n  ContextOptions,\n  JSModuleLoader,\n  JSModuleLoaderAsync,\n  JSModuleNormalizer,\n  JSModuleNormalizerAsync,\n} from \"./types\"\nimport { intrinsicsToFlags } from \"./types\"\nimport { Lifetime } from \"./lifetime\"\n\nexport class QuickJSAsyncRuntime extends QuickJSRuntime {\n  public declare context: QuickJSAsyncContext | undefined\n\n  /** @private */\n  protected declare module: QuickJSAsyncEmscriptenModule\n  /** @private */\n  protected declare ffi: QuickJSAsyncFFI\n  /** @private */\n  protected declare rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected declare callbacks: QuickJSModuleCallbacks\n  /** @private */\n  protected declare contextMap: Map<JSContextPointer, QuickJSAsyncContext>\n\n  /** @private */\n  constructor(args: {\n    module: QuickJSAsyncEmscriptenModule\n    ffi: QuickJSAsyncFFI\n    rt: Lifetime<JSRuntimePointer>\n    callbacks: QuickJSModuleCallbacks\n  }) {\n    super(args)\n  }\n\n  override newContext(options: ContextOptions = {}): QuickJSAsyncContext {\n    const intrinsics = intrinsicsToFlags(options.intrinsics)\n    const ctx = new Lifetime(\n      this.ffi.QTS_NewContext(this.rt.value, intrinsics),\n      undefined,\n      (ctx_ptr) => {\n        this.contextMap.delete(ctx_ptr)\n        this.callbacks.deleteContext(ctx_ptr)\n        this.ffi.QTS_FreeContext(ctx_ptr)\n      },\n    )\n\n    const context = new QuickJSAsyncContext({\n      module: this.module,\n      ctx,\n      ffi: this.ffi,\n      rt: this.rt,\n      ownedLifetimes: [],\n      runtime: this,\n      callbacks: this.callbacks,\n    })\n    this.contextMap.set(ctx.value, context)\n\n    return context\n  }\n\n  public override setModuleLoader(\n    moduleLoader: JSModuleLoaderAsync,\n    moduleNormalizer?: JSModuleNormalizerAsync,\n  ): void {\n    super.setModuleLoader(\n      moduleLoader as JSModuleLoader,\n      moduleNormalizer as JSModuleNormalizer | undefined,\n    )\n  }\n\n  /**\n   * Set the max stack size for this runtime in bytes.\n   * To remove the limit, set to `0`.\n   *\n   * Setting this limit also adjusts the global `ASYNCIFY_STACK_SIZE` for the entire {@link QuickJSAsyncWASMModule}.\n   * See the [pull request](https://github.com/justjake/quickjs-emscripten/pull/114) for more details.\n   */\n  public override setMaxStackSize(stackSize: number): void {\n    return super.setMaxStackSize(stackSize)\n  }\n}\n","import type { QuickJSAsyncEmscriptenModule, QuickJSAsyncFFI } from \"@jitl/quickjs-ffi-types\"\nimport type { QuickJSAsyncContext } from \"./context-asyncify\"\nimport { QuickJSNotImplemented } from \"./errors\"\nimport { Lifetime, Scope } from \"./lifetime\"\nimport type { ModuleEvalOptions } from \"./module\"\nimport { applyBaseRuntimeOptions, applyModuleEvalRuntimeOptions, QuickJSWASMModule } from \"./module\"\nimport { QuickJSAsyncRuntime } from \"./runtime-asyncify\"\nimport type { AsyncRuntimeOptions, ContextOptions } from \"./types\"\n\n/**\n * Asyncified version of {@link QuickJSWASMModule}.\n *\n * Due to limitations of Emscripten's ASYNCIFY process, only a single async\n * function call can happen at a time across the entire WebAssembly module.\n *\n * That means that all runtimes, contexts, functions, etc created inside this\n * WebAssembly are limited to a single concurrent async action.\n * **Multiple concurrent async actions is an error.**\n *\n * To allow for multiple concurrent async actions, you must create multiple WebAssembly\n * modules.\n */\nexport class QuickJSAsyncWASMModule extends QuickJSWASMModule {\n  /** @private */\n  protected ffi: QuickJSAsyncFFI\n  /** @private */\n  protected module: QuickJSAsyncEmscriptenModule\n\n  /** @private */\n  constructor(module: QuickJSAsyncEmscriptenModule, ffi: QuickJSAsyncFFI) {\n    super(module, ffi)\n    this.ffi = ffi\n    this.module = module\n  }\n\n  /**\n   * Create a new async runtime inside this WebAssembly module. All runtimes inside a\n   * module are limited to a single async call at a time. For multiple\n   * concurrent async actions, create multiple WebAssembly modules.\n   */\n  override newRuntime(options: AsyncRuntimeOptions = {}): QuickJSAsyncRuntime {\n    const rt = new Lifetime(this.ffi.QTS_NewRuntime(), undefined, (rt_ptr) => {\n      this.callbacks.deleteRuntime(rt_ptr)\n      this.ffi.QTS_FreeRuntime(rt_ptr)\n    })\n    const runtime = new QuickJSAsyncRuntime({\n      module: this.module,\n      ffi: this.ffi,\n      rt,\n      callbacks: this.callbacks,\n    })\n\n    applyBaseRuntimeOptions(runtime, options)\n\n    if (options.moduleLoader) {\n      runtime.setModuleLoader(options.moduleLoader)\n    }\n\n    return runtime\n  }\n\n  /**\n   * A simplified API to create a new {@link QuickJSAsyncRuntime} and a\n   * {@link QuickJSAsyncContext} inside that runtime at the same time. The runtime will\n   * be disposed when the context is disposed.\n   */\n  override newContext(options: ContextOptions = {}): QuickJSAsyncContext {\n    const runtime = this.newRuntime()\n    const lifetimes = options.ownedLifetimes ? options.ownedLifetimes.concat([runtime]) : [runtime]\n    const context = runtime.newContext({ ...options, ownedLifetimes: lifetimes })\n    runtime.context = context\n    return context\n  }\n\n  /** Synchronous evalCode is not supported. */\n  override evalCode(): never {\n    throw new QuickJSNotImplemented(\"QuickJSWASMModuleAsyncify.evalCode: use evalCodeAsync instead\")\n  }\n\n  /**\n   * One-off evaluate code without needing to create a {@link QuickJSAsyncRuntime} or\n   * {@link QuickJSAsyncContext} explicitly.\n   *\n   * This version allows for asynchronous Ecmascript module loading.\n   *\n   * Note that only a single async action can occur at a time inside the entire WebAssembly module.\n   * **Multiple concurrent async actions is an error.**\n   *\n   * See the documentation for {@link QuickJSWASMModule#evalCode} for more details.\n   */\n  evalCodeAsync(code: string, options: ModuleEvalOptions): Promise<unknown> {\n    // TODO: we should really figure out generator for the Promise monad...\n    return Scope.withScopeAsync(async (scope) => {\n      const vm = scope.manage(this.newContext())\n      applyModuleEvalRuntimeOptions(vm.runtime, options)\n      const result = await vm.evalCodeAsync(code, \"eval.js\")\n\n      if (options.memoryLimitBytes !== undefined) {\n        // Remove memory limit so we can dump the result without exceeding it.\n        vm.runtime.setMemoryLimit(-1)\n      }\n\n      if (result.error) {\n        const error = vm.dump(scope.manage(result.error))\n        throw error\n      }\n\n      const value = vm.dump(scope.manage(result.value))\n      return value\n    })\n  }\n}\n","export * from \"@jitl/quickjs-ffi-types\"\n\n// Sync classes\nexport { QuickJSWASMModule } from \"./module\"\nexport { QuickJSContext } from \"./context\"\nexport { QuickJSRuntime, InterruptHandler, ExecutePendingJobsResult } from \"./runtime\"\n\n// Async classes\nexport { QuickJSAsyncWASMModule } from \"./module-asyncify\"\nexport { QuickJSAsyncRuntime } from \"./runtime-asyncify\"\nexport { QuickJSAsyncContext, AsyncFunctionImplementation } from \"./context-asyncify\"\n\n// Build variants\nexport * from \"./from-variant\"\n\n// Export helpers\nexport * from \"./vm-interface\"\nexport * from \"./lifetime\"\nexport * from \"./interrupt-helpers\"\n/** Collects the informative errors this library may throw. */\nexport * as errors from \"./errors\"\nexport * from \"./deferred-promise\"\nexport * from \"./module-test\"\nexport type {\n  StaticJSValue,\n  JSValueConst,\n  JSValue,\n  QuickJSHandle,\n  ContextOptions,\n  ContextEvalOptions,\n  RuntimeOptions,\n  AsyncRuntimeOptions,\n  RuntimeOptionsBase,\n  JSModuleLoader,\n  JSModuleLoadResult,\n  JSModuleLoaderAsync,\n  JSModuleLoadSuccess,\n  JSModuleLoadFailure,\n  JSModuleNormalizer,\n  JSModuleNormalizerAsync,\n  JSModuleNormalizeResult,\n  JSModuleNormalizeFailure,\n  JSModuleNormalizeSuccess,\n  Intrinsics,\n} from \"./types\"\nexport { DefaultIntrinsics } from \"./types\"\nexport type { ModuleEvalOptions } from \"./module\"\nexport { QuickJSPropertyKey } from \"./context\"\nexport { debugLog } from \"./debug\"\n","import type {\n  QuickJSSyncVariant,\n  QuickJSAsyncVariant,\n  QuickJSVariant,\n  EmscriptenModuleLoaderOptions,\n  SourceMapData,\n  QuickJSEmscriptenExtensions,\n} from \"@jitl/quickjs-ffi-types\"\nimport type { QuickJSWASMModule } from \"./module.js\"\nimport type { QuickJSAsyncWASMModule } from \"./module-asyncify.js\"\nimport { QuickJSEmscriptenModuleError } from \"./errors.js\"\nimport { debugLog } from \"./debug.js\"\n\n// Otherwise we have build errors?\nexport { QuickJSSyncVariant, QuickJSAsyncVariant, QuickJSVariant }\n\nexport type PromisedDefault<T> =\n  | T\n  | Promise<T>\n  | Promise<{ default: T }>\n  | Promise<{ default: { default: T } }>\n\n/**\n * Create a new, completely isolated WebAssembly module containing the QuickJS library.\n * See the documentation on {@link QuickJSWASMModule}.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n *\n * @example\n * ```ts\n * const quickjs = new newQuickJSWASMModuleFromVariant(\n *   import('@jitl/quickjs-browser-release-sync-wasm')\n * )\n * ```\n */\nexport async function newQuickJSWASMModuleFromVariant(\n  /**\n   * A {@link QuickJSSyncVariant} to construct the WebAssembly module.\n   */\n  variantOrPromise: PromisedDefault<QuickJSSyncVariant>,\n): Promise<QuickJSWASMModule> {\n  const variant = smartUnwrap(await variantOrPromise)\n  const [wasmModuleLoader, QuickJSFFI, { QuickJSWASMModule }] = await Promise.all([\n    variant.importModuleLoader().then(smartUnwrap),\n    variant.importFFI(),\n    import(\"./module.js\").then(smartUnwrap),\n  ])\n  const wasmModule = await wasmModuleLoader()\n  wasmModule.type = \"sync\"\n  const ffi = new QuickJSFFI(wasmModule)\n  return new QuickJSWASMModule(wasmModule, ffi)\n}\n\n/**\n * Create a new, completely isolated WebAssembly module containing a version of the QuickJS library\n * compiled with Emscripten's [ASYNCIFY](https://emscripten.org/docs/porting/asyncify.html) transform.\n *\n * This version of the library offers features that enable synchronous code\n * inside the VM to interact with asynchronous code in the host environment.\n * See the documentation on {@link QuickJSAsyncWASMModule}, {@link QuickJSAsyncRuntime},\n * and {@link QuickJSAsyncContext}.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n *\n * @example\n * ```ts\n * const quickjs = new newQuickJSAsyncWASMModuleFromVariant(\n *   import('@jitl/quickjs-browser-debug-asyncify-wasm')\n * )\n * ```\n */\nexport async function newQuickJSAsyncWASMModuleFromVariant(\n  /**\n   * A {@link QuickJSAsyncVariant} to construct the WebAssembly module.\n   */\n  variantOrPromise: PromisedDefault<QuickJSAsyncVariant>,\n): Promise<QuickJSAsyncWASMModule> {\n  const variant = smartUnwrap(await variantOrPromise)\n  const [wasmModuleLoader, QuickJSAsyncFFI, { QuickJSAsyncWASMModule }] = await Promise.all([\n    variant.importModuleLoader().then(smartUnwrap),\n    variant.importFFI(),\n    import(\"./module-asyncify.js\").then(smartUnwrap),\n  ])\n  const wasmModule = await wasmModuleLoader()\n  wasmModule.type = \"async\"\n  const ffi = new QuickJSAsyncFFI(wasmModule)\n  return new QuickJSAsyncWASMModule(wasmModule, ffi)\n}\n\n/**\n * Helper intended to memoize the creation of a WebAssembly module.\n * ```typescript\n * const getDebugModule = memoizePromiseFactory(() => newQuickJSWASMModule(DEBUG_SYNC))\n * ```\n */\nexport function memoizePromiseFactory<T>(fn: () => Promise<T>): () => Promise<T> {\n  let promise: Promise<T> | undefined\n  return () => {\n    return (promise ??= fn())\n  }\n}\n\nfunction smartUnwrap<T extends object>(val: T | { default: T } | { default: { default: T } }): T {\n  if (val && `default` in val && val.default) {\n    if (val.default && `default` in val.default && val.default.default) {\n      return val.default.default\n    }\n    return val.default as T\n  }\n  return val as T\n}\n\nexport type OrLoader<T> = T | (() => Promise<T>)\n\nexport interface CustomizeVariantOptions {\n  /** If given, Emscripten will try to load the WebAssembly module data from this location (path or URI) as appropriate for the current platform. */\n  wasmLocation?: string\n  /** If given, Emscripten will compile the WebAssembly.Module from these bytes. */\n  wasmBinary?: OrLoader<ArrayBuffer>\n  /** If given, Emscripten will instantiate the WebAssembly.Instance from this existing WebAssembly.Module */\n  wasmModule?: OrLoader<WebAssembly.Module>\n  /** If given, use the Memory when instantiating the WebAssembly.Instance. */\n  wasmMemory?: OrLoader<WebAssembly.Memory>\n  /** If given, Emscripten will try to load the source map for the WebAssembly module from this location (path or URI) as appropriate for the current platform. */\n  wasmSourceMapLocation?: string\n  /** If given, we will provide the source map to Emscripten directly. This may only be respected if wasmModule is also provided. */\n  wasmSourceMapData?: OrLoader<string | SourceMapData>\n  /**\n   * If set, this method will be called when the runtime needs to load a file,\n   * such as a .wasm WebAssembly file, .mem memory init file, or a file\n   * generated by the file packager.\n   *\n   * The function receives two parameters:\n   *\n   * - `fileName`, the relative path to the file as configured in build\n   * process, eg `\"emscripten-module.wasm\"`.\n   * - `prefix` (path to the main JavaScript file’s directory). This may be `''`\n   * (empty string) in some cases if the Emscripten Javascript code can't locate\n   * itself. Try logging it in your environment.\n   *\n   * It should return the actual URI or path to the requested file.\n   *\n   * This lets you host file packages on a different location than the directory\n   * of the JavaScript file (which is the default expectation), for example if\n   * you want to host them on a CDN.\n   */\n  locateFile?: EmscriptenModuleLoaderOptions[\"locateFile\"]\n  /** The enumerable properties of this object will be passed verbatim, although they may be overwritten if you pass other options. */\n  emscriptenModule?: EmscriptenModuleLoaderOptions\n  /** Debug logger */\n  log?: typeof console.log\n}\n\n/**\n * Create a new variant by overriding how Emscripten obtains the WebAssembly module.\n * This may be necessary in Cloudflare Workers, which can't compile WebAssembly modules from binary data.\n */\nexport function newVariant<T extends QuickJSVariant>(\n  baseVariant: T,\n  options: CustomizeVariantOptions,\n): T {\n  const variant: T = {\n    ...baseVariant,\n    async importModuleLoader() {\n      const moduleLoader = smartUnwrap(await baseVariant.importModuleLoader())\n      return async function newModuleLoader() {\n        const moduleLoaderArg: EmscriptenModuleLoaderOptions = options.emscriptenModule\n          ? { ...options.emscriptenModule }\n          : {}\n        const log =\n          options.log ?? ((...args: unknown[]) => debugLog(\"newVariant moduleLoader:\", ...args))\n        const tapValue = <T>(message: unknown[], val: T) => {\n          log(...message, val)\n          return val\n        }\n\n        const force = <T>(val: OrLoader<T> | undefined): T | undefined | Promise<T> => {\n          if (typeof val === \"function\") {\n            return (val as () => Promise<T>)()\n          }\n          return val\n        }\n\n        if (options.wasmLocation || options.wasmSourceMapLocation || options.locateFile) {\n          moduleLoaderArg.locateFile = (fileName: string, relativeTo: string) => {\n            const args = { fileName, relativeTo }\n            if (fileName.endsWith(\".wasm\") && options.wasmLocation !== undefined) {\n              return tapValue(\n                [\"locateFile .wasm: provide wasmLocation\", args],\n                options.wasmLocation,\n              )\n            }\n\n            if (fileName.endsWith(\".map\")) {\n              if (options.wasmSourceMapLocation !== undefined) {\n                return tapValue(\n                  [\"locateFile .map: provide wasmSourceMapLocation\", args],\n                  options.wasmSourceMapLocation,\n                )\n              }\n\n              if (options.wasmLocation && !options.locateFile) {\n                return tapValue(\n                  [\"locateFile .map: infer from wasmLocation\", args],\n                  options.wasmLocation + \".map\",\n                )\n              }\n            }\n\n            if (options.locateFile) {\n              return tapValue(\n                [\"locateFile: use provided fn\", args],\n                options.locateFile(fileName, relativeTo),\n              )\n            }\n\n            return tapValue([\"locateFile: unhandled, passthrough\", args], fileName)\n          }\n        }\n\n        if (options.wasmBinary) {\n          moduleLoaderArg.wasmBinary = await force(options.wasmBinary)\n        }\n\n        if (options.wasmMemory) {\n          moduleLoaderArg.wasmMemory = await force(options.wasmMemory)\n        }\n\n        const optionsWasmModule = options.wasmModule\n        let modulePromise: Promise<WebAssembly.Module | undefined> | undefined\n        if (optionsWasmModule) {\n          moduleLoaderArg.instantiateWasm = async (imports, onSuccess) => {\n            modulePromise ??= Promise.resolve(force(optionsWasmModule))\n            const wasmModule = await modulePromise\n            if (!wasmModule) {\n              // This should never happen\n              throw new QuickJSEmscriptenModuleError(\n                `options.wasmModule returned ${String(wasmModule)}`,\n              )\n            }\n            const instance = await WebAssembly.instantiate(wasmModule, imports)\n            onSuccess(instance)\n            return instance.exports\n          }\n        }\n\n        moduleLoaderArg.monitorRunDependencies = (left: number) => {\n          log(\"monitorRunDependencies:\", left)\n        }\n\n        // This will be replaced with the actual function by --pre-js\n        // Having the mock around makes our code simpler gives us handy logging\n        // if we need to understand any issues\n        moduleLoaderArg.quickjsEmscriptenInit = () => newMockExtensions(log)\n\n        const resultPromise = moduleLoader(moduleLoaderArg)\n        const extensions = moduleLoaderArg.quickjsEmscriptenInit?.(log)\n        if (\n          optionsWasmModule &&\n          extensions?.receiveWasmOffsetConverter &&\n          !extensions.existingWasmOffsetConverter\n        ) {\n          // Unlikely to be available, we'll usually end up mocking this.\n          // Still if the user has both, we'll take it.\n          const wasmBinary = (await force(options.wasmBinary)) ?? new ArrayBuffer(0)\n\n          modulePromise ??= Promise.resolve(force(optionsWasmModule))\n          const wasmModule = await modulePromise\n          if (!wasmModule) {\n            // This should never happen\n            throw new QuickJSEmscriptenModuleError(\n              `options.wasmModule returned ${String(wasmModule)}`,\n            )\n          }\n          extensions.receiveWasmOffsetConverter(wasmBinary, wasmModule)\n        }\n\n        if (extensions?.receiveSourceMapJSON) {\n          const loadedSourceMapData = await force(options.wasmSourceMapData)\n          if (typeof loadedSourceMapData === \"string\") {\n            extensions.receiveSourceMapJSON(JSON.parse(loadedSourceMapData))\n          } else if (loadedSourceMapData) {\n            extensions.receiveSourceMapJSON(loadedSourceMapData)\n          } else {\n            extensions.receiveSourceMapJSON({ version: 3, names: [], sources: [], mappings: \"\" })\n          }\n        }\n\n        return resultPromise\n      }\n    },\n  }\n  return variant\n}\n\nfunction newMockExtensions(log: typeof console.log): QuickJSEmscriptenExtensions {\n  const mockMessage = `mock called, emscripten module may not be initialized yet`\n  return {\n    mock: true,\n    removeRunDependency(name: string) {\n      log(`${mockMessage}: removeRunDependency called:`, name)\n    },\n    receiveSourceMapJSON(data: unknown) {\n      log(`${mockMessage}: receiveSourceMapJSON called:`, data)\n    },\n    WasmOffsetConverter: undefined,\n    receiveWasmOffsetConverter(bytes: ArrayBuffer, mod: WebAssembly.Module) {\n      log(`${mockMessage}: receiveWasmOffsetConverter called:`, bytes, mod)\n    },\n  }\n}\n","/**\n * Used as an optional.\n * `{ value: S } | { error: E }`.\n */\nexport type SuccessOrFail<S, F> =\n  | {\n      value: S\n      error?: undefined\n    }\n  | {\n      error: F\n    }\n\nexport function isSuccess<S, F>(successOrFail: SuccessOrFail<S, F>): successOrFail is { value: S } {\n  return \"error\" in successOrFail === false\n}\n\nexport function isFail<S, F>(successOrFail: SuccessOrFail<S, F>): successOrFail is { error: F } {\n  return \"error\" in successOrFail === true\n}\n\n/**\n * Used as an optional for results of a Vm call.\n * `{ value: VmHandle } | { error: VmHandle }`.\n */\nexport type VmCallResult<VmHandle> = SuccessOrFail<VmHandle, VmHandle>\n\n/**\n * A VmFunctionImplementation takes handles as arguments.\n * It should return a handle, or be void.\n *\n * To indicate an exception, a VMs can throw either a handle (transferred\n * directly) or any other Javascript value (only the poperties `name` and\n * `message` will be transferred). Or, the VmFunctionImplementation may return\n * a VmCallResult's `{ error: handle }` error variant.\n *\n * VmFunctionImplementation should not free its arguments or its return value.\n * It should not retain a reference to its return value or thrown error.\n */\nexport type VmFunctionImplementation<VmHandle> = (\n  this: VmHandle,\n  ...args: VmHandle[]\n) => VmHandle | VmCallResult<VmHandle> | void\n\n/**\n * A minimal interface to a Javascript execution environment.\n *\n * Higher-level tools should build over the LowLevelJavascriptVm interface to\n * share as much as possible between executors.\n *\n * From https://www.figma.com/blog/how-we-built-the-figma-plugin-system/\n */\nexport interface LowLevelJavascriptVm<VmHandle> {\n  global: VmHandle\n  undefined: VmHandle\n\n  typeof(handle: VmHandle): string\n\n  getNumber(handle: VmHandle): number\n  getString(handle: VmHandle): string\n\n  newNumber(value: number): VmHandle\n  newString(value: string): VmHandle\n  newObject(prototype?: VmHandle): VmHandle\n  newFunction(name: string, value: VmFunctionImplementation<VmHandle>): VmHandle\n\n  // For accessing properties of objects\n  getProp(handle: VmHandle, key: string | VmHandle): VmHandle\n  setProp(handle: VmHandle, key: string | VmHandle, value: VmHandle): void\n  defineProp(\n    handle: VmHandle,\n    key: string | VmHandle,\n    descriptor: VmPropertyDescriptor<VmHandle>,\n  ): void\n\n  callFunction(func: VmHandle, thisVal: VmHandle, ...args: VmHandle[]): VmCallResult<VmHandle>\n  evalCode(code: string, filename?: string): VmCallResult<VmHandle>\n}\n\n/**\n * From https://www.figma.com/blog/how-we-built-the-figma-plugin-system/\n */\nexport interface VmPropertyDescriptor<VmHandle> {\n  value?: VmHandle\n  configurable?: boolean\n  enumerable?: boolean\n  get?: (this: VmHandle) => VmHandle\n  set?: (this: VmHandle, value: VmHandle) => void\n}\n","import type { InterruptHandler } from \"./runtime\"\n\n/**\n * Returns an interrupt handler that interrupts Javascript execution after a deadline time.\n *\n * @param deadline - Interrupt execution if it's still running after this time.\n *   Number values are compared against `Date.now()`\n */\nexport function shouldInterruptAfterDeadline(deadline: Date | number): InterruptHandler {\n  const deadlineAsNumber = typeof deadline === \"number\" ? deadline : deadline.getTime()\n\n  return function () {\n    return Date.now() > deadlineAsNumber\n  }\n}\n","import type { QuickJSContext } from \"./context\"\nimport type { ModuleEvalOptions, QuickJSWASMModule } from \"./module\"\nimport type { QuickJSRuntime } from \"./runtime\"\nimport type { ContextOptions, RuntimeOptions } from \"./types\"\nimport { QuickJSMemoryLeakDetected } from \"./errors\"\nimport { Lifetime } from \"./lifetime\"\n\n/**\n * A test wrapper of {@link QuickJSWASMModule} that keeps a reference to each\n * context or runtime created.\n *\n * Call {@link disposeAll} to reset these sets and calls `dispose` on any left alive\n * (which may throw an error).\n *\n * Call {@link assertNoMemoryAllocated} at the end of a test, when you expect that you've\n * freed all the memory you've ever allocated.\n */\nexport class TestQuickJSWASMModule implements Pick<QuickJSWASMModule, keyof QuickJSWASMModule> {\n  contexts = new Set<QuickJSContext>()\n  runtimes = new Set<QuickJSRuntime>()\n  constructor(private parent: QuickJSWASMModule) {}\n\n  newRuntime(options?: RuntimeOptions): QuickJSRuntime {\n    const runtime = this.parent.newRuntime({\n      ...options,\n      ownedLifetimes: [\n        new Lifetime(undefined, undefined, () => this.runtimes.delete(runtime)),\n        ...(options?.ownedLifetimes ?? []),\n      ],\n    })\n    this.runtimes.add(runtime)\n    return runtime\n  }\n\n  newContext(options?: ContextOptions): QuickJSContext {\n    const context = this.parent.newContext({\n      ...options,\n      ownedLifetimes: [\n        new Lifetime(undefined, undefined, () => this.contexts.delete(context)),\n        ...(options?.ownedLifetimes ?? []),\n      ],\n    })\n    this.contexts.add(context)\n    return context\n  }\n\n  evalCode(code: string, options?: ModuleEvalOptions): unknown {\n    return this.parent.evalCode(code, options)\n  }\n\n  disposeAll() {\n    const allDisposables = [...this.contexts, ...this.runtimes]\n    this.runtimes.clear()\n    this.contexts.clear()\n    allDisposables.forEach((d) => {\n      if (d.alive) {\n        d.dispose()\n      }\n    })\n  }\n\n  assertNoMemoryAllocated() {\n    const leaksDetected = this.getFFI().QTS_RecoverableLeakCheck()\n    if (leaksDetected) {\n      // Note: this is currently only available when building from source\n      // with debug builds.\n      throw new QuickJSMemoryLeakDetected(\"Leak sanitizer detected un-freed memory\")\n    }\n\n    if (this.contexts.size > 0) {\n      throw new QuickJSMemoryLeakDetected(`${this.contexts.size} contexts leaked`)\n    }\n\n    if (this.runtimes.size > 0) {\n      throw new QuickJSMemoryLeakDetected(`${this.runtimes.size} runtimes leaked`)\n    }\n  }\n\n  getWasmMemory(): WebAssembly.Memory {\n    return this.parent.getWasmMemory()\n  }\n\n  /** @private */\n  getFFI() {\n    return this.parent.getFFI()\n  }\n}\n"],"mappings":"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","names":["debugLog","args","QTS_DEBUG","init_debug","__esmMin","errors_exports","__export","QuickJSAsyncifyError","QuickJSAsyncifySuspended","QuickJSEmscriptenModuleError","QuickJSMemoryLeakDetected","QuickJSNotImplemented","QuickJSPromisePending","QuickJSUnknownIntrinsic","QuickJSUnwrapError","QuickJSUseAfterFree","QuickJSWrongOwner","init_errors","__esmMin","cause","context","awaitYield","value","awaitYieldOf","generator","awaitEachYieldedPromise","maybeAsyncFn","that","fn","args","AwaitYield","maybeAsync","startGenerator","gen","handleNextStep","step","error","init_asyncify_helpers","__esmMin","scopeFinally","scope","blockError","disposeError","error","UsingDisposable","SymbolDispose","prototypeAsAny","Lifetime","StaticLifetime","WeakLifetime","Scope","init_lifetime","__esmMin","init_asyncify_helpers","init_debug","init_errors","_Lifetime","_value","copier","disposer","_owner","QTS_DEBUG","map","result","QuickJSUseAfterFree","value","owner","_Scope","block","_this","maybeAsync","awaited","lifetime","lifetimes","QuickJSDeferredPromise","init_deferred_promise","__esmMin","init_lifetime","UsingDisposable","args","value","resolve","ModuleMemory","init_memory","__esmMin","init_lifetime","module","handleArray","typedArray","handle","numBytes","ptr","Lifetime","length","zeros","value","string","strlen","dataBytes","buffer","str","intrinsicsToFlags","intrinsics","result","maybeIntrinsicName","enabled","QuickJSUnknownIntrinsic","evalOptionsToFlags","evalOptions","type","strict","strip","compileOnly","backtraceBarrier","flags","concat","values","value","import_quickjs_ffi_types","UnstableSymbol","DefaultIntrinsics","init_types","__esmMin","init_errors","import_quickjs_ffi_types","ContextMemory","QuickJSContext","init_context","__esmMin","init_debug","init_deferred_promise","init_errors","init_lifetime","init_memory","init_types","ModuleMemory","args","Scope","ptr","lifetime","str","Lifetime","UsingDisposable","ctx","this_ptr","argc","argv","fn_id","fn","awaited","scope","thisHandle","WeakLifetime","argHandles","i","result","debugLog","handle","error","errorHandle","StaticLifetime","num","charHandle","description","key","bigIntHandle","asString","prototype","buffer","array","value","deferredPromise","mutablePointerArray","promisePtr","promiseHandle","resolveHandle","rejectHandle","jsvaluePtr","QuickJSDeferredPromise","name","fnId","len","state","QuickJSPromisePending","promiseLikeHandle","vmResolveResult","vmPromise","vmPromiseResolve","resolve","promiseThenHandle","quickJSKey","descriptor","configurable","enumerable","hasValue","get","set","func","thisVal","resultPtr","argsArrayPtr","errorPtr","code","filename","options","detectModule","flags","evalOptionsToFlags","rt","type","asPromiseState","context","cause","message","stack","exception","QuickJSUnwrapError","hostStack","map_id","fnMap","QuickJSRuntime","init_runtime","__esmMin","init_asyncify_helpers","init_context","init_debug","init_errors","init_lifetime","init_memory","init_types","UsingDisposable","args","Scope","rt","fn","maybeAsyncFn","awaited","ctx","moduleName","moduleLoader","context","result","debugLog","moduleSource","error","baseModuleName","moduleNameRequest","moduleNormalizer","name","lifetime","ModuleMemory","options","intrinsics","intrinsicsToFlags","Lifetime","ctx_ptr","QuickJSContext","cb","prevInterruptHandler","maxJobsToExecute","ctxPtrOut","valuePtr","ctxPtr","resultValue","executedJobs","limitBytes","serviceContextMemory","stackSize","handle","QuickJSWrongOwner","module_exports","__export","QuickJSModuleCallbacks","QuickJSWASMModule","applyBaseRuntimeOptions","applyModuleEvalRuntimeOptions","runtime","options","QuickJSEmscriptenModuleCallbacks","init_module","__esmMin","init_debug","init_errors","init_lifetime","init_runtime","init_types","args","module","asyncify","ctx","this_ptr","argc","argv","fn_id","vm","error","rt","moduleName","runtimeCallbacks","loadModule","moduleBaseName","normalizeModule","callbacks","fn","done","result","debugLog","QuickJSAsyncifyError","QuickJSAsyncifySuspended","resolvedResult","value","ffi","Lifetime","rt_ptr","QuickJSRuntime","context","concat","code","Scope","scope","memory","QuickJSAsyncContext","init_context_asyncify","__esmMin","init_context","init_debug","init_types","QuickJSContext","code","filename","options","detectModule","flags","evalOptionsToFlags","resultPtr","charHandle","error","debugLog","errorPtr","name","fn","QuickJSAsyncRuntime","init_runtime_asyncify","__esmMin","init_context_asyncify","init_runtime","init_types","init_lifetime","QuickJSRuntime","args","options","intrinsics","intrinsicsToFlags","ctx","Lifetime","ctx_ptr","context","QuickJSAsyncContext","moduleLoader","moduleNormalizer","stackSize","module_asyncify_exports","__export","QuickJSAsyncWASMModule","init_module_asyncify","__esmMin","init_errors","init_lifetime","init_module","init_runtime_asyncify","QuickJSWASMModule","module","ffi","options","rt","Lifetime","rt_ptr","runtime","QuickJSAsyncRuntime","applyBaseRuntimeOptions","lifetimes","context","QuickJSNotImplemented","code","Scope","scope","vm","applyModuleEvalRuntimeOptions","result","src_exports","__export","DefaultIntrinsics","Lifetime","QuickJSAsyncContext","QuickJSAsyncRuntime","QuickJSAsyncWASMModule","QuickJSContext","QuickJSDeferredPromise","QuickJSRuntime","QuickJSWASMModule","Scope","StaticLifetime","TestQuickJSWASMModule","UsingDisposable","WeakLifetime","debugLog","errors_exports","isFail","isSuccess","memoizePromiseFactory","newQuickJSAsyncWASMModuleFromVariant","newQuickJSWASMModuleFromVariant","newVariant","shouldInterruptAfterDeadline","__toCommonJS","__reExport","init_module","init_context","init_runtime","init_module_asyncify","init_runtime_asyncify","init_context_asyncify","init_errors","init_debug","newQuickJSWASMModuleFromVariant","variantOrPromise","variant","smartUnwrap","wasmModuleLoader","QuickJSFFI","QuickJSWASMModule","wasmModule","ffi","newQuickJSAsyncWASMModuleFromVariant","QuickJSAsyncFFI","QuickJSAsyncWASMModule","memoizePromiseFactory","fn","promise","val","newVariant","baseVariant","options","moduleLoader","moduleLoaderArg","log","args","debugLog","tapValue","message","force","fileName","relativeTo","optionsWasmModule","modulePromise","imports","onSuccess","QuickJSEmscriptenModuleError","instance","left","newMockExtensions","resultPromise","extensions","wasmBinary","loadedSourceMapData","mockMessage","name","data","bytes","mod","isSuccess","successOrFail","isFail","init_lifetime","shouldInterruptAfterDeadline","deadline","deadlineAsNumber","init_errors","init_deferred_promise","init_errors","init_lifetime","TestQuickJSWASMModule","parent","options","runtime","Lifetime","context","code","allDisposables","d","QuickJSMemoryLeakDetected","init_types","init_debug"]}