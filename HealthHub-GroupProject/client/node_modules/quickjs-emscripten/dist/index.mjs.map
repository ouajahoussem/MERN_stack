{"version":3,"sources":["../src/index.ts","../src/mod.ts"],"sourcesContent":["export * from \"quickjs-emscripten-core\"\nexport * from \"#variants\"\nexport * from \"./mod.js\"\n","import type {\n  AsyncRuntimeOptions,\n  ContextOptions,\n  QuickJSAsyncContext,\n  QuickJSAsyncRuntime,\n  QuickJSWASMModule,\n} from \"quickjs-emscripten-core\"\nimport { newQuickJSAsyncWASMModule, newQuickJSWASMModule } from \"#variants\"\n\nlet singleton: QuickJSWASMModule | undefined = undefined\nlet singletonPromise: Promise<QuickJSWASMModule> | undefined = undefined\n\n/**\n * Get a shared singleton {@link QuickJSWASMModule}. Use this to evaluate code\n * or create Javascript environments.\n *\n * This is the top-level entrypoint for the quickjs-emscripten library.\n *\n * If you need strictest possible isolation guarantees, you may create a\n * separate {@link QuickJSWASMModule} via {@link newQuickJSWASMModule}.\n *\n * To work with the asyncified version of this library, see these functions:\n *\n * - {@link newAsyncRuntime}.\n * - {@link newAsyncContext}.\n * - {@link newQuickJSAsyncWASMModule}.\n */\nexport async function getQuickJS(): Promise<QuickJSWASMModule> {\n  singletonPromise ??= newQuickJSWASMModule().then((instance) => {\n    singleton = instance\n    return instance\n  })\n  return await singletonPromise\n}\n\n/**\n * Provides synchronous access to the shared {@link QuickJSWASMModule} instance returned by {@link getQuickJS}, as long as\n * least once.\n * @throws If called before `getQuickJS` resolves.\n */\nexport function getQuickJSSync(): QuickJSWASMModule {\n  if (!singleton) {\n    throw new Error(\"QuickJS not initialized. Await getQuickJS() at least once.\")\n  }\n  return singleton\n}\n\n/**\n * Create a new {@link QuickJSAsyncRuntime} in a separate WebAssembly module.\n *\n * Each runtime is isolated in a separate WebAssembly module, so that errors in\n * one runtime cannot contaminate another runtime, and each runtime can execute\n * an asynchronous action without conflicts.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nexport async function newAsyncRuntime(options?: AsyncRuntimeOptions): Promise<QuickJSAsyncRuntime> {\n  const module = await newQuickJSAsyncWASMModule()\n  return module.newRuntime(options)\n}\n\n/**\n * Create a new {@link QuickJSAsyncContext} (with an associated runtime) in an\n * separate WebAssembly module.\n *\n * Each context is isolated in a separate WebAssembly module, so that errors in\n * one runtime cannot contaminate another runtime, and each runtime can execute\n * an asynchronous action without conflicts.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nexport async function newAsyncContext(options?: ContextOptions): Promise<QuickJSAsyncContext> {\n  const module = await newQuickJSAsyncWASMModule()\n  return module.newContext(options)\n}\n"],"mappings":"4EAAA,WAAc,0BCSd,IAAIA,EACAC,EAiBJ,eAAsBC,GAAyC,CAC7D,OAAAD,MAAqBE,EAAqB,EAAE,KAAMC,IAChDJ,EAAYI,EACLA,EACR,GACM,MAAMH,CACf,CAOO,SAASI,GAAoC,CAClD,GAAI,CAACL,EACH,MAAM,IAAI,MAAM,4DAA4D,EAE9E,OAAOA,CACT,CAaA,eAAsBM,EAAgBC,EAA6D,CAEjG,OADe,MAAMC,EAA0B,GACjC,WAAWD,CAAO,CAClC,CAcA,eAAsBE,EAAgBF,EAAwD,CAE5F,OADe,MAAMC,EAA0B,GACjC,WAAWD,CAAO,CAClC","names":["singleton","singletonPromise","getQuickJS","newQuickJSWASMModule","instance","getQuickJSSync","newAsyncRuntime","options","newQuickJSAsyncWASMModule","newAsyncContext"]}