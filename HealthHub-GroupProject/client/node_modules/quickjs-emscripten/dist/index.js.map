{"version":3,"sources":["../src/index.ts","../src/variants.ts","../src/mod.ts"],"sourcesContent":["export * from \"quickjs-emscripten-core\"\nexport * from \"#variants\"\nexport * from \"./mod.js\"\n","import type {\n  QuickJSSyncVariant,\n  QuickJSAsyncVariant,\n  QuickJSWASMModule,\n  QuickJSAsyncWASMModule,\n  PromisedDefault,\n} from \"quickjs-emscripten-core\"\nimport {\n  newQuickJSWASMModuleFromVariant,\n  newQuickJSAsyncWASMModuleFromVariant,\n} from \"quickjs-emscripten-core\"\nimport DEBUG_SYNC from \"@jitl/quickjs-wasmfile-debug-sync\"\nimport RELEASE_SYNC from \"@jitl/quickjs-wasmfile-release-sync\"\nimport DEBUG_ASYNC from \"@jitl/quickjs-wasmfile-debug-asyncify\"\nimport RELEASE_ASYNC from \"@jitl/quickjs-wasmfile-release-asyncify\"\n\n/**\n * Create a new, completely isolated WebAssembly module containing the QuickJS library.\n * See the documentation on {@link QuickJSWASMModule}.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nexport async function newQuickJSWASMModule(\n  /**\n   * Optionally, pass a {@link QuickJSSyncVariant} to construct a different WebAssembly module.\n   */\n  variantOrPromise: PromisedDefault<QuickJSSyncVariant> = RELEASE_SYNC,\n): Promise<QuickJSWASMModule> {\n  return newQuickJSWASMModuleFromVariant(variantOrPromise)\n}\n\n/**\n * Create a new, completely isolated WebAssembly module containing a version of the QuickJS library\n * compiled with Emscripten's [ASYNCIFY](https://emscripten.org/docs/porting/asyncify.html) transform.\n *\n * This version of the library offers features that enable synchronous code\n * inside the VM to interact with asynchronous code in the host environment.\n * See the documentation on {@link QuickJSAsyncWASMModule}, {@link QuickJSAsyncRuntime},\n * and {@link QuickJSAsyncContext}.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nexport async function newQuickJSAsyncWASMModule(\n  /**\n   * Optionally, pass a {@link QuickJSAsyncVariant} to construct a different WebAssembly module.\n   */\n  variantOrPromise: PromisedDefault<QuickJSAsyncVariant> = RELEASE_ASYNC,\n): Promise<QuickJSAsyncWASMModule> {\n  return newQuickJSAsyncWASMModuleFromVariant(variantOrPromise)\n}\n\nexport { DEBUG_SYNC, RELEASE_SYNC, DEBUG_ASYNC, RELEASE_ASYNC }\n","import type {\n  AsyncRuntimeOptions,\n  ContextOptions,\n  QuickJSAsyncContext,\n  QuickJSAsyncRuntime,\n  QuickJSWASMModule,\n} from \"quickjs-emscripten-core\"\nimport { newQuickJSAsyncWASMModule, newQuickJSWASMModule } from \"#variants\"\n\nlet singleton: QuickJSWASMModule | undefined = undefined\nlet singletonPromise: Promise<QuickJSWASMModule> | undefined = undefined\n\n/**\n * Get a shared singleton {@link QuickJSWASMModule}. Use this to evaluate code\n * or create Javascript environments.\n *\n * This is the top-level entrypoint for the quickjs-emscripten library.\n *\n * If you need strictest possible isolation guarantees, you may create a\n * separate {@link QuickJSWASMModule} via {@link newQuickJSWASMModule}.\n *\n * To work with the asyncified version of this library, see these functions:\n *\n * - {@link newAsyncRuntime}.\n * - {@link newAsyncContext}.\n * - {@link newQuickJSAsyncWASMModule}.\n */\nexport async function getQuickJS(): Promise<QuickJSWASMModule> {\n  singletonPromise ??= newQuickJSWASMModule().then((instance) => {\n    singleton = instance\n    return instance\n  })\n  return await singletonPromise\n}\n\n/**\n * Provides synchronous access to the shared {@link QuickJSWASMModule} instance returned by {@link getQuickJS}, as long as\n * least once.\n * @throws If called before `getQuickJS` resolves.\n */\nexport function getQuickJSSync(): QuickJSWASMModule {\n  if (!singleton) {\n    throw new Error(\"QuickJS not initialized. Await getQuickJS() at least once.\")\n  }\n  return singleton\n}\n\n/**\n * Create a new {@link QuickJSAsyncRuntime} in a separate WebAssembly module.\n *\n * Each runtime is isolated in a separate WebAssembly module, so that errors in\n * one runtime cannot contaminate another runtime, and each runtime can execute\n * an asynchronous action without conflicts.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nexport async function newAsyncRuntime(options?: AsyncRuntimeOptions): Promise<QuickJSAsyncRuntime> {\n  const module = await newQuickJSAsyncWASMModule()\n  return module.newRuntime(options)\n}\n\n/**\n * Create a new {@link QuickJSAsyncContext} (with an associated runtime) in an\n * separate WebAssembly module.\n *\n * Each context is isolated in a separate WebAssembly module, so that errors in\n * one runtime cannot contaminate another runtime, and each runtime can execute\n * an asynchronous action without conflicts.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nexport async function newAsyncContext(options?: ContextOptions): Promise<QuickJSAsyncContext> {\n  const module = await newQuickJSAsyncWASMModule()\n  return module.newContext(options)\n}\n"],"mappings":"wmBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,mBAAAE,QAAA,iBAAAC,QAAA,oBAAAC,QAAA,mBAAAC,QAAA,eAAAC,EAAA,mBAAAC,EAAA,oBAAAC,EAAA,oBAAAC,EAAA,8BAAAC,EAAA,yBAAAC,IAAA,eAAAC,EAAAZ,GAAAa,EAAAb,EAAc,mCAAd,gBCOA,IAAAc,EAGO,mCACPC,EAAuB,gDACvBC,EAAyB,kDACzBC,EAAwB,oDACxBC,EAA0B,sDAU1B,eAAsBC,EAIpBC,EAAwD,EAAAC,QAC5B,CAC5B,SAAO,mCAAgCD,CAAgB,CACzD,CAeA,eAAsBE,EAIpBF,EAAyD,EAAAG,QACxB,CACjC,SAAO,wCAAqCH,CAAgB,CAC9D,CC5CA,IAAII,EACAC,EAiBJ,eAAsBC,GAAyC,CAC7D,OAAAD,MAAqBE,EAAqB,EAAE,KAAMC,IAChDJ,EAAYI,EACLA,EACR,GACM,MAAMH,CACf,CAOO,SAASI,GAAoC,CAClD,GAAI,CAACL,EACH,MAAM,IAAI,MAAM,4DAA4D,EAE9E,OAAOA,CACT,CAaA,eAAsBM,EAAgBC,EAA6D,CAEjG,OADe,MAAMC,EAA0B,GACjC,WAAWD,CAAO,CAClC,CAcA,eAAsBE,EAAgBF,EAAwD,CAE5F,OADe,MAAMC,EAA0B,GACjC,WAAWD,CAAO,CAClC","names":["src_exports","__export","DEBUG_ASYNC","DEBUG_SYNC","RELEASE_ASYNC","RELEASE_SYNC","getQuickJS","getQuickJSSync","newAsyncContext","newAsyncRuntime","newQuickJSAsyncWASMModule","newQuickJSWASMModule","__toCommonJS","__reExport","import_quickjs_emscripten_core","import_quickjs_wasmfile_debug_sync","import_quickjs_wasmfile_release_sync","import_quickjs_wasmfile_debug_asyncify","import_quickjs_wasmfile_release_asyncify","newQuickJSWASMModule","variantOrPromise","RELEASE_SYNC","newQuickJSAsyncWASMModule","RELEASE_ASYNC","singleton","singletonPromise","getQuickJS","newQuickJSWASMModule","instance","getQuickJSSync","newAsyncRuntime","options","newQuickJSAsyncWASMModule","newAsyncContext"]}